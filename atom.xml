<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>printf(&quot; I&#39;m EricWang &quot;)</title>
  
  
  <link href="http://wwssllabcd.github.io/atom.xml" rel="self"/>
  
  <link href="http://wwssllabcd.github.io/"/>
  <updated>2020-11-07T18:00:02.452Z</updated>
  <id>http://wwssllabcd.github.io/</id>
  
  <author>
    <name>EricWang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RPI-4 安裝 android tv</title>
    <link href="http://wwssllabcd.github.io/2020/11/08/how-to-intall-android-tv-in-raspberry-pi-4/"/>
    <id>http://wwssllabcd.github.io/2020/11/08/how-to-intall-android-tv-in-raspberry-pi-4/</id>
    <published>2020-11-07T17:07:44.000Z</published>
    <updated>2020-11-07T18:00:02.452Z</updated>
    
    <content type="html"><![CDATA[<p>首先你需要下載 android tv for raspberry pi 4 的 image file ，使用的是 LineageOS 17.1 Android TV (Android 10)</p><ul><li><a href="https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/">https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/</a></li></ul><p>在安裝之前有幾點要注意的</p><ul><li>只能支援 HDMI</li><li>最初解析度為 1920*1080</li></ul><p>所以說，如果你的螢幕是 DVI 的話，你可以離開了，因為不會有畫面，先提醒你以免白忙一場</p><p>下載後使用 Win32 Disk Imager 燒錄即可，這邊跟之前的 Rpi 做法並沒有不一樣，如果還是不行，那你可以參考以前的<a href="https://wwssllabcd.github.io/blog/2013/01/31/2013-01-31-how-to-setup-raspberry-pi/#%E5%AE%89%E8%A3%9D-OS">教學</a>，燒完後，插上卡片，直接開機就可以進入到 android tv 了</p><p>這邊有燒錄相關教學</p><ul><li><a href="https://ifunoffice.com/raspberry-pi-install-android9/">https://ifunoffice.com/raspberry-pi-install-android9/</a></li></ul><p>這邊也有一點很重要的要先講，就是如果你等下遇到任何問題找不到答案的，你應該要回去<a href="https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/">官網</a>找，那邊通常都已經有答案了</p><a id="more"></a><h2 id="下載需要的檔案"><a href="#下載需要的檔案" class="headerlink" title="下載需要的檔案"></a>下載需要的檔案</h2><p>在開始之前，我建議你先下載兩個，分別是    * <a href="https://opengapps.org/">gapp</a>    * <a href="https://androidfilehost.com/?fid=8889791610682901035">recover2boot</a> : 要刷這個, 才能從 twrp 回到 android os</p><p>去<a href="https://opengapps.org/">opengapp</a> 下載 gapp，我們要選 </p><ul><li>arm</li><li>android 10</li><li>tv stock</li></ul><p>選好之後就可以下載了</p><p>接下來要準備<code>recover2boot</code>，你可以在以下連結找到</p><ul><li><a href="https://androidfilehost.com/?fid=8889791610682901035">https://androidfilehost.com/?fid=8889791610682901035</a></li></ul><h2 id="關機-android-tv"><a href="#關機-android-tv" class="headerlink" title="關機 android tv "></a>關機 android tv </h2><p>這邊先提一下，關機選項在</p><pre><code>setting/device prrferance/about/shutdown</code></pre><h2 id="安裝-Google-app"><a href="#安裝-Google-app" class="headerlink" title="安裝 Google app"></a>安裝 Google app</h2><p>步驟有點多，主要流程為先打開 Developer option 後，開啟 root 與 terminal 後，你才可以切到 recover mode 做 twrp 並寫入 google app 到 rom 中，其實就是跟刷手機版本的 lineage 的 gapp 大同小異，以下是步驟</p><ul><li>打開 Developer option<ul><li>setting/about 後，按10下&quot;關於&quot;標籤就可以了，跟一般的 android 是一樣的作法，</li></ul></li><li>打開 root 權限<ul><li>一樣在 Developer options</li></ul></li><li>打開本機終端機<ul><li>在 Developer options</li></ul></li></ul><p>如果你在 Developer options 可以順利地打開<code>本機終端機</code>，你就可以去<code>應用程式</code>那邊就會看到，</p><p>進入本機終端機後，先打 </p><pre><code>su rpi4-recovery.sh </code></pre><p>接下來你就可以重開機了，如果順利的話你會進到 TRWP </p><h2 id="使用-TRWP-刷入-GAPP"><a href="#使用-TRWP-刷入-GAPP" class="headerlink" title="使用 TRWP 刷入 GAPP"></a>使用 TRWP 刷入 GAPP</h2><p>接下來你可以把剛剛下載的 gapp 與 recover2boot 放到 usb 上，並且插入 rpi4，此時你在 trwp 應該要可以認的到那隻 usb，接下來就要刷 gapp，刷法跟一般的手機刷法是一樣的，唯一不同的是刷 rpi 不會變磚，所以就大膽地刷吧</p><p>這邊列出步驟</p><ol><li>Download open_gapps-arm-10.0-tvstock-xxxxxxxx.zip and save it to your device’s internal storage or use an external USB drive</li><li>Boot to TWRP recovery (你應該已經進入了)</li><li>Install open_gapps-arm-10.0-tvstock-xxxxxxxx.zip from your selected storage</li><li>Wipe-&gt;Factory reset!</li><li>Boot out of recovery (see FAQ)</li></ol><p>這邊要注意的是，如果你刷好，並且重開機後，還是回到 TRWP，此時你就必須刷<code>recover2boot</code>，他可以切換 partition 到 boot，刷完之後重開機應該就能進入到 android tv 了，重開機之後，你應該就可以使用 googe store 了，之後應該就不用教了，裝自己喜歡的 app 吧，若還是卡關，這邊有其他刷 gapp 的相關教學，你可以參考看看</p><ul><li><a href="https://www.makeuseof.com/tag/build-android-tv-box-raspberry-pi/">https://www.makeuseof.com/tag/build-android-tv-box-raspberry-pi/</a></li><li><a href="https://itigic.com/install-android-tv-on-raspberry-pi-with-lineageos/">https://itigic.com/install-android-tv-on-raspberry-pi-with-lineageos/</a></li></ul><h2 id="android-tv-操作"><a href="#android-tv-操作" class="headerlink" title="android tv 操作"></a>android tv 操作</h2><p>這邊列出一些 android tv 的操作 </p><ul><li>F1 = Home, </li><li>F2 = Back, </li><li>F3 = Multi-tasking, </li><li>F4 = Menu, </li><li>F5 = Power, </li><li>F11 = Volume down,</li><li>F12 = Volume up. </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先你需要下載 android tv for raspberry pi 4 的 image file ，使用的是 LineageOS 17.1 Android TV (Android 10)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/&quot;&gt;https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在安裝之前有幾點要注意的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能支援 HDMI&lt;/li&gt;
&lt;li&gt;最初解析度為 1920*1080&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以說，如果你的螢幕是 DVI 的話，你可以離開了，因為不會有畫面，先提醒你以免白忙一場&lt;/p&gt;
&lt;p&gt;下載後使用 Win32 Disk Imager 燒錄即可，這邊跟之前的 Rpi 做法並沒有不一樣，如果還是不行，那你可以參考以前的&lt;a href=&quot;https://wwssllabcd.github.io/blog/2013/01/31/2013-01-31-how-to-setup-raspberry-pi/#%E5%AE%89%E8%A3%9D-OS&quot;&gt;教學&lt;/a&gt;，燒完後，插上卡片，直接開機就可以進入到 android tv 了&lt;/p&gt;
&lt;p&gt;這邊有燒錄相關教學&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ifunoffice.com/raspberry-pi-install-android9/&quot;&gt;https://ifunoffice.com/raspberry-pi-install-android9/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這邊也有一點很重要的要先講，就是如果你等下遇到任何問題找不到答案的，你應該要回去&lt;a href=&quot;https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/&quot;&gt;官網&lt;/a&gt;找，那邊通常都已經有答案了&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>kodi 教學，心得</title>
    <link href="http://wwssllabcd.github.io/2020/11/08/how-to-use-kodi/"/>
    <id>http://wwssllabcd.github.io/2020/11/08/how-to-use-kodi/</id>
    <published>2020-11-07T16:24:46.000Z</published>
    <updated>2020-11-07T16:58:13.009Z</updated>
    
    <content type="html"><![CDATA[<p>Kodi 是一套 media center 軟體，其前身為 xbmc，這邊列出一些相關的資源</p><h2 id="遠程控制-使用手機-APP-Yatse"><a href="#遠程控制-使用手機-APP-Yatse" class="headerlink" title="遠程控制 -- 使用手機 APP: Yatse"></a>遠程控制 -- 使用手機 APP: Yatse</h2><p>Yastse 是一款 Kodi 的遙控及投放工具，你可以在 google store 找到</p><p>不過你必須要先在 kodi 打開遠程控制，打開的地方在</p><pre><code>控制-&gt;允許通過 HTTP 遠程控制，允許異地程序遠程控制</code></pre><p>你也可以打開Web界面，這樣就可以直接使用瀏覽器控制 kodi</p><h2 id="遠程控制-使用-firefox"><a href="#遠程控制-使用-firefox" class="headerlink" title="遠程控制 -- 使用 firefox "></a>遠程控制 -- 使用 firefox </h2><p>Firefox 有很多 kodi 的套件可供遠端控制，這裡不再詳述</p><h2 id="使用-kodi-檔案總管，並從-usb-copy-檔案到-kodi"><a href="#使用-kodi-檔案總管，並從-usb-copy-檔案到-kodi" class="headerlink" title="使用 kodi 檔案總管，並從 usb copy 檔案到 kodi"></a>使用 kodi 檔案總管，並從 usb copy 檔案到 kodi</h2><p>選擇    系統-&gt;檔案總管</p><p>你就可以啟動 kodi 的檔案總管，左邊的框是操作的地方，按 C 可以叫出選單，按空白可以複選檔案例如你可以按 C 選複製，就會複製到右邊，若右邊的你找不到你要的路徑，就必須要新增瀏覽路徑</p><a id="more"></a><h2 id="調整音量音量"><a href="#調整音量音量" class="headerlink" title="調整音量音量"></a>調整音量音量</h2><ul><li>使用鍵盤上的 + - 鈕就可以</li><li>Yastse 也可以</li></ul><h2 id="設定-kodi-時間"><a href="#設定-kodi-時間" class="headerlink" title="設定 kodi 時間"></a>設定 kodi 時間</h2><ol><li>選擇 Settings &gt; Interface &gt; Regional.</li><li>注意你的 settings level 是在 Expert</li><li>如果是的話，你就可以看到 time zone 這個選項</li></ol><h2 id="安裝附加元件，遇到-kodi-script-module-urlresolver-error-dependency"><a href="#安裝附加元件，遇到-kodi-script-module-urlresolver-error-dependency" class="headerlink" title="安裝附加元件，遇到 kodi script module urlresolver error dependency"></a>安裝附加元件，遇到 kodi script module urlresolver error dependency</h2><p>請根據 error log, 下載相對應的 add-on，例如 </p><pre><code>urlsolver https://github.com/kodil/kodil/tree/master/repo/script.module.urlresolver</code></pre><p>這個代表你需要安裝 urlsolver</p><h2 id="收看直播電視"><a href="#收看直播電視" class="headerlink" title="收看直播電視"></a>收看直播電視</h2><p>必須要先安裝 add-on : <code>IPTV Simple PVR</code>，這個是 Kodi 的 IPTV 直播電視和廣播 PVR 客戶端插件，安裝完後，我們必須要指定 IPTV 要讀取哪一個直播節目的列表，IPTV 是使用 m3u8 的格式，所以我們必須要找到 m3u8 格式的直播來源</p><p>有很多 m3u8 的連結是可以 google 的到的，甚至你去 github 使用搜尋也可以找到很多，不過這個項目很大很複雜，所以之後會另開專頁說明</p><h2 id="安裝-youtube"><a href="#安裝-youtube" class="headerlink" title="安裝 youtube "></a>安裝 youtube </h2><p>你需要先安裝附加套件 Youtube，在 repository 可以找到，以下是該套件的原作者連結<a href="https://github.com/anxdpanic/plugin.video.youtube">https://github.com/anxdpanic/plugin.video.youtube</a></p><p>這邊是官方連結<a href="https://forum.kodi.tv/showthread.php?tid=356934">https://forum.kodi.tv/showthread.php?tid=356934</a></p><p>安裝完套件後，你還必須要建立 Youtube API key，可見以下連結的教學<a href="https://seo-michael.co.uk/how-to-create-your-own-youtube-api-key-id-and-secret/">https://seo-michael.co.uk/how-to-create-your-own-youtube-api-key-id-and-secret/</a></p><p>好像可以改外觀輸入密碼並允許許可後，您就可以開始了。 但是，它可能看起來不像包含所有視頻縮略圖的普通YouTube主頁。 要獲得該外觀，請從左側面板中將 Vi ewtype 更改為 Wall，如下所示</p><h2 id="安裝-Netflix"><a href="#安裝-Netflix" class="headerlink" title="安裝 Netflix "></a>安裝 Netflix </h2><p>也很麻煩，主要是登入的問題，我後來是使用 auth-key 才能登入</p><p>該套件的原始網站</p><ul><li><a href="https://github.com/CastagnaIT/plugin.video.netflix">https://github.com/CastagnaIT/plugin.video.netflix</a></li></ul><p>login with auth key  </p><ul><li><a href="https://github.com/CastagnaIT/plugin.video.netflix/wiki/Login-with-Authentication-key">https://github.com/CastagnaIT/plugin.video.netflix/wiki/Login-with-Authentication-key</a></li></ul><h2 id="kodi-套件介紹"><a href="#kodi-套件介紹" class="headerlink" title="kodi 套件介紹"></a>kodi 套件介紹</h2><ul><li>kodi 中文套件庫:  <ul><li>他是套件庫，所以只要裝這個的話，你就可以在裡面找到很多中文相關的套件，維護的不錯，很多開發者也會幫忙撰寫一些例如 bilibili, youku 的套件</li><li>該套件庫的官網<ul><li><a href="https://github.com/taxigps/xbmc-addons-chinese">https://github.com/taxigps/xbmc-addons-chinese</a></li></ul></li><li>介紹與安裝教學: <ul><li><a href="https://blog.gtwang.org/iot/openelec-xbmc-kodi-chinese-addons/">https://blog.gtwang.org/iot/openelec-xbmc-kodi-chinese-addons/</a></li><li><a href="https://github.com/imDazui/Tvlist-awesome-m3u-m3u8/blob/master/Kodi-addons.md">https://github.com/imDazui/Tvlist-awesome-m3u-m3u8/blob/master/Kodi-addons.md</a></li></ul></li></ul></li><li>kodi exodus: <ul><li>這是提供國外影片的套件</li><li><a href="https://ppkkkp.blogspot.com/2017/10/exodus-kodi-new.html">https://ppkkkp.blogspot.com/2017/10/exodus-kodi-new.html</a></li></ul></li><li>動畫瘋<ul><li><a href="https://github.com/YWJamesLin/bahamut_anime_player_kodi">https://github.com/YWJamesLin/bahamut_anime_player_kodi</a></li></ul></li><li>kodi 套件介紹<ul><li><a href="https://zh.vpnmentor.com/blog/%E9%9B%BB%E5%BD%B1%E5%8F%8A%E9%9B%BB%E8%A6%96%E5%B0%88%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3kodi%E9%99%84%E5%8A%A0%E5%85%83%E4%BB%B6/">https://zh.vpnmentor.com/blog/%E9%9B%BB%E5%BD%B1%E5%8F%8A%E9%9B%BB%E8%A6%96%E5%B0%88%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3kodi%E9%99%84%E5%8A%A0%E5%85%83%E4%BB%B6/</a></li><li><a href="https://zh.wizcase.com/blog/%E7%94%B5%E8%A7%86%E7%94%A8%E5%A4%A7kodi%E9%99%84%E5%8A%A0%E7%BB%84%E4%BB%B6%EF%BC%88%E5%90%AB%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97%EF%BC%89-%E5%B9%B4%E6%9B%B4%E6%96%B0/">https://zh.wizcase.com/blog/%E7%94%B5%E8%A7%86%E7%94%A8%E5%A4%A7kodi%E9%99%84%E5%8A%A0%E7%BB%84%E4%BB%B6%EF%BC%88%E5%90%AB%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97%EF%BC%89-%E5%B9%B4%E6%9B%B4%E6%96%B0/</a></li></ul></li></ul><h2 id="kodi-播放光碟機-CD-ROM"><a href="#kodi-播放光碟機-CD-ROM" class="headerlink" title="kodi 播放光碟機 (CD-ROM)"></a>kodi 播放光碟機 (CD-ROM)</h2><p>2 wayt to play</p><ul><li>使用主畫面左邊的選項上面會有播放光碟片的圖案，memu 應該會自動出現&quot;光碟&quot;選項才對</li><li>使用 cdrom 的路徑 <code>cdda://local/</code></li></ul><h2 id="自行撰寫-kodi-套件"><a href="#自行撰寫-kodi-套件" class="headerlink" title="自行撰寫 kodi 套件"></a>自行撰寫 kodi 套件</h2><p>這邊提供幾個 resource </p><p>kodi doc</p><ul><li><a href="https://codedocs.xyz/AlwinEsch/kodi/group__python.html">https://codedocs.xyz/AlwinEsch/kodi/group__python.html</a></li></ul><p>其他教學</p><ul><li><a href="https://kodi.wiki/view/HOW-TO:HelloWorld_addon">https://kodi.wiki/view/HOW-TO:HelloWorld_addon</a></li><li><a href="http://kfbiji.com/article/b15db97eceb78756">http://kfbiji.com/article/b15db97eceb78756</a></li><li><a href="https://pypi.org/project/kodi-addon-checker/">https://pypi.org/project/kodi-addon-checker/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kodi 是一套 media center 軟體，其前身為 xbmc，這邊列出一些相關的資源&lt;/p&gt;
&lt;h2 id=&quot;遠程控制-使用手機-APP-Yatse&quot;&gt;&lt;a href=&quot;#遠程控制-使用手機-APP-Yatse&quot; class=&quot;headerlink&quot; title=&quot;遠程控制 -- 使用手機 APP: Yatse&quot;&gt;&lt;/a&gt;遠程控制 -- 使用手機 APP: Yatse&lt;/h2&gt;&lt;p&gt;Yastse 是一款 Kodi 的遙控及投放工具，你可以在 google store 找到&lt;/p&gt;
&lt;p&gt;不過你必須要先在 kodi 打開遠程控制，打開的地方在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;控制-&amp;gt;允許通過 HTTP 遠程控制，允許異地程序遠程控制&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你也可以打開Web界面，這樣就可以直接使用瀏覽器控制 kodi&lt;/p&gt;
&lt;h2 id=&quot;遠程控制-使用-firefox&quot;&gt;&lt;a href=&quot;#遠程控制-使用-firefox&quot; class=&quot;headerlink&quot; title=&quot;遠程控制 -- 使用 firefox &quot;&gt;&lt;/a&gt;遠程控制 -- 使用 firefox &lt;/h2&gt;&lt;p&gt;Firefox 有很多 kodi 的套件可供遠端控制，這裡不再詳述&lt;/p&gt;
&lt;h2 id=&quot;使用-kodi-檔案總管，並從-usb-copy-檔案到-kodi&quot;&gt;&lt;a href=&quot;#使用-kodi-檔案總管，並從-usb-copy-檔案到-kodi&quot; class=&quot;headerlink&quot; title=&quot;使用 kodi 檔案總管，並從 usb copy 檔案到 kodi&quot;&gt;&lt;/a&gt;使用 kodi 檔案總管，並從 usb copy 檔案到 kodi&lt;/h2&gt;&lt;p&gt;選擇
    系統-&amp;gt;檔案總管&lt;/p&gt;
&lt;p&gt;你就可以啟動 kodi 的檔案總管，左邊的框是操作的地方，按 C 可以叫出選單，按空白可以複選檔案例如你可以按 C 選複製，就會複製到右邊，若右邊的你找不到你要的路徑，就必須要新增瀏覽路徑&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
    <category term="Kodi" scheme="http://wwssllabcd.github.io/tags/Kodi/"/>
    
  </entry>
  
  <entry>
    <title>how-to-install-kodi-in-raspberry-pi-4</title>
    <link href="http://wwssllabcd.github.io/2020/11/08/how-to-install-kodi-in-raspberry-pi-4/"/>
    <id>http://wwssllabcd.github.io/2020/11/08/how-to-install-kodi-in-raspberry-pi-4/</id>
    <published>2020-11-07T16:06:48.000Z</published>
    <updated>2020-11-07T16:58:00.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RPI-4-安裝-kodi-的心得"><a href="#RPI-4-安裝-kodi-的心得" class="headerlink" title="RPI 4 安裝 kodi 的心得"></a>RPI 4 安裝 kodi 的心得</h2><p>因為之前的rpi 效能都不太好，所以, 許久沒碰 rpi, 這次出了8GB 號稱可以接近桌機的效能，所以就買一台試看看</p><p>PS: 寫在前頭，如果你打算使用 DVI 螢幕當作 RPI 的螢幕的話，你可能要注意，rpi 有機會不能輸出畫面</p><h2 id="購買"><a href="#購買" class="headerlink" title="購買"></a>購買</h2><p>我這次是去台灣樹梅派購買的，我購買的是 8GB + 散熱殼，那個散熱殼我蠻滿意的，風扇也是靜音風扇，只是風扇安裝需要一點技巧，好像裝錯邊風扇就會很吵，記得風扇正反不要裝錯，有貼貼紙的地方是反面，否則你的風扇不會轉</p><h2 id="安裝-kodi，使用-LibreElec"><a href="#安裝-kodi，使用-LibreElec" class="headerlink" title="安裝 kodi，使用 LibreElec"></a>安裝 kodi，使用 LibreElec</h2><p>在 rpi 4 上面安裝 kodi 已經很簡單了，LibreElec 這個專案已經把 os + kodi 整合起來，所以我們就直接安裝 libreelec 就可以了，請到以下網站抓取 image file </p><p><a href="https://libreelec.tv/raspberry-pi-4/">https://libreelec.tv/raspberry-pi-4/</a></p><p>該網站提供的下載的檔案叫做 &quot;LibreELEC-RPi4.arm-9.2.6.img.gz&quot;，下載完後使用 7z，解開她得到 img file 後，就可以使用  Win32 Disk Imager 燒錄即可，這邊跟之前的 Rpi 做法並沒有不一樣</p><p>如果還是不行，那你可以參考以前的<a href="https://wwssllabcd.github.io/blog/2013/01/31/2013-01-31-how-to-setup-raspberry-pi/#%E5%AE%89%E8%A3%9D-OS">教學</a></p><p>燒完之後，插入至RPI後，接上電源就可以使用了</p><a id="more"></a><h2 id="常見問題"><a href="#常見問題" class="headerlink" title="常見問題"></a>常見問題</h2><h2 id="沒有畫面，沒有螢幕"><a href="#沒有畫面，沒有螢幕" class="headerlink" title="沒有畫面，沒有螢幕"></a>沒有畫面，沒有螢幕</h2><p>Raspberry Pi 僅支持具有 DVI-D 插槽的設備如果你的螢幕只能使用 DVI 的話就會很麻煩，特別是那種很古老的 DVI 介面，你必須要取得你螢幕能支援的解析度</p><p>所以你必須要能在 console 執行以下指令</p><pre><code>/opt/vc/bin/tvservice -d edid.dat/opt/vc/bin/edidparser edid.dat</code></pre><p>以便得到你螢幕的參數，但是你又沒螢幕，也看不到，自然也沒法輸入指令，這邊提供兩個做法</p><ol><li>你可以使用 ssh / telnet 的方式登入到 rpi ，自然就可以下指令</li><li>找一台可以順利顯示的螢幕，輸入上述 edid 指令後，先不要執行，然後再把你的螢幕接到不能顯示的螢幕上後，再去執行該指令後，再把螢幕接回來，這樣一來你就可以得到那台無法顯示畫面的螢幕的 edid 檔案了</li></ol><p>拿到參數後，關機後修改 config.txt ，你就可以根據螢幕回報的解析度組合，來設定能支援的參數，以下連結有 video option 可以參考</p><ul><li><a href="https://www.raspberrypi.org/documentation/configuration/config-txt/video.md">https://www.raspberrypi.org/documentation/configuration/config-txt/video.md</a></li><li><a href="https://elinux.org/RPiconfig#Video_mode_options">https://elinux.org/RPiconfig#Video_mode_options</a></li><li><a href="https://pimylifeup.com/raspberry-pi-screen-resolution/">https://pimylifeup.com/raspberry-pi-screen-resolution/</a></li></ul><p>主要就是要修改 <code>hdmi_group</code> 與  <code>hdmi_mode</code> 這兩個參數</p><h2 id="沒有畫面，沒有螢幕-continue"><a href="#沒有畫面，沒有螢幕-continue" class="headerlink" title="沒有畫面，沒有螢幕(continue)"></a>沒有畫面，沒有螢幕(continue)</h2><p>如果還是不行，可以試看看在 <code>config.txt</code> 中，設定 hdmi 的輸出的選項，如以下選項都可以試試</p><pre><code>hdmi_drive chooses between HDMI and DVI modeshdmi_drive=1 Normal DVI mode (No sound)hdmi_drive=2 Normal HDMI mode (Sound will be sent if supported and enabled)</code></pre><p>讓 config.txt 強制設定螢幕介面為你裝置的介面</p><h2 id="kodi-有畫面沒有聲音"><a href="#kodi-有畫面沒有聲音" class="headerlink" title="kodi 有畫面沒有聲音"></a>kodi 有畫面沒有聲音</h2><ul><li>把 hdmi 線改接到比較靠近電源的那個插孔(注意，RPI4 會有兩個 hdmi 輸出的接孔，靠近電源的那一個才是主要的輸出)</li><li>檢查 config.txt 是否為 <code>hdmi_drive=2</code></li><li>檢查 kodi 的設定，是否沒有設定成 hdmi 輸出音效</li><li>在系統設定那邊, 選[設定]-&gt;[音效設定], 檢查輸出設定是否為[hdmi or alalog]</li></ul><h2 id="SSH-打不開"><a href="#SSH-打不開" class="headerlink" title="SSH 打不開"></a>SSH 打不開</h2><p>可能是沒有安裝 ssh ，請使用指令安裝</p><pre><code>sudo service ssh start</code></pre><p>或者是根本沒安裝</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;RPI-4-安裝-kodi-的心得&quot;&gt;&lt;a href=&quot;#RPI-4-安裝-kodi-的心得&quot; class=&quot;headerlink&quot; title=&quot;RPI 4 安裝 kodi 的心得&quot;&gt;&lt;/a&gt;RPI 4 安裝 kodi 的心得&lt;/h2&gt;&lt;p&gt;因為之前的rpi 效能都不太好，所以, 許久沒碰 rpi, 這次出了8GB 號稱可以接近桌機的效能，所以就買一台試看看&lt;/p&gt;
&lt;p&gt;PS: 寫在前頭，如果你打算使用 DVI 螢幕當作 RPI 的螢幕的話，你可能要注意，rpi 有機會不能輸出畫面&lt;/p&gt;
&lt;h2 id=&quot;購買&quot;&gt;&lt;a href=&quot;#購買&quot; class=&quot;headerlink&quot; title=&quot;購買&quot;&gt;&lt;/a&gt;購買&lt;/h2&gt;&lt;p&gt;我這次是去台灣樹梅派購買的，我購買的是 8GB + 散熱殼，那個散熱殼我蠻滿意的，風扇也是靜音風扇，只是風扇安裝需要一點技巧，好像裝錯邊風扇就會很吵，記得風扇正反不要裝錯，有貼貼紙的地方是反面，否則你的風扇不會轉&lt;/p&gt;
&lt;h2 id=&quot;安裝-kodi，使用-LibreElec&quot;&gt;&lt;a href=&quot;#安裝-kodi，使用-LibreElec&quot; class=&quot;headerlink&quot; title=&quot;安裝 kodi，使用 LibreElec&quot;&gt;&lt;/a&gt;安裝 kodi，使用 LibreElec&lt;/h2&gt;&lt;p&gt;在 rpi 4 上面安裝 kodi 已經很簡單了，LibreElec 這個專案已經把 os + kodi 整合起來，所以我們就直接安裝 libreelec 就可以了，請到以下網站抓取 image file &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://libreelec.tv/raspberry-pi-4/&quot;&gt;https://libreelec.tv/raspberry-pi-4/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;該網站提供的下載的檔案叫做 &amp;quot;LibreELEC-RPi4.arm-9.2.6.img.gz&amp;quot;，下載完後使用 7z，解開她得到 img file 後，就可以使用  Win32 Disk Imager 燒錄即可，這邊跟之前的 Rpi 做法並沒有不一樣&lt;/p&gt;
&lt;p&gt;如果還是不行，那你可以參考以前的&lt;a href=&quot;https://wwssllabcd.github.io/blog/2013/01/31/2013-01-31-how-to-setup-raspberry-pi/#%E5%AE%89%E8%A3%9D-OS&quot;&gt;教學&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;燒完之後，插入至RPI後，接上電源就可以使用了&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>指數型投資(Investment of indexing)</title>
    <link href="http://wwssllabcd.github.io/2020/02/16/Investment-of-indexing/"/>
    <id>http://wwssllabcd.github.io/2020/02/16/Investment-of-indexing/</id>
    <published>2020-02-15T20:29:30.000Z</published>
    <updated>2020-11-07T16:58:07.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>這篇是給目前不能自己挑到好股票, 但又想做投資的人看的</li><li>這邊主要的核心概念是&quot;分散&quot;, 若是能挑到好股票的人看了這篇, 不但沒幫助, 反而會有害</li></ul><h2 id="核心概念-分散投資標的以降低風險"><a href="#核心概念-分散投資標的以降低風險" class="headerlink" title="核心概念 -- 分散投資標的以降低風險"></a>核心概念 -- 分散投資標的以降低風險</h2><ul><li>分散股票種類: 購買 ETF 分散投資目標的風險</li><li>分散購入時機: 定期定額</li><li>分散股票區域性: 購入全球 ETF</li><li>分散股票類型: 股票 + 債的資產配置</li></ul><p>我先講結論, 然後再慢慢解釋我為何這樣推薦, 而作法就是   </p><h3 id="quot-定期定額購買-指數型-ETF-quot"><a href="#quot-定期定額購買-指數型-ETF-quot" class="headerlink" title="&quot;定期定額購買 指數型 ETF &quot;"></a>&quot;定期定額購買 指數型 ETF &quot;</h3><p>方法很多種, 從簡單到複雜:   </p><ol><li>利用富邦證劵, 定期定額購買富邦采吉50(006208) ETF<ul><li>投資低消為 1000元, 適合小資上班族</li><li><a href="https://www.fubon.com/securities/hot_new/open-now/etf.html">富邦定期定額 ETF</a> 1萬元以內, 手續費只要1元</li></ul></li><li>利用複委託, 例如<a href="https://www.dcn.com.tw/re-consigned/charge.htm">大昌證券複委託</a> , 定期定額購買 VT + BNDW, 或是 AOA 系列的 ETF</li><li>開網路劵商, 如 <a href="https://www.firstrade.com/content/zh-tw/welcome">Firstrade</a> or <a href="https://www.tdameritrade.com/">TD Ameritrade</a> 帳戶, 定期定額購買 VT + BNDW + VNQ ... etc</li></ol><a id="more"></a><h2 id="本文開始"><a href="#本文開始" class="headerlink" title="本文開始"></a>本文開始</h2><p>通常我們想要購買股票投資時, 會遇到兩個問題就是</p><ul><li>買哪支股票?</li><li>什麼時候買?</li></ul><p>股票那麼多種, 在規畫退休金時, 從早期的中鋼開始, 經過中華電信, 到現在的金融股, 其實變動很大, 10年前的手機很紅, 如果買了 HTC 當作退休金, 放到現在無法退休吧, 也就是說其實做長期投資, 光是 10 年其實變化就很大, 不論是公司或是產業, 因為時間一拉長的關係, 原本看好的市場或是公司不免產生一些變化, 而把退休金放在這些標的上面, 一旦發生變化那不是很可怕? </p><p>所以主動選擇產業跟公司, 其實是不太好的策略, 要避免這個問題就是要分散產業與公司, 其實有一種簡單的方法就是買市場指數型 ETF(大盤) </p><p>這邊再把這兩個問題整理一下  </p><ul><li>買哪支股票?<ul><li>我不會選股, 也看不出股票真正價值, 所以不買個股</li><li>採用 ETF 指數投資, 例如投資市值前50大的公司的 0050<ul><li>被動投資不見得會輸主動投資, 0050 其實打敗很多人</li><li>不用研究股票, 就有更多的時間拿來運用</li><li>不用怕下市, 台灣市值前50大的公司若都倒了, 那台灣應該也毀了吧, 而且買其他個股的會比你先死</li><li>連股神巴菲特都開始買 SP 500 的ETF了</li><li>買大盤指數也減少了人為操弄, 避免股市巨鯨進出而被影響</li></ul></li></ul></li><li>什麼時候買?<ul><li>世上沒人可以預估進場時機</li><li>所以使用定期購買法分散風險<ul><li>利用平均法, 長時間下來你不會買在低點, 也不會買到高點, 而是買在平均點</li></ul></li></ul></li></ul><p>也就是說, 利用定期定額購買大盤, 你就會獲得到大盤的利潤, 你不會比大盤賺, 你也不會比大盤差, 你就是拿到大盤成長的利潤</p><h2 id="戰勝市場-大盤-很難嗎"><a href="#戰勝市場-大盤-很難嗎" class="headerlink" title="戰勝市場(大盤), 很難嗎?"></a>戰勝市場(大盤), 很難嗎?</h2><p>我參考到的資料是打敗大盤不是不能, 但是很難, 你可能要花上相當大的資源才能打敗大盤, 投報率很低, 這個問題的答案理論基礎在於市場是否為效率市場有關, 大概是說假設去掉手續費, 這其實是一場零和遊戲, 那假設每個人都很厲害, 就代表市場裡的每個人都很有效率的購買股票, 最後這些人也只能拿到跟大盤一樣的利潤, 那今天有一個人比較遜, 跑來市場, 最後那些很有效率的人賺到的錢的總和就是那個比較遜的人虧的總和</p><p>不過我舉另一個例子, 巴菲特在 2008 年跟公開賭50萬美金, 賭沒有任何的對沖基金可以贏的了 Vanguard S&amp;P500 ETF(美國標普500指數型基金, 代號 VOO, 簡單的來說你可以把它想像成美國50), 2018 年巴菲特賭贏了, 這個結論也代表經理人是多餘的 :D, 他在2017 年也說過沒有人可以打敗大盤指數型基金</p><p>這個故事你可以在這邊找到: <a href="https://wealth.businessweekly.com.tw/GArticle.aspx?id=ARTL000124494">從與經理人的10年賭約，看巴菲特價值投資法</a></p><h2 id="市場一定會成長嗎"><a href="#市場一定會成長嗎" class="headerlink" title="市場一定會成長嗎?"></a>市場一定會成長嗎?</h2><p>理論上會的, 人類不斷的產生經濟活動就會創造更多的價值, 所以說你如果長期買空頭的話, 會蠻慘的</p><h2 id="台灣追蹤指數的-ETF-元大台灣-50-0050-VS-富邦台灣采吉-50-006208"><a href="#台灣追蹤指數的-ETF-元大台灣-50-0050-VS-富邦台灣采吉-50-006208" class="headerlink" title="台灣追蹤指數的 ETF -- 元大台灣 50(0050) VS 富邦台灣采吉 50(006208)"></a>台灣追蹤指數的 ETF -- 元大台灣 50(0050) VS 富邦台灣采吉 50(006208)</h2><p>在台灣有兩隻 EFT分別都是追蹤大盤指數, 分別是元大台灣 50(代號: 0050) 與富邦台灣采吉 50(代號: 006208), 基本上這兩隻性質很像, 那我們要選哪一隻呢? </p><p>在評斷 ETF 時, 有幾點要注意的</p><ul><li>追蹤誤差是多少?<ul><li>例如 元大台灣 50(0050) 與 富邦台灣采吉 50(006208) 都是追蹤大盤, 但是大盤今年漲 10%, ETF 不見得會跟著漲 10%, 可能會漲 9.5%, 如果爛一點的話可能會更低, 9%, 8% 之類的, 這種與標的物差太多的就是不好的 ETF, 相反的, 如果該 ETF 比大盤來得高, 例如是賺 10%, 11%, 也不是好的 ETF</li></ul></li><li>內扣費用高低?<ul><li>因為指數型 ETF 不需要靠經理人殺進殺出, 是根據指數做操作的, 所以管理費應該會隨著基金規模變大而下降</li><li>有良心的業者隨著規模變大應該要調降管理費用</li></ul></li></ul><p>綜合以上兩點, 我會建議你買<a href="https://websys.fsit.com.tw/FubonETF/Funds/Profile.aspx?stock=006208">富邦50</a>, 是因為 <em>&quot;富貴要人幫, 買股買這張&quot;</em> 嗎? 並不是, 而是因為他有比較低的手續費與內扣費用, 追蹤大盤的能力也很好的緣故</p><p><a href="https://www.twse.com.tw/zh/ETF/fund/0050">台灣50的費用為 0.355%</a><a href="https://www.twse.com.tw/zh/ETF/fund/00692">富邦50的費用為 0.185%</a></p><p>網路有不少分析文章, 想知道更細部的原因可以看以下幾篇</p><ul><li><a href="https://greenhornfinancefootnote.blogspot.com/2019/10/50etf0062082019.html">台50 vs 富邦 50 -- 綠角</a></li><li><a href="https://rich01.com/0050etf-vs-006208etf/">富邦台50ETF(006208)vs台灣50(0050)報酬與費用比較》小資族挑哪個好</a></li><li><a href="https://wealth.businessweekly.com.tw/GArticle.aspx?id=ARTL000120248">同樣追蹤台股大盤...月投5千買「便宜版0050」，管理費更低、賺更多！</a></li></ul><h2 id="指數型-ETF-VS-存股"><a href="#指數型-ETF-VS-存股" class="headerlink" title="指數型 ETF VS 存股"></a>指數型 ETF VS 存股</h2><p>現在也蠻流行固定購買某些特定的股票, 例如定期定額買入中華電信, 兆豐金等股票, 這些人稱存股族, 那這種投資方式好嗎?</p><p>首先, 投資的方式應該沒什麼好不好, 只有適不適合自己, 只要你能買下去, 晚上能睡好覺的就是好方式, 而&quot;定期定額購買定存股&quot;與&quot;定期定額購買大盤指數型 ETF (如台灣50)&quot; 其實差別只有在買入標, 但我覺得買入 ETF 更好, 以下是推論</p><ul><li>存股不能買了不管<ul><li>退休應該是很久的事情, 至少超過10年</li><li>10年前表現好的定存股, 10年後不見得會好</li><li>指數型 ETF 每年會自動調整, 定存股需要手動調整</li><li>不要買固定股票當存股, 除非你常常盯著他</li></ul></li></ul><p>當然, 也許你會想說定存股也可以自行調整, 這當然可以, 這邊只是提出存股不能放著不管的想法, 所以才建議購買大盤指數型 ETF, 畢竟我們不想花大時間去研究哪個股票適合當定存股, 你如果能時時刻刻照顧你的股票, 那也是 ok 的</p><h2 id="EFT-哪種比較好-元大台灣50-0050-VS-元大高股息-0056-VS-富邦公司治理-006208"><a href="#EFT-哪種比較好-元大台灣50-0050-VS-元大高股息-0056-VS-富邦公司治理-006208" class="headerlink" title="EFT 哪種比較好 -- 元大台灣50(0050) VS 元大高股息(0056) VS 富邦公司治理(006208)"></a>EFT 哪種比較好 -- 元大台灣50(0050) VS 元大高股息(0056) VS 富邦公司治理(006208)</h2><p>這幾隻都是很熱門的 ETF, 哪種比較好呢? 這邊先列出基本資料</p><ul><li>元大台灣50: 是追蹤大盤指數 ETF, 由市值最大的50大公司, 依照市值比例組成</li><li>元大高股息: 是由配股配息高的股票</li><li>富邦公司治理: 追蹤金管會發布的公司治理名單所組成</li></ul><p>直接講結論:<br>挑選 &quot;非人為能介入&quot; 的, 所以就是選大盤指數 ETF (台灣50), 理由是人可以介入的話, 就可能會出問題, 如果你認為它們兩個績效一樣的話, 那你就買指數型就好了, 問題會比較少, 更何況 0056 雖然名稱叫高股息, 但不見得會配贏 0050, 且管理費比 0050 還高, 雖然富邦公司治理(006208)其實跟大盤趨勢很像, 但基本上完全是不同的概念, 一個是主動型選股, 一個是被動選股, 績效相同只是剛巧而已</p><p>現在也看到很多不是以市場當作指數的 ETF , 例如元大高股息(0056) 就是, 雖然也叫做指數型 ETF 但其實跟原本針對市場做的指數型投資概念差很多, 千萬別搞錯了, 同理富邦公司治理(006208)也是</p><h2 id="存退休金的方式"><a href="#存退休金的方式" class="headerlink" title="存退休金的方式"></a>存退休金的方式</h2><p>定期定額其實很適合上班族, 當你每個月定期定額存入5000元到指數型基金, 等到 20 年假設你 60歲, 你可以每個月提 5000 元, 至少可以提 20 年, 至少提領到 80 歲, 當然股票是比較有波動的投資, 所以我們必須不斷地分散風險, 同時又拿到市場成長的果實</p><p>當然光是購買台灣 50 ETF 是遠遠不夠的, 你還需要資產配置, 例如搭配一點點的債劵或是 REIT 等, 這個可能等之後再來討論</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>假設我們決定要買&quot;台灣 50&quot;, 仔細想想, <strong>定期定額購買台灣50</strong> 這決策中, 背後代表什麼?    </p><ul><li>定期定額購買 + 台灣 50 ETF<ul><li>定期定額購買: 代表放棄選擇進入市場的時間, 被動進場</li><li>台灣 50 ETF: 代表放棄選股, 因為是他幫你選好了, 被動選股</li></ul></li></ul><p>最後你會發現, 我的策略其實是叫你 </p><h4 id="quot-放棄選股-也放棄選入場時機來買股票-quot"><a href="#quot-放棄選股-也放棄選入場時機來買股票-quot" class="headerlink" title="&quot;放棄選股, 也放棄選入場時機來買股票&quot;"></a>&quot;放棄選股, 也放棄選入場時機來買股票&quot;</h4><p> 這結論聽起來非常違反人性 😄</p><p>不過我非財經研究專家, 所以上面有些東西推論起來其實是有點卡卡的, 不過工程師就是要做實驗, 這個違反人性的事, 你可以每個月花1000塊, 定期定額購買 ETF, 一年後你可以再來看看這種奇怪的方式到底是好, 還是不好, 結果搞不好會讓你大吃一驚喔</p><p>最後我在文中一直提到個概念就是 <strong>分散標的</strong>, 以降低風險 , 舉一反三的你一定會發現, 我們談到的分散的範圍也只是在台灣這塊市場而已, 若是把每個國家市場都看成一間公司, 其實你會發現我們最終還是在投資一間公司而已, 而這個問題就留在下次討論嚕</p><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><p>這邊提供更多市場價值的解釋, 可以看看</p><ul><li><a href="https://www.ptt.cc/bbs/Stock/M.1523074420.A.B23.html">被動型ETF投資方式及心得</a></li></ul><p>若你還想看更多有關指數化與被動投資的文章, 可以看看下面的連結</p><ul><li>被動投資是什麼<ul><li><a href="https://rich01.com/what-passive-invest/">https://rich01.com/what-passive-invest/</a></li><li><a href="https://pgfinnote.com/understanding-passive-investing/">https://pgfinnote.com/understanding-passive-investing/</a></li><li><a href="https://www.etf168.com.tw/Article/Article?articleID=211">https://www.etf168.com.tw/Article/Article?articleID=211</a></li><li><a href="http://justin0904.pixnet.net/blog/post/222388512">http://justin0904.pixnet.net/blog/post/222388512</a></li><li><a href="https://as223400.pixnet.net/blog/post/227830082-%E8%A2%AB%E5%8B%95%E6%8A%95%E8%B3%87-%E4%BD%8E%E9%A2%A8%E9%9A%AA%E7%9A%84%E6%87%B6%E4%BA%BA%E6%8A%95%E8%B3%87%E6%96%B9%E6%B3%95">https://as223400.pixnet.net/blog/post/227830082-%E8%A2%AB%E5%8B%95%E6%8A%95%E8%B3%87-%E4%BD%8E%E9%A2%A8%E9%9A%AA%E7%9A%84%E6%87%B6%E4%BA%BA%E6%8A%95%E8%B3%87%E6%96%B9%E6%B3%95</a></li><li><a href="https://www.etf168.com.tw/Article/Article?articleID=211">https://www.etf168.com.tw/Article/Article?articleID=211</a></li></ul></li><li>指數化投資是什麼<ul><li><a href="https://greenhornfinancefootnote.blogspot.com/2013/08/1greenhorns-investment-principles.html">https://greenhornfinancefootnote.blogspot.com/2013/08/1greenhorns-investment-principles.html</a></li><li><a href="https://greenhornfinancefootnote.blogspot.com/2016/02/indexing-best-choice-for-professionals.html">https://greenhornfinancefootnote.blogspot.com/2016/02/indexing-best-choice-for-professionals.html</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;這篇是給目前不能自己挑到好股票, 但又想做投資的人看的&lt;/li&gt;
&lt;li&gt;這邊主要的核心概念是&amp;quot;分散&amp;quot;, 若是能挑到好股票的人看了這篇, 不但沒幫助, 反而會有害&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;核心概念-分散投資標的以降低風險&quot;&gt;&lt;a href=&quot;#核心概念-分散投資標的以降低風險&quot; class=&quot;headerlink&quot; title=&quot;核心概念 -- 分散投資標的以降低風險&quot;&gt;&lt;/a&gt;核心概念 -- 分散投資標的以降低風險&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分散股票種類: 購買 ETF 分散投資目標的風險&lt;/li&gt;
&lt;li&gt;分散購入時機: 定期定額&lt;/li&gt;
&lt;li&gt;分散股票區域性: 購入全球 ETF&lt;/li&gt;
&lt;li&gt;分散股票類型: 股票 + 債的資產配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我先講結論, 然後再慢慢解釋我為何這樣推薦, 而作法就是   &lt;/p&gt;
&lt;h3 id=&quot;quot-定期定額購買-指數型-ETF-quot&quot;&gt;&lt;a href=&quot;#quot-定期定額購買-指數型-ETF-quot&quot; class=&quot;headerlink&quot; title=&quot;&amp;quot;定期定額購買 指數型 ETF &amp;quot;&quot;&gt;&lt;/a&gt;&amp;quot;定期定額購買 指數型 ETF &amp;quot;&lt;/h3&gt;&lt;p&gt;方法很多種, 從簡單到複雜:   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用富邦證劵, 定期定額購買富邦采吉50(006208) ETF&lt;ul&gt;
&lt;li&gt;投資低消為 1000元, 適合小資上班族&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.fubon.com/securities/hot_new/open-now/etf.html&quot;&gt;富邦定期定額 ETF&lt;/a&gt; 1萬元以內, 手續費只要1元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用複委託, 例如&lt;a href=&quot;https://www.dcn.com.tw/re-consigned/charge.htm&quot;&gt;大昌證券複委託&lt;/a&gt; , 定期定額購買 VT + BNDW, 或是 AOA 系列的 ETF&lt;/li&gt;
&lt;li&gt;開網路劵商, 如 &lt;a href=&quot;https://www.firstrade.com/content/zh-tw/welcome&quot;&gt;Firstrade&lt;/a&gt; or &lt;a href=&quot;https://www.tdameritrade.com/&quot;&gt;TD Ameritrade&lt;/a&gt; 帳戶, 定期定額購買 VT + BNDW + VNQ ... etc&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Investment" scheme="http://wwssllabcd.github.io/tags/Investment/"/>
    
  </entry>
  
  <entry>
    <title>Python windows 安裝, 心得, 教學</title>
    <link href="http://wwssllabcd.github.io/2018/05/21/how-to-install-python-on-windows/"/>
    <id>http://wwssllabcd.github.io/2018/05/21/how-to-install-python-on-windows/</id>
    <published>2018-05-20T17:13:59.000Z</published>
    <updated>2018-06-19T15:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下載並安裝-Python"><a href="#下載並安裝-Python" class="headerlink" title="下載並安裝 Python"></a>下載並安裝 Python</h2><p>請至 <a href="https://www.python.org/downloads/windows/">Python windows 下載頁面</a>, 不是每個版本都有 window 的安裝版</p><ol><li>最好選擇 Python 3.x, 因為選 2.7 會有檔名多國語言問題, dos 下讀檔會亂碼, py 3 就沒有這問題  </li><li>最好選 32bit 的, 因為如果要打包成單一執行檔(exe file), 打包完在 32 bit 的環境跑不起來, 且有 include dll 批配的問題  </li><li>要選 32bit 還是 64 bit, 基本上要看你用到的 DLL 決定, 例如你有些額外的 dll 是使用 w32 的, 那基本上你使用 64bit 的 ptyhon 就不行, 使用而且 64 bit dll 還有 ctype call address 的問題, 建議如果不想搞死自己, 那就最好是選 32bit 的比較保險</li></ol><p>這邊是選 <a href="https://www.python.org/ftp/python/3.6.5/python-3.6.5.exe">Python 3.6.5</a> 下載</p><p>安裝時請注意以下幾點</p><ul><li>請注意安裝路徑, 他預設是在&quot;使用者&quot;目錄下面, 最好換到非中文目錄底下</li><li>要移除時, 必須執行安裝程式後, 裡面有個uninstall, 在 window 那邊好像找不到移除方式</li><li>安裝時選 customize install, 這樣才可以自選安裝路徑</li><li>也順便選 Add python 3.6 to path</li></ul><a id="more"></a><h2 id="安裝-pip"><a href="#安裝-pip" class="headerlink" title="安裝 pip"></a>安裝 pip</h2><p>如果是安裝 python 3.5 以上的, 都會預設安裝 pip, 所以只要更新 pip 即可, 這邊舉出了舉多種 python 取得 pip 所對應的方法, 分述如下:</p><ul><li><p>Python 3.4 以前的版本: 取得 get-pip.py 後, 放到 Python 安裝目錄下後, 執行</p><pre><code>  python get-pip.py   </code></pre></li></ul><p>pip 會建立在例如 <code>D:\Python27\Scripts</code> 之下, 請把 <code>get-pip.py</code> 這個 script 加入到 path 中</p><ul><li><p>Python 3.6: 是內建pip的, 所以要使用的時候, 直接打開 dos cmd 輸入 pip 指令即可更新 pip (前面的 python 不能省略)    </p><pre><code>  python -m pip install --upgrade pip</code></pre></li></ul><p>更新某個套件也可以用 pip, 若要更新 pyqt5 時, 指令如下</p><pre><code>pip install -U pyqt5</code></pre><p>其他指令可藉由 <code>pip -h</code> 查到</p><h2 id="關於-pip-與-pip3-的差異"><a href="#關於-pip-與-pip3-的差異" class="headerlink" title="關於 pip 與 pip3 的差異"></a>關於 pip 與 pip3 的差異</h2><p>pip 和 pip3 都在 Python36\Scripts\ 目錄下, 如果同時裝有python2 和 python3, pip 默認給 python2 用, pip3 指定給 python3 用, 如果只裝有 python3，則pip和pip3是等價的, 安裝了python3之後，就會有pip3</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;下載並安裝-Python&quot;&gt;&lt;a href=&quot;#下載並安裝-Python&quot; class=&quot;headerlink&quot; title=&quot;下載並安裝 Python&quot;&gt;&lt;/a&gt;下載並安裝 Python&lt;/h2&gt;&lt;p&gt;請至 &lt;a href=&quot;https://www.python.org/downloads/windows/&quot;&gt;Python windows 下載頁面&lt;/a&gt;, 不是每個版本都有 window 的安裝版&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最好選擇 Python 3.x, 因為選 2.7 會有檔名多國語言問題, dos 下讀檔會亂碼, py 3 就沒有這問題  &lt;/li&gt;
&lt;li&gt;最好選 32bit 的, 因為如果要打包成單一執行檔(exe file), 打包完在 32 bit 的環境跑不起來, 且有 include dll 批配的問題  &lt;/li&gt;
&lt;li&gt;要選 32bit 還是 64 bit, 基本上要看你用到的 DLL 決定, 例如你有些額外的 dll 是使用 w32 的, 那基本上你使用 64bit 的 ptyhon 就不行, 使用而且 64 bit dll 還有 ctype call address 的問題, 建議如果不想搞死自己, 那就最好是選 32bit 的比較保險&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這邊是選 &lt;a href=&quot;https://www.python.org/ftp/python/3.6.5/python-3.6.5.exe&quot;&gt;Python 3.6.5&lt;/a&gt; 下載&lt;/p&gt;
&lt;p&gt;安裝時請注意以下幾點&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;請注意安裝路徑, 他預設是在&amp;quot;使用者&amp;quot;目錄下面, 最好換到非中文目錄底下&lt;/li&gt;
&lt;li&gt;要移除時, 必須執行安裝程式後, 裡面有個uninstall, 在 window 那邊好像找不到移除方式&lt;/li&gt;
&lt;li&gt;安裝時選 customize install, 這樣才可以自選安裝路徑&lt;/li&gt;
&lt;li&gt;也順便選 Add python 3.6 to path&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://wwssllabcd.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>安裝 PyQt</title>
    <link href="http://wwssllabcd.github.io/2018/05/21/how-to-install-pyqt/"/>
    <id>http://wwssllabcd.github.io/2018/05/21/how-to-install-pyqt/</id>
    <published>2018-05-20T17:13:59.000Z</published>
    <updated>2018-06-19T15:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安裝-PyQt"><a href="#安裝-PyQt" class="headerlink" title="安裝 PyQt "></a>安裝 PyQt </h2><p>PyQT 為 python 的一款 GUI 程式, 是採用 GPL licence, 但也是不是每一版都有 windows 安裝版<br>注意: 這邊可能會更推薦使用 pip 安裝, 指令為</p><pre><code> pip install pyqt5</code></pre><p>pip 會自動根據 python 的版本自動匹配, 我這邊使用 <code>python 3.6.5</code> 批配到的是 <code>pyqt 5.10.1</code></p><pre><code>雖然 PyQt 可以自行從官網下載並安裝, 但請務必使用 pip 安裝, 後面使用的時候問題會比較少</code></pre><h2 id="安裝-Pyqt5-tools"><a href="#安裝-Pyqt5-tools" class="headerlink" title="安裝 Pyqt5-tools"></a>安裝 Pyqt5-tools</h2><p>使用 pip 安裝 PyQt 時, 並不會把 Pyqt designr 給安裝起來, 所以使用 pip 安裝 Pyqt5-tools, 以便取得 QT designer</p><pre><code>pip install pyqt5-tools</code></pre><p>而 designer 會在 </p><pre><code>D:\Python\Python36-32\Lib\site-packages\pyqt5-tools</code></pre><p>中找到</p><a id="more"></a><h2 id="PyQt-的-ui-檔轉換"><a href="#PyQt-的-ui-檔轉換" class="headerlink" title="PyQt 的 ui 檔轉換"></a>PyQt 的 ui 檔轉換</h2><p>安裝好 pyqt5 後, 可以使用 qt design 來設計 UI, 把 UI 設計好了之後存檔, 會產生 .ui檔 接下來要使用此ui 檔, 我們必須把此 ui 檔案轉換成 .py檔，方便我們直接在 Python 中使用, 使用 CMD 切換到設計好的 ui 所在目錄下，執行此指令(ui檔我們取名為 myui.ui) </p><pre><code>pyuic5 myui.ui -o myui.py</code></pre><p>而 pyuic5 路徑如下( python 安裝路徑為 D:\Python36-32 為例)</p><pre><code>D:\Python36-32\Scripts\pyuic5.exe</code></pre><p>接下來把以下文字存成&#39;PyGui.py&#39;  </p><pre><code>import sysfrom PyQt5.QtWidgets import QApplication, QDialog, QMessageBoxfrom myui import Ui_Dialogclass MyDlg(QDialog):    def __init__(self):        super(MyDlg, self).__init__()        # Set up the user interface from Designer.        self.ui = Ui_Dialog()        self.ui.setupUi(self)def main_start():    app = QApplication(sys.argv)    window = MyDlg()    window.show()    sys.exit(app.exec_())if __name__ == &#39;__main__&#39;:    main_start()</code></pre><p>再執行以下指令即可</p><pre><code>python PyGui.py </code></pre><p>ref:</p><p><a href="http://pyqt.sourceforge.net/Docs/PyQt5/designer.html">http://pyqt.sourceforge.net/Docs/PyQt5/designer.html</a></p><h2 id="在-QT-design-中觀看-ui-預覽"><a href="#在-QT-design-中觀看-ui-預覽" class="headerlink" title="在 QT design 中觀看 ui 預覽"></a>在 QT design 中觀看 ui 預覽</h2><ul><li>表單/預覽, </li><li>或是 Ctrl+R</li></ul><h2 id="LineEdit-與-TextEdit-的差異"><a href="#LineEdit-與-TextEdit-的差異" class="headerlink" title="LineEdit 與 TextEdit 的差異"></a>LineEdit 與 TextEdit 的差異</h2><p>lineEdit: 單行的 editTextEdit: 多行</p><h2 id="什麼是-Spacer"><a href="#什麼是-Spacer" class="headerlink" title="什麼是 Spacer "></a>什麼是 Spacer </h2><p>是當使用 vertical layout 時, 若中間不想放東西的時候用來填空的Horizontal Spacer 水平空白条和 Vertical Spacer 垂直空白条，空白条的作用就是填充无用的空隙，如果不希望看到控件拉伸后变丑，就可以塞一个空白条到布局器里面<a href="https://qtguide.ustclug.org/">https://qtguide.ustclug.org/</a></p><h2 id="建立一個事件"><a href="#建立一個事件" class="headerlink" title="建立一個事件"></a>建立一個事件</h2><pre><code>class MyDlg(QtGui.QDialog):    def __init__(self, parent=None):        QtGui.QWidget.__init__(self, parent)        self.ui = Ui_Dialog()        self.ui.setupUi(self)        self.ui.btnRefresh.clicked.connect(self.chk_fun)    def chk_fun(self):        print(&quot;Good.&quot;)</code></pre><p>直接在 MyDlg 中的 <code>__init__</code> 中加入事件, 並綁定到某個 function 就可以了, 例如這邊看到的是一個叫<code>btnRefresh</code> 的button, 我們把這個 button 的 clicked 的事件, 綁訂到 chk_fun 這個 function , 而這個 function 印出 good</p><p>再舉一個例子, 如 combobox 的 index change 綁定事件如下</p><pre><code>myCombobox.currentIndexChanged.connect(self.cmd_idx_change)</code></pre><h2 id="使用-keypass-event"><a href="#使用-keypass-event" class="headerlink" title="使用 keypass event"></a>使用 keypass event</h2><p>只要在該 Qdlog 中, 複寫 def keyPressEvent(self, event): 即可, 如下所示</p><pre><code>def keyPressEvent(self, event):    key = event.key()    print(key)    super(MyDlg, self).keyPressEvent(event)</code></pre><p>要注意的是, 如果現在 focus 的控鍵上有 keypassevent 的話, 會優先呼叫該控鍵的 event, 例如 txtedit 有自己的 page down , 所以 dialog 的不會對他造成影響</p><h2 id="關掉-QTextEdit-的-Scoll"><a href="#關掉-QTextEdit-的-Scoll" class="headerlink" title="關掉 QTextEdit 的 Scoll"></a>關掉 QTextEdit 的 Scoll</h2><p>找到 verticalScrollBarPolicy , 並且把她設成 off 即可</p><h2 id="設定-dialog-title"><a href="#設定-dialog-title" class="headerlink" title="設定 dialog title"></a>設定 dialog title</h2><p>self.setWindowTitle</p><h2 id="Combobox-中的下拉式-item-加長"><a href="#Combobox-中的下拉式-item-加長" class="headerlink" title="Combobox 中的下拉式 item 加長"></a>Combobox 中的下拉式 item 加長</h2><p>有個屬性叫<code>visiable item cnt</code>的數字選大一點</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;安裝-PyQt&quot;&gt;&lt;a href=&quot;#安裝-PyQt&quot; class=&quot;headerlink&quot; title=&quot;安裝 PyQt &quot;&gt;&lt;/a&gt;安裝 PyQt &lt;/h2&gt;&lt;p&gt;PyQT 為 python 的一款 GUI 程式, 是採用 GPL licence, 但也是不是每一版都有 windows 安裝版&lt;br&gt;注意: 這邊可能會更推薦使用 pip 安裝, 指令為&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; pip install pyqt5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pip 會自動根據 python 的版本自動匹配, 我這邊使用 &lt;code&gt;python 3.6.5&lt;/code&gt; 批配到的是 &lt;code&gt;pyqt 5.10.1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;雖然 PyQt 可以自行從官網下載並安裝, 但請務必使用 pip 安裝, 後面使用的時候問題會比較少&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;安裝-Pyqt5-tools&quot;&gt;&lt;a href=&quot;#安裝-Pyqt5-tools&quot; class=&quot;headerlink&quot; title=&quot;安裝 Pyqt5-tools&quot;&gt;&lt;/a&gt;安裝 Pyqt5-tools&lt;/h2&gt;&lt;p&gt;使用 pip 安裝 PyQt 時, 並不會把 Pyqt designr 給安裝起來, 所以使用 pip 安裝 Pyqt5-tools, 以便取得 QT designer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install pyqt5-tools&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而 designer 會在 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;D:\Python\Python36-32\Lib\site-packages\pyqt5-tools&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中找到&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://wwssllabcd.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>執行 amb expression</title>
    <link href="http://wwssllabcd.github.io/2017/11/12/how-to-execute-amb-expression/"/>
    <id>http://wwssllabcd.github.io/2017/11/12/how-to-execute-amb-expression/</id>
    <published>2017-11-11T17:13:59.000Z</published>
    <updated>2017-11-30T19:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立-amb-環境"><a href="#建立-amb-環境" class="headerlink" title="建立 amb 環境"></a>建立 amb 環境</h2><p>先去這邊下載</p><pre><code>https://mitpress.mit.edu/sicp/code/</code></pre><p>amb 是 chapter 4 的, 所以選以下這個下載</p><pre><code>ch4-ambeval.scm     Amb Evaluator (section 4.3)</code></pre><p>然後再scheme 中執行, 會發現 load 不進去另一個檔, 其實把兩個檔案合起來就可以了, 存成一個檔案後, 就可以使用指令 load 出來, 如下</p><pre><code>( load &quot;e:\\a.scm&quot;) </code></pre><p><code>PS：按CTRL-Y 可以貼上文字</code></p><a id="more"></a><p>然後按<code>Ctrl + x</code>, 再按<code>ctrl + e</code>就可以執行 LISP</p><p>如果出現了 </p><pre><code>;Loading &quot;e:\\a.scm&quot;... done;Value: amb-evaluator-loaded</code></pre><p>就代表載入 成功, 執行amb的部分可以參考以下</p><pre><code>http://uents.hatenablog.com/entry/sicp/059-amb-operator-with-call-cc.md</code></pre><p>接下來建立 env, 使用以下指令</p><pre><code>(define the-global-environment (setup-environment))</code></pre><h2 id="執行-amb"><a href="#執行-amb" class="headerlink" title="執行 amb "></a>執行 amb </h2><p>接下來就可以輸入 </p><pre><code>(driver-loop)</code></pre><p>如果出現</p><pre><code>;;; Amb-Eval input:</code></pre><p>此時就是代表進入到 amb 執行器, 輸入</p><pre><code>(amb 1 3 5 )</code></pre><p>會出現1 , 輸入 </p><pre><code>try-again</code></pre><p>會出現3</p><h2 id="觀察裡面的值"><a href="#觀察裡面的值" class="headerlink" title="觀察裡面的值"></a>觀察裡面的值</h2><p>例如, 我想觀察變數<code>exp</code>, 就可以在 code 中插入</p><pre><code>(newline)(display &quot;=== my print ==&quot;)(newline)(display exp)</code></pre><p>即可 trace code</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol><li>先把輸入參數, 利用 map +analyze 分析完成後, 放到 cprocs 中</li><li>再利用 (try-next cprocs), 把每個東西都拿出來</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;建立-amb-環境&quot;&gt;&lt;a href=&quot;#建立-amb-環境&quot; class=&quot;headerlink&quot; title=&quot;建立 amb 環境&quot;&gt;&lt;/a&gt;建立 amb 環境&lt;/h2&gt;&lt;p&gt;先去這邊下載&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://mitpress.mit.edu/sicp/code/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;amb 是 chapter 4 的, 所以選以下這個下載&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch4-ambeval.scm     Amb Evaluator (section 4.3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後再scheme 中執行, 會發現 load 不進去另一個檔, 其實把兩個檔案合起來就可以了, 存成一個檔案後, 就可以使用指令 load 出來, 如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;( load &amp;quot;e:\\a.scm&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PS：按CTRL-Y 可以貼上文字&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="sicp" scheme="http://wwssllabcd.github.io/tags/sicp/"/>
    
  </entry>
  
  <entry>
    <title>makefile 心得、教學</title>
    <link href="http://wwssllabcd.github.io/2016/10/03/how-to-write-make-file/"/>
    <id>http://wwssllabcd.github.io/2016/10/03/how-to-write-make-file/</id>
    <published>2016-10-02T17:13:59.000Z</published>
    <updated>2016-10-03T13:20:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>要寫 makefile 之前，首先我們必須要先從最基本的 GCC 編譯指令開始學起，才可以一步一步地建立起 makefile，幸好這不會花我們太多時間</p><h1 id="使用-GCC-編譯命令，並且印出-hello-world"><a href="#使用-GCC-編譯命令，並且印出-hello-world" class="headerlink" title="使用 GCC 編譯命令，並且印出 hello world "></a>使用 GCC 編譯命令，並且印出 hello world </h1><p>建立一個檔案叫做 main.c 後，輸入以下指令</p><pre><code>#include&lt;stdio.h&gt;int main()&#123;    printf(&quot;\r\nHello World&quot;);&#125;</code></pre><p>接著在命令列(windows 系統可以使用 cygwin)中，輸入 compile 指令</p><pre><code> gcc -c main.c</code></pre><p>執行完後會產生 obj file，如 main.o<br>而上述所使用的編譯參數如下所示</p><pre><code>-c : 只編譯不連結 </code></pre><p>執行連結，使用 gcc -o 指令</p><pre><code> gcc -o test main.o</code></pre><p>-o 代表作 link，-o filename 為指定輸出檔名<br>此時應該會出現一個叫 test 的檔案<br>執行 test </p><pre><code>./testHello World</code></pre><p>編譯時，如果有 header file 的時候，可以使用 -I 參數，如下所示<br>這邊是指定 header file 是在哪個目錄可以找的到</p><pre><code> gcc -c -I ./inc main.c</code></pre><a id="more"></a><h1 id="使用-makefile-簡化"><a href="#使用-makefile-簡化" class="headerlink" title="使用 makefile 簡化"></a>使用 makefile 簡化</h1><p>建立一個文字檔，取名為 makefile，內容填入如下所示</p><pre><code>test: main.o    gcc -o main.o testmain.o: main.c    gcc -c main.cclean:    rm -f *.o *.exe</code></pre><p>先解說以下這行</p><pre><code>main.o: main.c</code></pre><p>main.o: 分號前面代表目標，而後面的 main.c 就是告訴 make，要完成前面那個目標的話，必須要有<code>main.c</code>這個前置條件，所以如果輸入<code>make main.o</code> 的話，是會自動執行 <code>gcc -c main.c</code> 這段指令的，因為前置條件已經滿足，所以可以執行執行完就是產生 main.o 了</p><p>再看看第一行</p><pre><code>test: main.o</code></pre><p>test: 代表目標，而後面的 main.o 是前置條件，執行 make test 的時候，make 會找看看有沒有 main.o 這個檔，如果有的話就會執行，如果沒有的話，他會去找看看tag有沒有產生 main.o 的方法，並且嘗試產生出main.o</p><h1 id="執行-makefile"><a href="#執行-makefile" class="headerlink" title="執行 makefile"></a>執行 makefile</h1><p>在 console 輸入 make test 之後，make 會去找有無 test 這個 tag，這邊有 test 的 tag，而執行 test 的前置條件是必須要有 main.o ，則 make 會檢查有無 main.o 這個檔案，如果沒有的話，會自動搜尋 makefile 中，有無 main.o 這個檔案的產生方法，</p><p>這邊是有的，不過產生 main.o 的先決條件是要有 main.c ，則 make 會檢查有無 main.c 這個檔案，目前是有的，</p><p>所以 make 會先去執行 main.o 那個 tag，也就是 gcc -c main.c，執行這行指令後，會產生 main.o 這個檔案出來，所以執行 test 這個 tag 的條件也已經滿足了，所以可以執行 test 這個 tag ，也就是執行 gcc -o main.o test，所以產生出 test 這個檔案出來了</p><h1 id="多個檔案的-makefile"><a href="#多個檔案的-makefile" class="headerlink" title="多個檔案的 makefile"></a>多個檔案的 makefile</h1><p>加入第二個 .c file </p><pre><code>main.o: main.c    gcc -c  main.cDataIn.o: DataIn.cpp    gcc -c DataIn.cpp</code></pre><p>可以觀察到 main.o 與 dataIn.o 其實差不多格式，所以應該要有個萬用的格式例如 <em>.</em> 這種東西來簡化，而 make 的確是有這種簡化指令的，他是使用 % 來簡化，但 % 是屬於一對一的，也就是 foo.o 對應到 foo.c，這跟 * 不太一樣，而目標與前置條件都有萬用符號後，其實 gcc -c 要接的那個檔案名稱，也必須要是一種變數才行</p><pre><code>%.o: %.c    gcc -c $&lt;</code></pre><p>$&lt; : 屬於第一條件，也就是 foo.c<br>$@ : 屬於目標條件，也就是 foo.o  </p><h1 id="撰寫-makefile-的一些心得"><a href="#撰寫-makefile-的一些心得" class="headerlink" title="撰寫 makefile 的一些心得"></a>撰寫 makefile 的一些心得</h1><p>先把ld 需要的 object 建立起來，如建立起 obj_files </p><pre><code> OBJ_FILES = \    $(OBJDIR)/head.o  \    $(OBJ_LIB) \    $(OBJ_KERNEL) \</code></pre><p>然後利用 make 的前置規則讓他去找自動產生編譯需求</p><pre><code> system.bin:  $(OBJ_FILES )</code></pre><p>再利用萬用符號，讓每個檔案被編譯出來，如下所示</p><pre><code># == rule for kernel/ ==$(DIR_KERENL)/%.o: $(DIR_KERENL) /%.asm    $(AS) $&lt; -o $@$(DIR_KERENL)/%.o: $(DIR_KERENL) /%.c    $(CC) $(CFLAGS) $&lt; -o $@ </code></pre><h1 id="編譯前的-pre-task"><a href="#編譯前的-pre-task" class="headerlink" title="編譯前的 pre-task "></a>編譯前的 pre-task </h1><p>make 的前置條件，不見得是一個檔案，也可以是某個 tag</p><pre><code>all: clean mkdir boot.img </code></pre><p>這邊代表需要先執行 clean 這個規則，再需要 執行 mkdir 這個規則，然後執行boot.img</p><h1 id="make-時不顯示指令"><a href="#make-時不顯示指令" class="headerlink" title="make 時不顯示指令"></a>make 時不顯示指令</h1><p>在命令前面加上 @ ，代表不顯示該命令，如下所示@mkdir -p $@</p><h1 id="PHONY-符號的用法"><a href="#PHONY-符號的用法" class="headerlink" title=".PHONY 符號的用法"></a>.PHONY 符號的用法</h1><p>例如有時候都會見到</p><pre><code>.PHONY: clean</code></pre><p>.PHONY。這個符號的目的是告訴 make，&quot;clean&quot; 不是一個真正的檔案目標，只是一個標記，不要把他當成檔案來處理，避免有檔案真的叫 clean 時，make 會在依賴性判斷時判斷錯誤，那就糗了。</p><h1 id="在-make-file-中使用-awk"><a href="#在-make-file-中使用-awk" class="headerlink" title="在 make file 中使用 awk"></a>在 make file 中使用 awk</h1><pre><code>awk &#39;&#123; print $$1&quot; &quot;$$3 &#125;&#39; system.nm &gt; system.bsb</code></pre><p>只有使用一個$的話，會被make吃掉，使用兩個$，就不會消失</p><h1 id="makefile-中，定義變數"><a href="#makefile-中，定義變數" class="headerlink" title="makefile 中，定義變數"></a>makefile 中，定義變數</h1><p>可利用 $(MACRO) 或 ${MACRO} 來存取已定義的變數</p><p>M=$(PWD) 表明然後返回到當前目錄繼續讀入、執行當前的 Makefile。</p><h1 id="quot-語法-quot"><a href="#quot-語法-quot" class="headerlink" title="&quot;?= 語法&quot; "></a>&quot;?= 語法&quot; </h1><p>?= 語法：?= 是一個簡化的語法：若變數未定義，則替它指定新的值。否則，採用原有的值。例：FOO ?= bar若 FOO 未定義，則 FOO = bar；若 FOO 已定義，則 FOO 的值維持不變。</p><h1 id="語法"><a href="#語法" class="headerlink" title=":= 語法"></a>:= 語法</h1><p>:= 語法注意到，make 會將整個 Makefile 展開後，再決定變數的值。也就是說，變數的值將會是整個 Mackfile 中最後被指定的值。例：</p><pre><code>x = fooy = $(x) barx = xyz    # 此時 y 的值為 xyz bar</code></pre><p>在上例中，y 的值將會是 xyz bar，而不是 foo bar。您可以利用 := 來避開這個問題。:= 表示變數的值決定於它在 Makefile 中的位置，而不是整個 Makefile 展開後最終的值。</p><h1 id="巢狀-make"><a href="#巢狀-make" class="headerlink" title="巢狀 make"></a>巢狀 make</h1><p>也就是說 make 可以執行其他的 make ，如每個目錄都有自己的 make ，根目錄的 make 是可以進入到 其他目錄中，跳去執行其他的 make 後再回來使用 -C 參數。後面帶目錄名稱如下所示</p><pre><code>make -C boot</code></pre><p>你就會看到 make 會 Entering directory 後，再做 make </p><h1 id="makefile-建立目錄"><a href="#makefile-建立目錄" class="headerlink" title="makefile 建立目錄"></a>makefile 建立目錄</h1><p>必須要一個 target來幫助，如 directories，如下所示</p><pre><code>OBJDIR = ./obj$(OBJDIR):    mkdir -p $@makeDir: $&#123;OBJDIR&#125;</code></pre><p>接下來就是在 make all 那邊，加入dependence</p><pre><code>all: makeDir </code></pre><h1 id="make-內部變數"><a href="#make-內部變數" class="headerlink" title="make 內部變數"></a>make 內部變數</h1><p>$?：代表已被更新的 dependencies 的值，也就是 dependencies 中，比 targets 還新的值。<br>$@：代表 targets 的值。$&lt;：代表第一個 dependencies 的值<br>$* :代表 targets 所指定的檔案，但不包含副檔名    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;要寫 makefile 之前，首先我們必須要先從最基本的 GCC 編譯指令開始學起，才可以一步一步地建立起 makefile，幸好這不會花我們太多時間&lt;/p&gt;
&lt;h1 id=&quot;使用-GCC-編譯命令，並且印出-hello-world&quot;&gt;&lt;a href=&quot;#使用-GCC-編譯命令，並且印出-hello-world&quot; class=&quot;headerlink&quot; title=&quot;使用 GCC 編譯命令，並且印出 hello world &quot;&gt;&lt;/a&gt;使用 GCC 編譯命令，並且印出 hello world &lt;/h1&gt;&lt;p&gt;建立一個檔案叫做 main.c 後，輸入以下指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
int main()&amp;#123;
    printf(&amp;quot;\r\nHello World&amp;quot;);
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接著在命令列(windows 系統可以使用 cygwin)中，輸入 compile 指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gcc -c main.c&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行完後會產生 obj file，如 main.o&lt;br&gt;而上述所使用的編譯參數如下所示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-c : 只編譯不連結 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行連結，使用 gcc -o 指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gcc -o test main.o&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-o 代表作 link，-o filename 為指定輸出檔名&lt;br&gt;此時應該會出現一個叫 test 的檔案&lt;br&gt;執行 test &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./test

Hello World&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;編譯時，如果有 header file 的時候，可以使用 -I 參數，如下所示&lt;br&gt;這邊是指定 header file 是在哪個目錄可以找的到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gcc -c -I ./inc main.c&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="linux，makefile" scheme="http://wwssllabcd.github.io/tags/linux%EF%BC%8Cmakefile/"/>
    
  </entry>
  
  <entry>
    <title>bochs 使用教學，心得</title>
    <link href="http://wwssllabcd.github.io/2016/04/20/how-to-use-bochs/"/>
    <id>http://wwssllabcd.github.io/2016/04/20/how-to-use-bochs/</id>
    <published>2016-04-20T09:23:25.000Z</published>
    <updated>2016-06-05T16:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h1><p>使用 apt 安裝的是沒有debug 功能的，bochs 通常一出現視窗運行會沒辦法輸入指令，如果你只是要單純的執行環境的話，就使用 apt安裝吧，如果要 debug 功能的話，就要自行 compile</p><p>下載 <a href="https://sourceforge.net/projects/bochs/files/bochs/2.6.8/">bochs 2.6.8 source code</a></p><p>安裝(可參考 orange&#39;s P10)輸入下列指令 </p><pre><code>tar vxzf bochs-2.6.8.tar.gz</code></pre><p>進入目錄後，開始設定</p><pre><code>./configure --enable-disasm  --enable-debugger</code></pre><p>如果要使用 gdb 的話，就不能用 <code>--enable-debugger</code> ，要換成  <code>--enable-gdbstub</code>接下來就是</p><pre><code>makesudo make install</code></pre><a id="more"></a><h1 id="Bochs-ini-配置"><a href="#Bochs-ini-配置" class="headerlink" title="Bochs ini 配置"></a>Bochs ini 配置</h1><p>配置文件詳解可看 <a href="http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html">The configuration file bochsrc</a>也可見 linux 內核完全註釋 CH17，這邊列出我自己的 src 檔</p><pre><code>romimage: file=/usr/share/bochs/BIOS-bochs-latestmegs: 16vgaromimage: file=/usr/share/vgabios/vgabios.binfloppya: 1_44=system.img, status=insertedata0-master: type=disk, path=&quot;80.img&quot;, mode=flatboot: alog: bochsout.txtmouse: enabled=0display_library: x#debug_symbols: file=system.bsb#gdbstub: enabled=1, port=1234</code></pre><p>把以上的ini存成 <code>bochsrc.txt</code> 就可以了，另外如果有多個 ini 檔要切換時可以使用 <code>-f</code> 參數，如下所示</p><pre><code>bochs -f anotherBochIni.txt</code></pre><h1 id="bochs-載入-debug-symbols"><a href="#bochs-載入-debug-symbols" class="headerlink" title="bochs 載入 debug symbols "></a>bochs 載入 debug symbols </h1><p>載入symbol 的方是有兩種，一種是手動，一種是ini載入，以下兩者都會介紹到</p><h2 id="修改-symbol-格式"><a href="#修改-symbol-格式" class="headerlink" title="修改 symbol 格式"></a>修改 symbol 格式</h2><p>官方說，bochs的 symbol 的格式為</p><pre><code>The symbol file consists of zero or more lines of the format&quot;%x %s&quot;</code></pre><p>也就是說，只有文字檔格式 &quot;%x %s&quot;  才可以載入，不像GDB可以載入bin，而這邊可以先觀察一下 nm 輸出的格式如下</p><pre><code> 00000000 T startup_32</code></pre><p>中間有一個 type，不符合 bochs 規定的格式，所以要把那個 type 行去掉如果要改變格式，可以利用 awk 來幫助，例如要改變 nm 檔為兩行時，可用下列 awk 指令</p><pre><code> awk &#39;&#123; print $1&quot; &quot;$3 &#125;&#39; system.nm  &gt; system.bsb</code></pre><p>$1與$3 分別代表直排一與直排三，若要搭配在 make 中使用的時候，要加兩個$，如下所示 </p><pre><code>nm:   nm system.elf |sort &gt; system.nm   awk &#39;&#123; print $ $1&quot; &quot;$ $3 &#125;&#39; system.nm &gt; system.bsb</code></pre><p>nm 檔要經過修改後，才可以正確的載入到 bochs</p><h2 id="使用-ini-載入-debug-file"><a href="#使用-ini-載入-debug-file" class="headerlink" title="使用 ini 載入 debug file "></a>使用 ini 載入 debug file </h2><p>在ini中輸入</p><pre><code>debug_symbols: file=&quot;system.bsb&quot;</code></pre><p>system.bsb 為你修改過的 symbol file </p><h2 id="Bochs-手動載入-symbol"><a href="#Bochs-手動載入-symbol" class="headerlink" title="Bochs 手動載入 symbol"></a>Bochs 手動載入 symbol</h2><p>而使用 ldsym 的時候，要加雙引號，如下所示</p><pre><code> ldsym &quot;system.bsb&quot;</code></pre><h2 id="使用-gdb-當作測試-client"><a href="#使用-gdb-當作測試-client" class="headerlink" title="使用 gdb 當作測試 client"></a>使用 gdb 當作測試 client</h2><p>安裝 bochs 時，必須要打開 <code>--enable-gdbstub</code> 後，在 ini 中，加入參數即可</p><pre><code> gdbstub: enabled=1, port=1234</code></pre><h1 id="bochs-debug-指令"><a href="#bochs-debug-指令" class="headerlink" title="bochs debug 指令 "></a>bochs debug 指令 </h1><p>可以在執行時，輸入 h ，會有簡單的指令列表，而在 bochs 中，下中斷要加雙引號，如下所示</p><pre><code> b &quot;TestA&quot; </code></pre><p>也可以列出變數的值，如</p><pre><code>x/10 &quot;idt&quot;</code></pre><p>其實 bochs 應該就是根據 symbol file ，來找出對應的記憶體位置而已，</p><p>Bochs 操作蠻像 GDB 的，以下列出常用的 bochs 的debug 指令</p><table><thead><tr><th>指令</th><th>說明</th></tr></thead><tbody><tr><td>c</td><td>continue，執行 OS</td></tr><tr><td>s</td><td>單步(會進入function)</td></tr><tr><td>n</td><td>單步(不進入function)</td></tr><tr><td>b &quot;main&quot;</td><td>下中斷在 function main 的起始位置，使用時，記得要載入符號表</td></tr><tr><td>d</td><td>刪除中斷</td></tr><tr><td>blist</td><td>列出所有中斷點</td></tr><tr><td>x/10 addr</td><td>列出 addr 的位置的值</td></tr><tr><td>q</td><td>離開 bochs</td></tr></tbody></table><p>其他的指令可見 <a href="http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html">Using Bochs internal debugger</a> 說明</p><h1 id="troubleshooting"><a href="#troubleshooting" class="headerlink" title="troubleshooting "></a>troubleshooting </h1><h2 id="fatal-error-X11-extensions-Xrandr-h-No-such-file-or-directory"><a href="#fatal-error-X11-extensions-Xrandr-h-No-such-file-or-directory" class="headerlink" title="fatal error: X11/extensions/Xrandr.h: No such file or directory"></a>fatal error: X11/extensions/Xrandr.h: No such file or directory</h2><p>ANS:  missing libxrandr-dev</p><h2 id="display-library-39-sdl-39-not-available"><a href="#display-library-39-sdl-39-not-available" class="headerlink" title="display library &#39;sdl&#39; not available"></a>display library &#39;sdl&#39; not available</h2><p>手動安裝的時候，預設的display選項為 x (此例為sdl)所以<code>bochssrc.txt</code>設定要設為</p><pre><code>display_library: x</code></pre><h2 id="BIOS-No-bootable-device"><a href="#BIOS-No-bootable-device" class="headerlink" title="[BIOS ] No bootable device"></a>[BIOS ] No bootable device</h2><p>有很多問題會造成這個錯誤，這邊只是列舉一個</p><pre><code>ans:  floppya image size doesn&#39;t match one of the supported types</code></pre><p>OS 若是使用 floppy 模擬的話，磁碟最好寫滿到count 2888。最後加上</p><pre><code>count=2883 seek=5 conv=notrunc</code></pre><p>以seek5個sector為例，這邊就是寫2883個sector</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><p><a href="http://www.groad.net/bbs/thread-678-1-1.html">http://www.groad.net/bbs/thread-678-1-1.html</a><br><a href="http://www.cnblogs.com/long123king/p/3568575.html">http://www.cnblogs.com/long123king/p/3568575.html</a>     </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;安裝&quot;&gt;&lt;a href=&quot;#安裝&quot; class=&quot;headerlink&quot; title=&quot;安裝&quot;&gt;&lt;/a&gt;安裝&lt;/h1&gt;&lt;p&gt;使用 apt 安裝的是沒有debug 功能的，bochs 通常一出現視窗運行會沒辦法輸入指令，
如果你只是要單純的執行環境的話，就使用 apt安裝吧，如果要 debug 功能的話，就要自行 compile&lt;/p&gt;
&lt;p&gt;下載 &lt;a href=&quot;https://sourceforge.net/projects/bochs/files/bochs/2.6.8/&quot;&gt;bochs 2.6.8 source code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安裝(可參考 orange&amp;#39;s P10)
輸入下列指令 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar vxzf bochs-2.6.8.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;進入目錄後，開始設定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --enable-disasm  --enable-debugger&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要使用 gdb 的話，就不能用 &lt;code&gt;--enable-debugger&lt;/code&gt; ，要換成  &lt;code&gt;--enable-gdbstub&lt;/code&gt;
接下來就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make
sudo make install&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="bochs" scheme="http://wwssllabcd.github.io/tags/bochs/"/>
    
  </entry>
  
  <entry>
    <title>Bitcoin 簡介</title>
    <link href="http://wwssllabcd.github.io/2015/08/21/what-is-bitcoin/"/>
    <id>http://wwssllabcd.github.io/2015/08/21/what-is-bitcoin/</id>
    <published>2015-08-21T15:32:31.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>發明者: 中本聰(<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%9C%AC%E8%81%AA">1</a>)，但這只是化名，真實身份不明，應該是一群想撈錢的集團幹的</p><p>經過: It&#39;s a very long story，請見資料(<a href="https://yowureport.com/%E5%85%A9%E5%B9%B42%E8%90%AC%E5%80%8D%E7%9A%84%E5%8D%87%E5%80%BC%EF%BC%8C%E6%9C%80%E5%88%92%E7%AE%97%E7%9A%84%E6%8A%95%E8%B3%87-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-bitcoin/">2</a>)</p><h2 id="使用過程"><a href="#使用過程" class="headerlink" title="使用過程"></a>使用過程</h2><p>其實就是妳的電子錢包，把交易的訊息(如我要把 100 個 bitcoin 轉給 A)這條訊息用數位簽章簽過，經過P2P網路送給所有的錢包使用者手上，利用P2P網路把交易的訊息傳遞出去，利用RSA保證身份，是一種去中心化的貨幣</p><h2 id="產生比特的方式"><a href="#產生比特的方式" class="headerlink" title="產生比特的方式"></a>產生比特的方式</h2><p>就是所謂的 mining(挖礦)，透過這個公式 </p><pre><code>SHA256( Block data + Random nonce ) &lt; 難度值</code></pre><p>來算出來(<a href="https://www.ptt.cc/bbs/Soft_Job/M.1385557793.A.5E6.html">3</a>)，而 Block data 就是上一筆交易的資料，也就是說，Block data 再加上某個值 N ，如果丟到 SHA 中運算小於這次難度值的結果的話就代表挖到礦，挖到的東西就是新的 block，這個Block會把數字 N 還有這段期間收到的交易資料還有新的難度值，包成一包變成新的BlockNo後，接在舊的後面後，再藉由P2P傳出去，別人在根據新 BlockNo 繼續玩上面那套公式，而所謂的&quot;難度值&quot;會根據 BlockNo 根據當初設計的公式調整(這個數值會每隔2016個block，網絡大約每小時創建6個塊，創建2016塊大約2週)調整一次)，所以後面會越來越難挖，變成總數(發行量)會趨近於某個數值，又因為交易的資料是伴隨著新的 Block 用P2P的方式散布出去，所以有時候交易的資料並不會馬上顯示出來，約要等 6 個 block 左右的時間才可能散布到所有使用者手上</p><p>而<a href="https://zh.wikipedia.org/zh-hant/SHA%E5%AE%B6%E6%97%8F">SHA-256</a>是一種<a href="https://zh.wikipedia.org/zh-hant/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">雜湊演算法</a> (Hash algorithm)，他的公式會讓輸入的值變成長度固定的數字，例如輸入 Fox，可能會產生 DFCD3454(<a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8#/media/File:Hash_function.svg">4</a>)，他的原理有點類似拿一個質數來取餘數，如以質數 13 來做雜湊的 Base Key 的話，數字131的雜湊值就是1( 131 mod 13 = 1，就是他的餘數)，而 1 的雜湊值也是 1，而 261 的雜湊也是 1，發生了有好幾個數值Hash都相同，這個就叫做碰撞，產生碰撞的雜湊代表 Base Key 選的很爛，通常要大一點的質數才行，而SHA演算法就是以數學的角度上去確定這個碰撞的機會很小(所以才叫 &quot;Secure&quot; Hash Algorithm )</p><p>至於怎樣確定 SHA 是安全的，本人密碼學上課都在神遊，so ... 就到此為止</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;發明者: 中本聰(&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%9C%AC%E8%81%AA&quot;&gt;1&lt;/a&gt;)，但這只是化名，真實身份不明，應該是一群想撈錢的集團幹的&lt;/p&gt;
&lt;p&gt;經過: It&amp;#39;s a ver</summary>
      
    
    
    
    
    <category term="Bitcoin" scheme="http://wwssllabcd.github.io/tags/Bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>Lamobo M1( banana pi ) 安裝心得</title>
    <link href="http://wwssllabcd.github.io/2015/01/12/how-to-setup-Lamobo-m1/"/>
    <id>http://wwssllabcd.github.io/2015/01/12/how-to-setup-Lamobo-m1/</id>
    <published>2015-01-12T15:32:31.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lamobo M1 (之前比較常見的名稱為 Banana Pi, 又稱香蕉派) 跟 Raspberry pi(以下簡稱 RPI ) 一樣是屬於單版電腦，Lamobo-M1(以下簡稱 M1)而 Lamobo M1 與 Banana Pi 是同一片板子，根據該公司的說法，這是透過雙品牌的方式來運營，Banana Pi 專注於開源社群的運營</p><h1 id="評比"><a href="#評比" class="headerlink" title="評比"></a>評比</h1><p>以下為雙方比較大的差異點，見下表</p><table><thead><tr><th></th><th><a href="http://zh.wikipedia.org/wiki/%E6%A0%91%E8%8E%93%E6%B4%BE#.E7.A1.AC.E9.AB.94.E8.A7.84.E6.A0.BC.EF.BC.88Spec..EF.BC.89">Raspberry Pi Mode B</a></th><th><a href="http://lamobo.com/lamobom.html">Lamobo-M1</a></th><th>簡評</th></tr></thead><tbody><tr><td>CPU</td><td>Broadcom BCM2835 ARM11系列）700MHz</td><td><a href="http://linux-sunxi.org/A20">Allwinner A20</a> 1 GHz ARM Cortex-A7 Dual-Core</td><td>M1勝</td></tr><tr><td>GPU</td><td>Broadcom VideoCore IV @ 250 MHz</td><td>ARM Mali400MP2</td><td></td></tr><tr><td>RAM</td><td>512 M</td><td>1GB DDR3</td><td>M1勝</td></tr><tr><td>OS</td><td>支援 XBMC</td><td>支援 RPI 的 OS，也有 andorid, 但有些不能使用</td><td>各有勝負</td></tr><tr><td>sata</td><td>無</td><td>SATA*1</td><td>M1勝</td></tr><tr><td>Lan</td><td>10/100 Ethernet RJ45 x1</td><td>10/100/1000 Ethernet RJ45 x1</td><td>M1勝</td></tr></tbody></table><a id="more"></a><p>對我而言，M1 硬體的確是大勝 RPI，但我不喜歡對岸的東西，總覺得有可能會偷傳什麼資料的，除了大陸製，還有外殼難看以上這幾點外， M1的確沒什麼好挑剔的，NT 1900 就可以買到這種配備，算是佛心來著的  </p><h1 id="安裝-Raspbian"><a href="#安裝-Raspbian" class="headerlink" title="安裝 Raspbian"></a>安裝 Raspbian</h1><p>到 <a href="http://www.lemaker.org/resources/9-38/image_files.html">Lemaker OS 下載網頁</a>下載，要注意不要下載到 Pro 版本，()通常你買到的是 Banana Pi，如果你版子上有電源按鈕的話，那就是 Pro 版)，選 Raspbian 下載後解開得到 img 檔後，使用 <a href="http://sourceforge.net/projects/win32diskimager/">Win32Diskimager</a> 寫入至 SD 卡，過程與 RPI 相同，預設密碼為 <code>root/bananapi</code>，，預設電腦名稱為`lemaker&#39;，進入 OS 後，一樣可執行 Rasp-config 來修改細部設定，詳細情形與RPI相同</p><h1 id="安裝-Bananian"><a href="#安裝-Bananian" class="headerlink" title="安裝 Bananian"></a>安裝 Bananian</h1><p>到 <a href="http://www.lemaker.org/resources/9-38/image_files.html">Lemaker OS 下載網頁</a>下載，選 Raspbian 下載後解開得到 img 檔後，使用 <a href="http://sourceforge.net/projects/win32diskimager/">Win32Diskimager</a> 寫入至 SD 卡，過程與 RPI 相同，預設密碼為 <code>root/pi</code>，預設電腦名稱為<code>bananapi&#39;，進入 OS 後，可執行 </code>bananian-config` 來修改細部設定</p><h1 id="安裝-XBMC"><a href="#安裝-XBMC" class="headerlink" title="安裝 XBMC"></a>安裝 XBMC</h1><p>到 <a href="http://www.lemaker.org/resources/9-38/image_files.html">Lemaker OS 下載網頁</a>下載，選 LeMedia 後下載解壓縮完得到 img 檔後，使用 <a href="http://sourceforge.net/projects/win32diskimager/">Win32Diskimager</a> 刷入即可，不過要注意的是 LeMedia 還在開發階段，很多東西都不太能用，播放起來也很 lag，也沒聲音，簡單的來說就是 <em>XBMC for linux on Allwinner devices is NOT READY FOR USE!</em></p><h1 id="安裝-Android"><a href="#安裝-Android" class="headerlink" title="安裝 Android"></a>安裝 Android</h1><p>到 <a href="http://www.lemaker.org/resources/9-38/image_files.html">Lemaker OS 下載網頁</a>下載，選 Android，解開後得到 img 檔，但這次不能用 <a href="http://sourceforge.net/projects/win32diskimager/">Win32Diskimager</a> 來刷，要使用全志自己的卡刷工具 PhoenixCard，但是這個工具放在大陸的百度雲，下載很麻煩，打開後我卡刷也失敗，所以放棄，這邊提供<a href="http://forum.lemaker.org/cn/thread-64-1-1-Android+4.2+%E9%95%9C%E5%83%8F%E7%83%A7%E5%BD%95SD%E5%8D%A1%E6%95%99%E7%A8%8B.html">Android 詳細刷機方法</a>，有興趣可以自己參考</p><h1 id="效能"><a href="#效能" class="headerlink" title="效能"></a>效能</h1><p>因為農場是我買該機的原因，所以測試也以農場軟體相關，見下表</p><table><thead><tr><th></th><th>Raspberry pi</th><th>Lamobo-M1</th><th>簡評</th></tr></thead><tbody><tr><td>transmission-daemon</td><td>約 3MB，CPU 負載率超過 95%</td><td>輕鬆上 6MB，CPU 約 20%</td><td>M1勝</td></tr><tr><td>Samba</td><td>約 2.x MB，CUP 與 RAM 負載高</td><td>可上 9MB</td><td>M1勝</td></tr></tbody></table><p>這邊測試的是 Raspbian for Banana Pro 的 OS，而 Raspbian for Banana pi 數據只比 Raspberry Pi 好一點，我不知道為何，這個數據也許不太準，參考看看就好了，我後來改安裝 Raspbian for Banana pi ，其 transmission-daemon 的 CPU 老是給我 100%，不知哪裡有問題，不過換回去 Raspbian for Banana Pro 的就正常許多，可是我的版子又是 Banana Pi，反而要裝 For Pro 的 OS 才會比較好，真是一整個怪</p><h1 id="相關資源"><a href="#相關資源" class="headerlink" title="相關資源"></a>相關資源</h1><p>Banana pi 有其<a href="http://forum.lemaker.org/cn/forum.php">中文BPI官方論壇</a>，有中文的，但討論不熱烈，最好還是去<a href="http://forum.lemaker.org/forum.php">英文BPI官方論壇</a>比較好</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>我測兩次都有不一樣的數據，所以無從推薦，Lamobo 差就差在支援太少，雖然有很多 OS 可玩，但都只是能開機而已，就像是 XBMC 一樣，只是能開機而已，根本就是 NOT READY FOR USE  </p><p>Lamobo 目前只有看到在開農場的時候，同時使用 samba 會比較快之外，目前看不到什麼利基，若你喜歡折腾又有閒錢的話，可以試試，若要買還是<a href="http://www.raspberrypi.org/raspberry-pi-2-on-sale/">Raspberry Pi 2</a>會比較理想</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Lamobo M1 (之前比較常見的名稱為 Banana Pi, 又稱香蕉派) 跟 Raspberry pi(以下簡稱 RPI ) 一樣是屬於單版電腦，Lamobo-M1(以下簡稱 M1)
而 Lamobo M1 與 Banana Pi 是同一片板子，根據該公司的說法，這是透過雙品牌的方式來運營，Banana Pi 專注於開源社群的運營&lt;/p&gt;
&lt;h1 id=&quot;評比&quot;&gt;&lt;a href=&quot;#評比&quot; class=&quot;headerlink&quot; title=&quot;評比&quot;&gt;&lt;/a&gt;評比&lt;/h1&gt;&lt;p&gt;以下為雙方比較大的差異點，見下表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%A0%91%E8%8E%93%E6%B4%BE#.E7.A1.AC.E9.AB.94.E8.A7.84.E6.A0.BC.EF.BC.88Spec..EF.BC.89&quot;&gt;Raspberry Pi Mode B&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;http://lamobo.com/lamobom.html&quot;&gt;Lamobo-M1&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;簡評&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;Broadcom BCM2835 ARM11系列）700MHz&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://linux-sunxi.org/A20&quot;&gt;Allwinner A20&lt;/a&gt; 1 GHz ARM Cortex-A7 Dual-Core&lt;/td&gt;
&lt;td&gt;M1勝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GPU&lt;/td&gt;
&lt;td&gt;Broadcom VideoCore IV @ 250 MHz&lt;/td&gt;
&lt;td&gt;ARM Mali400MP2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAM&lt;/td&gt;
&lt;td&gt;512 M&lt;/td&gt;
&lt;td&gt;1GB DDR3&lt;/td&gt;
&lt;td&gt;M1勝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OS&lt;/td&gt;
&lt;td&gt;支援 XBMC&lt;/td&gt;
&lt;td&gt;支援 RPI 的 OS，也有 andorid, 但有些不能使用&lt;/td&gt;
&lt;td&gt;各有勝負&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sata&lt;/td&gt;
&lt;td&gt;無&lt;/td&gt;
&lt;td&gt;SATA*1&lt;/td&gt;
&lt;td&gt;M1勝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lan&lt;/td&gt;
&lt;td&gt;10/100 Ethernet RJ45 x1&lt;/td&gt;
&lt;td&gt;10/100/1000 Ethernet RJ45 x1&lt;/td&gt;
&lt;td&gt;M1勝&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 安裝教學、心得筆記</title>
    <link href="http://wwssllabcd.github.io/2014/12/22/how-to-install-hexo/"/>
    <id>http://wwssllabcd.github.io/2014/12/22/how-to-install-hexo/</id>
    <published>2014-12-22T08:48:07.000Z</published>
    <updated>2020-11-07T16:03:13.091Z</updated>
    
    <content type="html"><![CDATA[<p>自從用了 Octopress ( static page + markdown 寫 blog 後 )，我發現我回不去了以前那些所謂聰明的 blog system，以前在看 blog 的時候就超討厭 blog 自動產生一些 tag 等東西而把網頁弄得超慢，明明每次生成的東西都一樣，每一次都要自動產生的什麼鬼的，看了就不爽  </p><p>不過 Octopress 很久沒更新，且又只能限定使用 Ruby 1.9.3，造成很多不方便，所以我又跳槽到同樣是 Static Page 的 Blog System -- <a href="http://hexo.io/">Hexo</a>，特別是作者 <a href="https://twitter.com/tommy351">tommy351</a> 是台灣人，所以用起來更是愉快，這邊有<a href="http://zespia.tw/blog/2012/10/11/hexo-debut/">作者對 hexo 的介紹</a><br><img src="https://lh4.googleusercontent.com/-zW5Mdi4neqc/VJkouOcaeCI/AAAAAAAAswE/EMMODfCyNTU/s0/GitHub_icon.jpg" alt="Hexo 可建構在 GitHub 上面，為什麼放這張圖是因為它可愛 XD"></p><h1 id="安裝-Hexo"><a href="#安裝-Hexo" class="headerlink" title="安裝 Hexo "></a>安裝 Hexo </h1><h2 id="安裝-Hexo-所需檔案"><a href="#安裝-Hexo-所需檔案" class="headerlink" title="安裝 Hexo 所需檔案"></a>安裝 Hexo 所需檔案</h2><p>Hexo 是建構在 Node.js 上面，所以第一步就是安裝 Node.js，到 <a href="http://nodejs.org/">http://nodejs.org/</a> 下載並安裝，安裝好 Node.js 後，在程式集中會出現 <code>Node.js command prompt</code>，點開後會進入到命令提示字元，接下來輸入</p><pre><code>npm install hexo-cli -g</code></pre><p>而在 Ubuntu 下面安裝則要加上 sudo， 之後不再詳述此點</p><pre><code>sudo npm install hexo-cli -g</code></pre><p>安裝好後可以鍵入 hexo 看看有沒有反應，若有反應就代表安裝好了</p><pre><code>hexo # 測試 hexo 是否被正確安裝</code></pre><a id="more"></a><h2 id="建置你的-Hexo-Blog"><a href="#建置你的-Hexo-Blog" class="headerlink" title="建置你的 Hexo Blog"></a>建置你的 Hexo Blog</h2><p>選定你所要的目錄後(這邊取名叫<code>Blog</code>)，輸入</p><pre><code>hexo init Blogcd Blognpm install</code></pre><p>這樣就完成了初步的建置，這樣大致的就完成了建置了，簡單吧，若要檢視Blog可以使用</p><pre><code>hexo g  # 產生 bloghexo s  # 讓 blog 可以在 local 端檢視</code></pre><p>然後打開瀏覽器，輸入 <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000</a> 就可以看到你的 Blog 了</p><h2 id="把-Blog-放在-Github-上"><a href="#把-Blog-放在-Github-上" class="headerlink" title="把 Blog 放在 Github 上"></a>把 Blog 放在 Github 上</h2><p>首先先開一個 Repostory，取名叫 Blog 後，記住該 Repostory 的 clone 路徑後，打開本地端 Blog 中的_config.yml，尋找 <code>deploy:</code>後，type 輸入 github，repository 就去 github 那邊，把你專案的 repo 路徑抄在這，最好是選 ssh 的，branch 選 gh-pages <code>(固定，很重要，因為 github 固定以此 branch 作為網站的目錄)</code>，最後會長成像以下這個樣子</p><pre><code>deploy:    type: github    repository: git@github.com:yourname/yourRepo.git    branch: gh-pages</code></pre><p>記住，repository 後面的 yourname，請改成你的帳號，而 yourRepo 就是你剛剛取的名子，其實這個也是 git clone 使用的路徑<br>若真的不行的話，請參考<a href="http://www.jianshu.com/p/05289a4bc8b2">如何搭建一個獨立博客</a>，這邊就不再詳述  </p><p>PS: 而新版的 Hexo 已把 deploy 的方式改變，詳見 <a href="http://hexo.io/docs/deployment.html">Hexo Deployment</a>  </p><p>若發生 ERROR Deployer not found: git，請執行以下指令試試</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>接下來找到 URL 的部份，root 那邊必須要跟你的 repo 一樣，如下所示</p><pre><code># URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://xxx.github.io/Blogroot: /Blog/</code></pre><p>設好後，回到 nodejs，鍵入</p><pre><code>hexo d  # 部署 blog 到 GitHub 上</code></pre><p>就可以上傳你的 blog 到 github 了</p><h2 id="使用標準的-markdown"><a href="#使用標準的-markdown" class="headerlink" title="使用標準的 markdown"></a>使用標準的 markdown</h2><p>由於新版的 Hexo 使用 hexo-renderer-marked 來控制 Markdown ，而所以還要在調整一下，在 _config.yml 中，鍵入以下參數   </p><pre><code>marked:    gfm: true    pedantic: false    sanitize: false    tables: false    breaks: false    smartLists: false    smartypants: false</code></pre><p>其中 breaks 是控制斷行的，一般來說 markdown 是採用兩個空格( two space )來代表<code>&lt;p&gt;</code>，若喜歡用 markdown 的格式的話，這邊要設為 false，建議除了 gfm 是設 true 之外. 都設為 false 比較好  </p><h2 id="建立新文章"><a href="#建立新文章" class="headerlink" title="建立新文章"></a>建立新文章</h2><pre><code>hexo new &quot;postName&quot;  # 建立一個新的文章</code></pre><h1 id="增加其他功能"><a href="#增加其他功能" class="headerlink" title="增加其他功能"></a>增加其他功能</h1><h2 id="加入留言"><a href="#加入留言" class="headerlink" title="加入留言 "></a>加入留言 </h2><p>使用 <a href="https://disqus.com/">Disqus</a>，在_config.yml中，尋找 disqus_shortname ，並把後面加成你 Disqus 的 id </p><pre><code># Disqusdisqus_shortname: 名稱</code></pre><h2 id="加入-Google-Analytics"><a href="#加入-Google-Analytics" class="headerlink" title="加入 Google Analytics"></a>加入 Google Analytics</h2><p>Hexo 有兩個 _config.yml，一個在根目錄，一個則是 theme 使用，這邊的就要用到 theme 的 _config.yml，而以預設的 theme 來做範例，編輯 theme 目錄下的 _config.yml</p><pre><code>./themes/light/_config.yml</code></pre><p>找到<code>google_analytics:</code>後，把 ID 貼在這邊即可</p><h2 id="加入-TOC-Table-Of-Content"><a href="#加入-TOC-Table-Of-Content" class="headerlink" title="加入 TOC ( Table Of Content) "></a>加入 TOC ( Table Of Content) </h2><p>以預設的 theme 為例，在.\themes\landscape\layout_partial\article.ejs中，找到<code>&lt;%- post.content %&gt;</code>後，再把以下的段落，加在<code>&lt;%- post.content %&gt;</code>之前</p><pre><code>&lt;% if(post.toc == true)&#123; %&gt;        &lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt;            &lt;%- toc(post.content) %&gt;        &lt;/div&gt;&lt;% &#125; %&gt;</code></pre><p>以上段落就是加入 TOC 的位置，適時上可以在任何你喜歡的地方加入<br>然後在每篇文章的屬性那邊，加入</p><pre><code>toc: true </code></pre><p>就可以決定要不要打開該文章，而這邊可以利用 markdown 的<code>===</code>與<code>---</code>做 TOC 一級、二級的控制<br>題外話，這邊也可以觀察到，post 其實就是對應到文章的屬性  </p><pre><code>post.content: 文章內容post.title: 文章標題post.toc: 這邊 toc 屬性其實是自己加的，若沒設定應該是 null 的值吧</code></pre><h2 id="加入-sitemap"><a href="#加入-sitemap" class="headerlink" title="加入 sitemap "></a>加入 sitemap </h2><p>使用 sitemap 可以讓搜尋引擎可以快一點把你的網站抓回去, 加入的方法也很簡單, 鍵入</p><pre><code>npm install hexo-generator-sitemap --save</code></pre><p>然後在 <code>_config.yml</code> 中加入以下選項即可</p><pre><code>sitemap:    path: sitemap.xml</code></pre><h2 id="加入-RSS-Feed"><a href="#加入-RSS-Feed" class="headerlink" title="加入 RSS Feed "></a>加入 RSS Feed </h2><p>使用 feed 可以讓別人訂閱你的文章, 鍵入</p><pre><code>npm install hexo-generator-feed</code></pre><p>然後在 <code>_config.yml</code> 中加入</p><pre><code>#Feed Atomfeed:    type: atom    path: atom.xml    limit: 20</code></pre><p>即可</p><h1 id="從-Octopress-轉換到-Hexo"><a href="#從-Octopress-轉換到-Hexo" class="headerlink" title="從 Octopress 轉換到 Hexo"></a>從 Octopress 轉換到 Hexo</h1><p>其實要轉換不會太麻煩，只是有幾個地方要注意的就是了  </p><h2 id="網站的根目錄"><a href="#網站的根目錄" class="headerlink" title="網站的根目錄"></a>網站的根目錄</h2><p>在 _config.yml 中，網站的根目錄最好設為 <code>blog</code>(注意大小寫)，如下所示</p><pre><code>root: /blog/</code></pre><h2 id="Octopress-的文章放在-hexo-上-Compile"><a href="#Octopress-的文章放在-hexo-上-Compile" class="headerlink" title="Octopress 的文章放在 hexo 上 Compile"></a>Octopress 的文章放在 hexo 上 Compile</h2><p>文章可以直接放過去，只是 categories 要換成 tag 會比較好，不換也可以，只是 hexo 會變成 categories 而已</p><h2 id="新文章的格式"><a href="#新文章的格式" class="headerlink" title="新文章的格式"></a>新文章的格式</h2><p>Octopress 產生的 markdown 檔案是有帶日期的，但 Hexo 沒有，如果想讓 Hexo 帶日期，可以修改 _config.yml中的 <code>new_post_name</code>，改成下列格式即可</p><pre><code>new_post_name: :year-:month-:day-:title.md</code></pre><p>不過這樣改，hexo 產生文章的 link 依然是以 title 為主，這樣剛好相容於 octopress，真是太棒了  </p><h1 id="換佈景主題"><a href="#換佈景主題" class="headerlink" title="換佈景主題"></a>換佈景主題</h1><p>可先到 <a href="https://github.com/hexojs/hexo/wiki/Themes">Hexo Theme</a> 先決定好一個主題後，把該主題clone 下來，放在/theme 目錄中，如我想要換 daisy 這個主題，則需要做以下步驟</p><pre><code>git clone https://github.com/imbyron/hexo-theme-daisy.git ./themes/daisy  </code></pre><p>接著在_config.yml中，尋找 theme 這個關鍵字後，輸入剛載下來的那個目錄的名稱，如下所示</p><pre><code>theme: daisy</code></pre><h2 id="修改-default-theme-的封面"><a href="#修改-default-theme-的封面" class="headerlink" title="修改 default theme 的封面"></a>修改 default theme 的封面</h2><p>修改封面，各家的都不太一樣，要自己去找，而修改 landscape 的封面為以下兩個<br>修改封面圖案(圖片大小為 1920x1200 )</p><pre><code>YourBlogPath/themes/landscape/source/css/images/banner.jpg</code></pre><p>使用外部封面圖案</p><pre><code>YourBlogPath/themes/landscape/source/css/_variables.styl</code></pre><p>裡面的<code>banner-url = &quot;images/banner.jpg&quot;</code><br>在這邊提供一個小技巧, 因為原始的 theme 是搭配黑色為底， 所以我們可以去 Flickr 那邊找CC授權的<a href="https://www.flickr.com/search/?q=milkway">銀河(milk way)</a>照片，看到滿意的就抓下來當封面這樣就可以弄得跟預設的不一樣了</p><h2 id="修改-theme-cover"><a href="#修改-theme-cover" class="headerlink" title="修改 theme -- cover"></a>修改 theme -- cover</h2><p>Hexo 的 theme 中，有個叫 <a href="https://github.com/daisygao/hexo-themes-cover">theme cover</a> 做的蠻可愛的，也蠻乾淨的，所以這邊拿來當作範例  </p><ul><li>修改封面: 在 theme/cover下的 _comfig.yml 中修改   </li><li>修改中間的小圖: 放在/source/logo.png  </li><li>修改 brower 的 ico: 放在/source/favicon.ico</li></ul><p>而_comfig.yml中的 auto_change 最好也關掉，如果不想再文章下面出現分享到微博之類的，就把 add this 也關掉，留言系統，若想使用原本的 default 值，就把 comment_provider 槓掉即可</p><h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><h2 id="執行-hexo-d-後，出現-xxx-page-not-found"><a href="#執行-hexo-d-後，出現-xxx-page-not-found" class="headerlink" title="執行 hexo d 後，出現 xxx page not found "></a>執行 hexo d 後，出現 xxx page not found </h2><p>檢查文章檔案名稱是否包含空白</p><h2 id="執行-hexo-g-後，出現-warning-LF-will-be-replaced-by-CRLF"><a href="#執行-hexo-g-後，出現-warning-LF-will-be-replaced-by-CRLF" class="headerlink" title="執行 hexo g 後，出現 warning: LF will be replaced by CRLF"></a>執行 hexo g 後，出現 warning: LF will be replaced by CRLF</h2><p>輸入以下指令</p><pre><code>git config --global core.autocrlf false</code></pre><h2 id="在其他的地方-別台電腦-check-out-下來你的-blog-src"><a href="#在其他的地方-別台電腦-check-out-下來你的-blog-src" class="headerlink" title="在其他的地方(別台電腦) check out 下來你的 blog src  "></a>在其他的地方(別台電腦) check out 下來你的 blog src  </h2><p>因為 Hexo 的 Module 是跟著目錄的，所以如果把 code check out 下來，還是要在該目錄執行  </p><pre><code>npm install</code></pre><p>或者是</p><pre><code>npm install hexo-renderer-ejs --savenpm install hexo-renderer-marked --savenpm install hexo-renderer-stylus --save</code></pre><p>這三個，你會觀察到 ./node_modules 多了一些檔案  </p><h2 id="出現-src-refspec-master-does-not-match-any"><a href="#出現-src-refspec-master-does-not-match-any" class="headerlink" title="出現 src refspec master does not match any"></a>出現 src refspec master does not match any</h2><p>檢查一下你的 repo 是否還沒有上傳檔案，你可以先把 src 上傳之後，在做 deploy 的動作看看</p><h2 id="出現-spawn-ENOENT-at-errnoException-childprocess-js-1001-11"><a href="#出現-spawn-ENOENT-at-errnoException-childprocess-js-1001-11" class="headerlink" title="出現 spawn ENOENT at errnoException childprocess.js:1001:11"></a>出現 spawn ENOENT at errnoException childprocess.js:1001:11</h2><ul><li>輸入 git 檢查一下你的環境是否可以使用 git，如果不行的話，要把 git 加入到環境變數中才行   </li><li>輸入 node -v  檢查一下你的環境是否可以使用 node    </li><li>輸入 hexo --version 檢查一下你的環境是否可以使用 hexo   </li></ul><h2 id="出現-fatal-Could-not-read-from-remote-repository"><a href="#出現-fatal-Could-not-read-from-remote-repository" class="headerlink" title="出現 fatal: Could not read from remote repository."></a>出現 fatal: Could not read from remote repository.</h2><p>檢查 Git ssh 設定，或者是在 Git Bash 中執行</p><h2 id="出現-events-js-85-的錯誤"><a href="#出現-events-js-85-的錯誤" class="headerlink" title="出現 events.js:85 的錯誤"></a>出現 events.js:85 的錯誤</h2><p>執行 hexo d 發生錯誤，錯誤訊息如下所示</p><pre><code>INFO  Deploying: gitINFO  Clearing .deploy folder...INFO  Copying files from public folder...events.js:85    throw er; // Unhandled &#39;error&#39; event        ^Error: spawn git ENOENT    at exports._errnoException (util.js:746:11)    at Process.ChildProcess._handle.onexit (child_process.js:1053:32)    at child_process.js:1144:20    at process._tickCallback (node.js:355:11)</code></pre><p>解法: 在 Git Bash 中執行 hexo d 即可</p><h2 id="執行-hexo-d-出現-permission-denied-publickey"><a href="#執行-hexo-d-出現-permission-denied-publickey" class="headerlink" title="執行 hexo d 出現 permission denied (publickey)."></a>執行 hexo d 出現 permission denied (publickey).</h2><ul><li><p>先檢查自己的 .ssh 目錄( windows 是放在 C:\Users\yourname.ssh\  ) 有沒有放入 id_rsa</p></li><li><p>若有id_rsa檔案，但是還是有問題的話，可能是權限問題，特別是用 window 系統 copy 過去，修改成以下即可</p><p>  cd ~/.ssh  chmod 700 id_rsa</p></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://dreamerslab.com/blog/tw/how-to-setup-a-node-js-development-environment-on-windows/">如何在 Windows 上設定 node.js 的開發環境</a><br><a href="http://www.jianshu.com/p/05289a4bc8b2">如何搭建一個獨立博客——簡明Github Pages與Hexo教程</a><br><a href="http://ibruce.info/2013/11/22/hexo-your-blog/">hexo你的博客</a><br><a href="http://code.wileam.com/update-hexo/">升級hexo的一些坑</a><br><a href="http://blog.sunnyxx.com/2014/03/07/hexo_customize/">hexo的私人訂製</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自從用了 Octopress ( static page + markdown 寫 blog 後 )，我發現我回不去了以前那些所謂聰明的 blog system，以前在看 blog 的時候就超討厭 blog 自動產生一些 tag 等東西而把網頁弄得超慢，
明明每次生成的東西都一樣，每一次都要自動產生的什麼鬼的，看了就不爽  &lt;/p&gt;
&lt;p&gt;不過 Octopress 很久沒更新，且又只能限定使用 Ruby 1.9.3，造成很多不方便，所以我又跳槽到同樣是 Static Page 的 Blog System -- &lt;a href=&quot;http://hexo.io/&quot;&gt;Hexo&lt;/a&gt;，
特別是作者 &lt;a href=&quot;https://twitter.com/tommy351&quot;&gt;tommy351&lt;/a&gt; 是台灣人，所以用起來更是愉快，
這邊有&lt;a href=&quot;http://zespia.tw/blog/2012/10/11/hexo-debut/&quot;&gt;作者對 hexo 的介紹&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://lh4.googleusercontent.com/-zW5Mdi4neqc/VJkouOcaeCI/AAAAAAAAswE/EMMODfCyNTU/s0/GitHub_icon.jpg&quot; alt=&quot;Hexo 可建構在 GitHub 上面，為什麼放這張圖是因為它可愛 XD&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;安裝-Hexo&quot;&gt;&lt;a href=&quot;#安裝-Hexo&quot; class=&quot;headerlink&quot; title=&quot;安裝 Hexo &quot;&gt;&lt;/a&gt;安裝 Hexo &lt;/h1&gt;&lt;h2 id=&quot;安裝-Hexo-所需檔案&quot;&gt;&lt;a href=&quot;#安裝-Hexo-所需檔案&quot; class=&quot;headerlink&quot; title=&quot;安裝 Hexo 所需檔案&quot;&gt;&lt;/a&gt;安裝 Hexo 所需檔案&lt;/h2&gt;&lt;p&gt;Hexo 是建構在 Node.js 上面，所以第一步就是安裝 Node.js，到 &lt;a href=&quot;http://nodejs.org/&quot;&gt;http://nodejs.org/&lt;/a&gt; 下載並安裝，
安裝好 Node.js 後，在程式集中會出現 &lt;code&gt;Node.js command prompt&lt;/code&gt;，點開後會進入到命令提示字元，接下來輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-cli -g&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在 Ubuntu 下面安裝則要加上 sudo， 之後不再詳述此點&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo npm install hexo-cli -g&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安裝好後可以鍵入 hexo 看看有沒有反應，若有反應就代表安裝好了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo # 測試 hexo 是否被正確安裝&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Hexo" scheme="http://wwssllabcd.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Firefox addon-SDK 介紹, page-mod</title>
    <link href="http://wwssllabcd.github.io/2014/12/21/building-an-extension-for-firefox-PageMod/"/>
    <id>http://wwssllabcd.github.io/2014/12/21/building-an-extension-for-firefox-PageMod/</id>
    <published>2014-12-21T08:45:54.000Z</published>
    <updated>2016-06-05T16:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用時機"><a href="#使用時機" class="headerlink" title="使用時機"></a>使用時機</h1><p>今天要介紹的是 Firefox addon-SDK 中的 <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/page-mod">page-mod</a>, 使用時機為<code>想要把讀回來的網頁, 再加以修改</code>, 例如</p><ol><li>把某網站的排版重新排一下, 例如台鐵的火車時刻表</li><li>想把某些網站廣告區塊移除掉</li><li>想把網頁中特定資訊給顯現出來, 例如某影音網站的影片下載連結</li></ol><p>就可以使用這個, 使用的方式如下</p><h1 id="page-mode-簡介"><a href="#page-mode-簡介" class="headerlink" title="page-mode 簡介"></a>page-mode 簡介</h1><p>官方給的範例如下  </p><pre><code>var pageMod = require(&quot;sdk/page-mod&quot;);pageMod.PageMod(&#123;    include: &quot;*.mozilla.org&quot;,    contentScript: &#39;window.alert(&quot;Page matches ruleset&quot;);&#39;&#125;);</code></pre><a id="more"></a><p>這邊簡單的說明使用方式  </p><pre><code>include: 要對哪個 url 做動作, 符合的才會做接下來的動作  contentScript: 符合include 的條件後, 接下來的動作</code></pre><p>以上程式碼意思為假若 url 是 <code>*.mozilla.org</code> 的話, 則會跳出訊息<code>Page matches ruleset</code>, 當然簡單的 JS 可以這樣弄, 比較複雜的 JS 建議使用 file, 如下所示</p><pre><code>pageMod.PageMod(&#123;    include: &quot;*.mozilla.org&quot;,    contentScriptFile: &quot;./my-script.js&quot;&#125;);</code></pre><p>這邊從 <code>contentScript</code> 變成了 <code>contentScriptFile</code>, 然後 <code>./my-script.js</code> 的路徑是在 <code>/data</code> 區, 來看看<code>my-script.js</code>裡面長怎樣吧   </p><pre><code>//my-script.jswindow.alert(&quot;Page matches ruleset&quot;);   </code></pre><p>只有一行, 其實就是把 contentScript 中的括號拿掉, 就是.js中的內容了</p><h1 id="實戰-製作某影音網站的下載器"><a href="#實戰-製作某影音網站的下載器" class="headerlink" title="實戰 -- 製作某影音網站的下載器"></a>實戰 -- 製作某影音網站的下載器</h1><p>先來看一下 main.js, 當然, 目標網站的網址被我馬賽克掉了:D    </p><pre><code>var pageMod = require(&quot;sdk/page-mod&quot;);var targeURL = &quot;http://www.thisXX.com/video/*&quot;pageMod.PageMod(&#123;    include: targeURL,    contentScriptFile: &quot;./my-script.js&quot;&#125;);</code></pre><p>main.js 一如往常的簡單, 這邊說明了要針對哪個網站做動作外就沒事了, 一樣的我們把難的工作交給外部的 Java Script 檔案  </p><h2 id="找出下載連結"><a href="#找出下載連結" class="headerlink" title="找出下載連結"></a>找出下載連結</h2><p>我們的目標就是該網頁的唯一的 flv 連結 -- <code>即 http 開頭, .flv結尾</code>, 先做一個 function 來取連結</p><pre><code>var getFlvUrl = function(source)&#123;    // find .flv    var endWord = &quot;.flv&quot;;    var endPtr = source.indexOf(endWord);    var startIdx = source.lastIndexOf(&quot;http://&quot;, endPtr);    var len = endWord.length;    return source.substring(startIdx, endPtr + len  );&#125;</code></pre><p>這邊使用 indexOf 來找連結, 事實上用 regualr express 應該會更簡單, 之後再改善即可  </p><h2 id="在原網頁中-加入下載連結"><a href="#在原網頁中-加入下載連結" class="headerlink" title="在原網頁中, 加入下載連結"></a>在原網頁中, 加入下載連結</h2><p>接下來就是找一個地方放這個連結, 但如果隨便放的話, 有可能或破壞原始網頁的結構, 所以最好網頁還是一樣維持原狀, 只是在某個地方偷偷插入一段下載連結, 先來做一個超連結的 html code, 然後再把這段 code 插入原來的網頁</p><pre><code>var downloadInfo = &quot;&lt;P&gt;&lt;a href=&quot; + url + &quot;&gt;&quot; + url + &quot;&lt;/a&gt;&lt;P&gt;&quot;;</code></pre><p>接下來就是製作插入的 function, 這邊的概念也很簡單, 給定一個插入的目標還有字串, 先利用keyword 找出插入的點後, 利用substring 把原始網頁一分為二,接下來就是返還修改過的網頁, 一整個超簡單  </p><pre><code>var insertString = function(source, msg, keyword)&#123;    var idx = source.indexOf(keyword) + keyword.length;    var front = source.substring(0, idx);    var back =  source.substring(idx, source.length);        return front + msg + back;&#125;</code></pre><h2 id="把所有東西組裝起來"><a href="#把所有東西組裝起來" class="headerlink" title="把所有東西組裝起來"></a>把所有東西組裝起來</h2><p>最後就是把工具都組合起來, 這邊採用<code>點擊</code>兩字當作插入的關鍵字位置, 利用 <code>getFlvUrl(</code>) 取出 url, 利用 <code>insertString()</code> 插入下載連結後, 返還修改過的 html code 給瀏覽器    </p><pre><code>var url = getFlvUrl(document.body.innerHTML); var insert = &quot;&lt;P&gt;&lt;a href=&quot; + url + &quot;&gt;&quot; + url + &quot;&lt;/a&gt;&lt;P&gt;&quot;;var html = insertString(document.body.innerHTML, insert, &quot;點擊&quot;);document.body.innerHTML = html;</code></pre><p>整個<code>my-script.js</code>如下所示</p><pre><code>//my-script.jsvar getFlvUrl = function(source)&#123;    // find .flv    var endWord = &quot;.flv&quot;;    var endPtr = source.indexOf(endWord);    var startIdx = source.lastIndexOf(&quot;http://&quot;, endPtr);    var len = endWord.length;    return source.substring(startIdx, endPtr + len  );&#125;var insertString = function(source, msg, keyword)&#123;    var idx = source.indexOf(keyword) + keyword.length;    var front = source.substring(0, idx);    var back =  source.substring(idx, source.length);    return front + msg + back;&#125;var url = getFlvUrl(document.body.innerHTML); var insert = &quot;&lt;P&gt;&lt;a href=&quot; + url + &quot;&gt;&quot; + url + &quot;&lt;/a&gt;&lt;P&gt;&quot;;var html = insertString(document.body.innerHTML, insert, &quot;點擊&quot;);document.body.innerHTML = html;</code></pre><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>Firefox 的 addon-SDK 其實把很多事情都簡化了, 做一個附加元件其實很簡單的</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用時機&quot;&gt;&lt;a href=&quot;#使用時機&quot; class=&quot;headerlink&quot; title=&quot;使用時機&quot;&gt;&lt;/a&gt;使用時機&lt;/h1&gt;&lt;p&gt;今天要介紹的是 Firefox addon-SDK 中的 &lt;a href=&quot;https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/page-mod&quot;&gt;page-mod&lt;/a&gt;, 使用時機為&lt;code&gt;想要把讀回來的網頁, 再加以修改&lt;/code&gt;, 
例如&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把某網站的排版重新排一下, 例如台鐵的火車時刻表&lt;/li&gt;
&lt;li&gt;想把某些網站廣告區塊移除掉&lt;/li&gt;
&lt;li&gt;想把網頁中特定資訊給顯現出來, 例如某影音網站的影片下載連結&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就可以使用這個, 使用的方式如下&lt;/p&gt;
&lt;h1 id=&quot;page-mode-簡介&quot;&gt;&lt;a href=&quot;#page-mode-簡介&quot; class=&quot;headerlink&quot; title=&quot;page-mode 簡介&quot;&gt;&lt;/a&gt;page-mode 簡介&lt;/h1&gt;&lt;p&gt;官方給的範例如下  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var pageMod = require(&amp;quot;sdk/page-mod&amp;quot;);
pageMod.PageMod(&amp;#123;
    include: &amp;quot;*.mozilla.org&amp;quot;,
    contentScript: &amp;#39;window.alert(&amp;quot;Page matches ruleset&amp;quot;);&amp;#39;
&amp;#125;);&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Firefox extension" scheme="http://wwssllabcd.github.io/tags/Firefox-extension/"/>
    
  </entry>
  
  <entry>
    <title>打造一個 Firefox 附加元件</title>
    <link href="http://wwssllabcd.github.io/2014/05/03/building-an-extension-for-firefox/"/>
    <id>http://wwssllabcd.github.io/2014/05/03/building-an-extension-for-firefox/</id>
    <published>2014-05-02T17:32:00.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="開始之前"><a href="#開始之前" class="headerlink" title="開始之前"></a>開始之前</h1><p>以下會介紹 Mozilla 所推出的 Add-on SDK, 並且用它來打造你第一個 Firefox extension，要做的套件功能是利用 Add-on SDK 抓取匯率網站的資料，重新整理之後顯示出來  </p><p>首先先建立開發平台, 以下是需要的工具, 分別是 addon-sdk, python, firefox<img src="https://lh6.googleusercontent.com/-z0GbZ6KBNSA/VJexItwKtsI/AAAAAAAAsuM/2tHAspCDwrs/s0/Prerequisites.jpg" alt="Prerequisites"></p><ul><li><p>addon-sdk 請到 <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Installation">Mozilla 官網下載</a>, 下載完解壓縮後, 放在你喜歡的地方即可( 如 d:\project\addon-sdk)</p></li><li><p>除了 addon-sdk 外, 也需要 <a href="http://zh.wikipedia.org/zh-tw/Python">Python</a>, 由於我的平台是 windows, 所以就裝了 <a href="https://www.python.org/downloads/">Python for win</a>, 雖然有 <code>2.7.6</code>與 <code>3.4.0</code> 可以選擇, 不過mozilla 建議裝 2.7.X 的比較好, 安裝步驟就是下一步一直按下去, 沒難度.</p></li></ul><p>都安裝好了之後, 就使用<a href="http://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E5%AD%97%E5%85%83">命令提示字元</a>(以下簡稱 command line), 到 addon-sdk 下面接下來鍵入    bin\activate就會看到命令提示字元變得不太一樣了, 如下狀況<img src="https://lh4.googleusercontent.com/-zx2gUQKNiDA/VJexI1cktEI/AAAAAAAAsuI/Up_TR96b8Hw/s0/activate.jpg" alt="activate">  </p><p>這時候就是進入了 addon-sdk 開發模式, 不過這個動作在每一次關掉 command line 就要重複一次, 所以最好的做法還是把這一連串的啟動動作做成批次檔如下(我 addon-sdk 放在 d:\addon-sdk)</p><pre><code>d:cd\addon-sdkbin\activate</code></pre><a id="more"></a><h1 id="建立一個新的專案"><a href="#建立一個新的專案" class="headerlink" title="建立一個新的專案"></a>建立一個新的專案</h1><p>根據上一步, 啟動了addon-sdk 後, 在你想要的地方開始建立專案資料夾, 並且 initial 他</p><pre><code>mkdir my_addoncd my_addoncfx init</code></pre><p>執行起來大概長這樣<br><img src="https://lh6.googleusercontent.com/--JE6-Q96vNg/VJexJkW8erI/AAAAAAAAsuY/dHz8BMapgsM/s0/cfxInit.jpg" alt="cfxInit">  </p><h1 id="開始第一支程式-Hello-World"><a href="#開始第一支程式-Hello-World" class="headerlink" title="開始第一支程式 -- Hello World"></a>開始第一支程式 -- Hello World</h1><p>目錄中的 lib 的資料夾, 裡面有個 <code>main.js</code>, 則是套件的起點, 用編輯器打開, 鍵入以下程式碼</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var widgets &#x3D; require(&quot;sdk&#x2F;widget&quot;).Widget;</span><br><span class="line">myWedget &#x3D; widgets(&#123;</span><br><span class="line">id: &quot;I-am-wedget&quot;,</span><br><span class="line">label: &quot;wedget&quot;,</span><br><span class="line">content: &quot;Hello World!&quot;,</span><br><span class="line">tooltip: &quot;I-am-tooltip&quot;,</span><br><span class="line">width: 100</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>把<code>main.js</code>編碼選擇 UTF-8 後儲存關閉, 接下來就可以看看效果如何了<br>鍵入 </p><pre><code>cfx run</code></pre><p>之後就會跳出一個乾淨的 Firefox, 並且上面有你剛做的套件, 基本上 Wedget 算是顯示用的, 很簡單吧<img src="https://lh4.googleusercontent.com/-j8rzmz7qQeg/VJexKJ9PyhI/AAAAAAAAsug/oCEDsbIeVnU/s0/helloworld.jpg" alt="HelloWorld">  </p><h2 id="有關資源的存取"><a href="#有關資源的存取" class="headerlink" title="有關資源的存取"></a>有關資源的存取</h2><p>my_addon 目錄會出現數個資料夾, 如lib, data, doc, test 等, 其中 data 區對應到 code 裡面的 resource 的根目錄,如<code>./a.png</code>的意思就是代表存取 data 區裡面的 a.png 的意思，如果要用到外部的 JavaScript file ，也是放在 ./data中  </p><h2 id="放出-Message"><a href="#放出-Message" class="headerlink" title="放出 Message "></a>放出 Message </h2><p>使用 console.log 即可，如下所示  </p><pre><code>console.log(&quot;A= %D&quot;, 100)</code></pre><h1 id="實戰-製作一個抓取匯率的套件"><a href="#實戰-製作一個抓取匯率的套件" class="headerlink" title="實戰 -- 製作一個抓取匯率的套件"></a>實戰 -- 製作一個抓取匯率的套件</h1><h2 id="抓取某銀行網頁匯率的資料-使用-page-worker-取回網頁"><a href="#抓取某銀行網頁匯率的資料-使用-page-worker-取回網頁" class="headerlink" title="抓取某銀行網頁匯率的資料, 使用 page-worker 取回網頁"></a>抓取某銀行網頁匯率的資料, 使用 page-worker 取回網頁</h2><p>此時就要用 <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/page-worker">page-worker</a> 來幫你實現了, 延續剛剛的 Wedget, 這次我們來抓某個網頁的資料, 並且用 tooltip 的方式, 把它顯示在 Wedget 上面  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var widgets &#x3D; require(&quot;sdk&#x2F;widget&quot;).Widget;</span><br><span class="line">myWedget &#x3D; widgets(&#123;</span><br><span class="line">id: &quot;I-am-wedget&quot;,</span><br><span class="line">label: &quot;wedget&quot;,</span><br><span class="line">content: &quot;Hello World!&quot;,</span><br><span class="line">tooltip: &quot;I-am-tooltip&quot;,</span><br><span class="line">width: 100</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var pageWorkers &#x3D; require(&quot;sdk&#x2F;page-worker&quot;);</span><br><span class="line">var myWedget, myPW</span><br><span class="line">var script &#x3D; &quot;postMessage(document.body.innerHTML);&quot;;</span><br><span class="line">var targetURL &#x3D; &quot;http:&#x2F;&#x2F;rate.bot.com.tw&#x2F;Pages&#x2F;Static&#x2F;UIP003.zh-TW.htm&quot;;</span><br><span class="line"></span><br><span class="line">myPW &#x3D; pageWorkers.Page(&#123;</span><br><span class="line">contentURL: targetURL,</span><br><span class="line">contentScript: script,</span><br><span class="line">contentScriptWhen: &quot;ready&quot;,</span><br><span class="line">onMessage: function(message) &#123;</span><br><span class="line">myWedget.tooltip &#x3D; message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>這邊說明一下 PageWorkers 的屬性部分  </p><ul><li>contentURL: 代表的是要抓的 url</li><li>contentScript: 代表的是,抓回來要做什麼要的處理, 這邊我們只有把 document.body.innerHTML 藉由 postMessage 傳送出去</li><li>onMessage: 則負責接收 postMessage 丟出來的訊息, 也就是該網頁的 innerHTML 了, 並且把他設給 Wedget 的 tooltip </li></ul><p>我隨便選一個提供匯率的網頁, 並且把他設定給 targetURL, 他會把該網頁的 html, 顯示成為 Wedget 的 tooltip 上面, 原本把滑鼠移上去會顯示 <code>I-am-tooltip</code>, 現在已經變成亂七八糟的 html code 了, 如下所示<img src="https://lh5.googleusercontent.com/-QG7ut0HyUXo/VJexKX3oBrI/AAAAAAAAsuk/qIfCLqA8x50/s0/htmlCode.jpg" alt="htmlCode">  </p><h2 id="進一步的清理網頁資料"><a href="#進一步的清理網頁資料" class="headerlink" title="進一步的清理網頁資料"></a>進一步的清理網頁資料</h2><p>接下來就有點是 dirty work 了, 我們如果要把每個匯率的資料抓出來的話, 要怎做?<br>先觀察 html, 發現在匯率前面都會有串字串叫</p><pre><code>&quot;/Images/Flags/America.gif&quot;</code></pre><p>結束的字串都是為</p><pre><code>&quot;&lt;/td&gt;&lt;td class=&quot;</code></pre><p>我們利用這兩個字串當作識別項, 試看看能否把匯率的值給抓出來  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var findKeyWord &#x3D; function(keyWord, source, cellNo)</span><br><span class="line">&#123;</span><br><span class="line">var startWord &#x3D; &quot;&#x2F;Images&#x2F;Flags&#x2F;America.gif&quot;;</span><br><span class="line">var endWord &#x3D; &quot;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通常是Table的起始</span><br><span class="line">var startIdx &#x3D; source.indexOf(startWord);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從table的起點往後找KeyWord</span><br><span class="line">var keyWordIdx &#x3D; source.indexOf(keyWord,startIdx);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從keyword往後找結束符號</span><br><span class="line">var temp &#x3D; keyWordIdx;</span><br><span class="line">for(i&#x3D;0; i&lt;cellNo; i++)&#123;</span><br><span class="line">temp &#x3D; source.indexOf(endWord,temp)+1;</span><br><span class="line">&#125;</span><br><span class="line">endIdx &#x3D; temp-1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從EndIndex往前找，找&gt;關鍵字，但是要往前移一個</span><br><span class="line">var curIdx &#x3D; source.lastIndexOf(&quot;&gt;&quot;,endIdx)+1;</span><br><span class="line">return source.substring(curIdx,endIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>傳入要找的關鍵字(keyword), 資料來源(source), 還有要取第幾格的號碼(cellNo)來取出特定格數的資料出來, 貌似可以做到.  </p><p>再加點輔助程式吧, 現在只要呼叫 getResult 並且把 html 傳入的話, 就會得到完整的匯率表了  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">var getResult &#x3D; function(msg)&#123;</span><br><span class="line">var res &#x3D; &quot;&quot;;</span><br><span class="line">res +&#x3D; &quot;幣別： 現金買入 , 即期買入&quot;;</span><br><span class="line">res +&#x3D; getOneString(&quot;美金 ：&quot;, &quot;美金 (USD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;港幣 ：&quot;, &quot;港幣 (HKD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;英鎊 ：&quot;, &quot;英鎊 (GBP)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;澳幣 ：&quot;, &quot;澳幣 (AUD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;加拿大幣：&quot;, &quot;加拿大幣 (CAD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;新加坡幣：&quot;, &quot;新加坡幣 (SGD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;新加坡幣：&quot;, &quot;瑞士法朗 (CHF)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;日圓 ：&quot;, &quot;日圓 (JPY)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;南非幣 ：&quot;, &quot;南非幣 (ZAR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;瑞典幣 ：&quot;, &quot;瑞典幣 (SEK)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;紐元 ：&quot;, &quot;紐元 (NZD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;泰幣 ：&quot;, &quot;泰幣 (THB)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;菲國比索：&quot;, &quot;菲國比索 (PHP)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;印尼幣 ：&quot;, &quot;印尼幣 (IDR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;歐元 ：&quot;, &quot;歐元 (EUR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;韓元 ：&quot;, &quot;韓元 (KRW)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;越南盾 ：&quot;, &quot;越南盾 (VND)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;馬來幣 ：&quot;, &quot;馬來幣 (MYR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;人民幣 ：&quot;, &quot;人民幣 (CNY)&quot;, msg);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getOneString &#x3D; function(title, keyWord, html)&#123;</span><br><span class="line">var res_1, res_2;</span><br><span class="line">var res &#x3D; &quot;&quot;;</span><br><span class="line">res_1 &#x3D; findKeyWord(keyWord, html, 2);</span><br><span class="line">res_2 &#x3D; findKeyWord(keyWord, html, 4);</span><br><span class="line">res &#x3D; &quot;\n&quot; + title + res_1 + &quot;, &quot; + res_2;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var findKeyWord &#x3D; function(keyWord, source, cellNo)</span><br><span class="line">&#123;</span><br><span class="line">var startWord &#x3D; &quot;&#x2F;Images&#x2F;Flags&#x2F;America.gif&quot;;</span><br><span class="line">var endWord &#x3D; &quot;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通常是Table的起始</span><br><span class="line">var startIdx &#x3D; source.indexOf(startWord);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從table的起點往後找KeyWord</span><br><span class="line">var keyWordIdx &#x3D; source.indexOf(keyWord,startIdx);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從keyword往後找結束符號</span><br><span class="line">var temp &#x3D; keyWordIdx;</span><br><span class="line">for(i&#x3D;0; i&lt;cellNo; i++)&#123;</span><br><span class="line">temp &#x3D; source.indexOf(endWord,temp)+1;</span><br><span class="line">&#125;</span><br><span class="line">endIdx &#x3D; temp-1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從EndIndex往前找，找&gt;關鍵字，但是要往前移一個</span><br><span class="line">var curIdx &#x3D; source.lastIndexOf(&quot;&gt;&quot;,endIdx)+1;</span><br><span class="line">return source.substring(curIdx,endIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很髒很麻煩, 且一旦該網頁換掉格式就沒用了, 不是嗎?<br>我也沒辦法, 不推 API介接, 不推開放資料統一格式就是這樣麻煩, 先不提了.<br>現在我們只要在 pageWorkers 的 onMessage 加上 剛新作的 function -- getResult 就可以了   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onMessage: function(message) &#123;</span><br><span class="line">myWedget.tooltip &#x3D; getResult(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把所有東西組裝起來"><a href="#把所有東西組裝起來" class="headerlink" title="把所有東西組裝起來"></a>把所有東西組裝起來</h2><p>來看看效果吧, 很簡單吧<br><img src="https://lh6.googleusercontent.com/-XLs50aKm4qc/VJexK0N9uwI/AAAAAAAAsuw/YTqSzO1Pad0/s0/result.jpg" alt="result">  </p><p>我再把整個程式整理一下,大家可以參考  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">var widgets &#x3D; require(&quot;sdk&#x2F;widget&quot;).Widget;</span><br><span class="line">var pageWorkers &#x3D; require(&quot;sdk&#x2F;page-worker&quot;);</span><br><span class="line">var myWedget, myPW</span><br><span class="line"></span><br><span class="line">myWedget &#x3D; widgets(&#123;</span><br><span class="line">id: &quot;erw-wedget&quot;,</span><br><span class="line">label: &quot;erw&quot;,</span><br><span class="line">content: &quot;即時匯率&quot;,</span><br><span class="line">tooltip: &quot;wait ready&quot;,</span><br><span class="line">width: 50</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">var script &#x3D; &quot;postMessage(document.body.innerHTML);&quot;;</span><br><span class="line">var targetURL &#x3D; &quot;http:&#x2F;&#x2F;rate.bot.com.tw&#x2F;Pages&#x2F;Static&#x2F;UIP003.zh-TW.htm&quot;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">myPW &#x3D; pageWorkers.Page(&#123;</span><br><span class="line">contentURL: targetURL,</span><br><span class="line">contentScript: script,</span><br><span class="line">contentScriptWhen: &quot;ready&quot;,</span><br><span class="line">onMessage: function(message) &#123;</span><br><span class="line">myWedget.tooltip &#x3D; getResult(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var getResult &#x3D; function(msg)&#123;</span><br><span class="line">var res &#x3D; &quot;&quot;;</span><br><span class="line">res +&#x3D; &quot;幣別： 現金買入 , 即期買入&quot;;</span><br><span class="line">res +&#x3D; getOneString(&quot;美金 ：&quot;, &quot;美金 (USD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;港幣 ：&quot;, &quot;港幣 (HKD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;英鎊 ：&quot;, &quot;英鎊 (GBP)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;澳幣 ：&quot;, &quot;澳幣 (AUD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;加拿大幣：&quot;, &quot;加拿大幣 (CAD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;新加坡幣：&quot;, &quot;新加坡幣 (SGD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;新加坡幣：&quot;, &quot;瑞士法朗 (CHF)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;日圓 ：&quot;, &quot;日圓 (JPY)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;南非幣 ：&quot;, &quot;南非幣 (ZAR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;瑞典幣 ：&quot;, &quot;瑞典幣 (SEK)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;紐元 ：&quot;, &quot;紐元 (NZD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;泰幣 ：&quot;, &quot;泰幣 (THB)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;菲國比索：&quot;, &quot;菲國比索 (PHP)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;印尼幣 ：&quot;, &quot;印尼幣 (IDR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;歐元 ：&quot;, &quot;歐元 (EUR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;韓元 ：&quot;, &quot;韓元 (KRW)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;越南盾 ：&quot;, &quot;越南盾 (VND)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;馬來幣 ：&quot;, &quot;馬來幣 (MYR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;人民幣 ：&quot;, &quot;人民幣 (CNY)&quot;, msg);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getOneString &#x3D; function(title, keyWord, html)&#123;</span><br><span class="line">var res_1, res_2;</span><br><span class="line">var res &#x3D; &quot;&quot;;</span><br><span class="line">res_1 &#x3D; findKeyWord(keyWord, html, 2);</span><br><span class="line">res_2 &#x3D; findKeyWord(keyWord, html, 4);</span><br><span class="line">res &#x3D; &quot;\n&quot; + title + res_1 + &quot;, &quot; + res_2;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var findKeyWord &#x3D; function(keyWord, source, cellNo)&#123;</span><br><span class="line">var startWord &#x3D; &quot;&#x2F;Images&#x2F;Flags&#x2F;America.gif&quot;;</span><br><span class="line">var endWord &#x3D; &quot;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通常是Table的起始</span><br><span class="line">var startIdx &#x3D; source.indexOf(startWord);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從table的起點往後找KeyWord</span><br><span class="line">var keyWordIdx &#x3D; source.indexOf(keyWord,startIdx);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從keyword往後找結束符號</span><br><span class="line">var temp &#x3D; keyWordIdx;</span><br><span class="line">for(i&#x3D;0; i&lt;cellNo; i++)&#123;</span><br><span class="line">temp &#x3D; source.indexOf(endWord,temp)+1;</span><br><span class="line">&#125;</span><br><span class="line">endIdx &#x3D; temp-1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從EndIndex往前找，找&gt;關鍵字，但是要往前移一個</span><br><span class="line">var curIdx &#x3D; source.lastIndexOf(&quot;&gt;&quot;,endIdx)+1;</span><br><span class="line">return source.substring(curIdx,endIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>其實 Mozilla 也有出<a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Installation">官方教學</a>, 大家也可以參考看看</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;開始之前&quot;&gt;&lt;a href=&quot;#開始之前&quot; class=&quot;headerlink&quot; title=&quot;開始之前&quot;&gt;&lt;/a&gt;開始之前&lt;/h1&gt;&lt;p&gt;以下會介紹 Mozilla 所推出的 Add-on SDK, 並且用它來打造你第一個 Firefox extension，要做的套件功能是利用 Add-on SDK 抓取匯率網站的資料，重新整理之後顯示出來  &lt;/p&gt;
&lt;p&gt;首先先建立開發平台, 以下是需要的工具, 分別是 addon-sdk, python, firefox
&lt;img src=&quot;https://lh6.googleusercontent.com/-z0GbZ6KBNSA/VJexItwKtsI/AAAAAAAAsuM/2tHAspCDwrs/s0/Prerequisites.jpg&quot; alt=&quot;Prerequisites&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;addon-sdk 請到 &lt;a href=&quot;https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Installation&quot;&gt;Mozilla 官網下載&lt;/a&gt;, 
下載完解壓縮後, 放在你喜歡的地方即可( 如 d:\project\addon-sdk)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除了 addon-sdk 外, 也需要 &lt;a href=&quot;http://zh.wikipedia.org/zh-tw/Python&quot;&gt;Python&lt;/a&gt;, 由於我的平台是 windows, 所以就裝了 &lt;a href=&quot;https://www.python.org/downloads/&quot;&gt;Python for win&lt;/a&gt;, 
雖然有 &lt;code&gt;2.7.6&lt;/code&gt;與 &lt;code&gt;3.4.0&lt;/code&gt; 可以選擇, 不過mozilla 建議裝 2.7.X 的比較好, 安裝步驟就是下一步一直按下去, 沒難度.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;都安裝好了之後, 就使用&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E5%AD%97%E5%85%83&quot;&gt;命令提示字元&lt;/a&gt;(以下簡稱 command line), 到 addon-sdk 下面
接下來鍵入
    bin\activate
就會看到命令提示字元變得不太一樣了, 如下狀況
&lt;img src=&quot;https://lh4.googleusercontent.com/-zx2gUQKNiDA/VJexI1cktEI/AAAAAAAAsuI/Up_TR96b8Hw/s0/activate.jpg&quot; alt=&quot;activate&quot;&gt;  &lt;/p&gt;
&lt;p&gt;這時候就是進入了 addon-sdk 開發模式, 不過這個動作在每一次關掉 command line 就要重複一次, 所以最好的做法還是把這一連串的啟動動作做成批次檔如下(我 addon-sdk 放在 d:\addon-sdk)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;d:
cd\addon-sdk
bin\activate&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Firefox extension" scheme="http://wwssllabcd.github.io/tags/Firefox-extension/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry Pi 安裝 Archlinux</title>
    <link href="http://wwssllabcd.github.io/2013/11/14/how-to-install-archlinux-on-raspberrypi/"/>
    <id>http://wwssllabcd.github.io/2013/11/14/how-to-install-archlinux-on-raspberrypi/</id>
    <published>2013-11-14T11:48:00.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>簡短的紀錄一下 Raspberry pi 如何安裝 Archlinux，並且使用 pacman 安裝幾個套件  </p><p>一樣去下載頁面下載 arch linux OS 回來後，解壓縮可以得到 img 檔，安裝完後，開機，使用使用 pietty(talnet 軟體) 連線後登入，此時的安裝方式都與 wheezy 相同  </p><h1 id="更新-pacman"><a href="#更新-pacman" class="headerlink" title="更新 pacman"></a>更新 pacman</h1><p>要先更新 pacman ，否則某些套件會找不到</p><p>輸入以下指令</p><pre><code>pacman -Syypacman -Syu</code></pre><a id="more"></a><h1 id="安裝-transmission"><a href="#安裝-transmission" class="headerlink" title="安裝 transmission "></a>安裝 transmission </h1><p>使用 pacman 安裝，輸入</p><pre><code>pacman -S transmission-cli</code></pre><p>可參考<a href="https://wiki.archlinux.org/index.php/Transmission">archlinux 的 Transmission 安裝教學</a></p><p>安裝完後，先啟動, 讓他產生參數</p><pre><code>systemctl start transmission.service</code></pre><p>再停止，以便修改參數</p><pre><code>systemctl stop transmission.service</code></pre><p>檢查 status 是否正確停止</p><pre><code>systemctl status |grep transmission</code></pre><p>輸入</p><pre><code>transmission-daemon</code></pre><p>不知為何，要打入這個才會出現.config 的 folder</p><p>修改參數後重新啟動</p><pre><code>systemctl daemon-reloadsystemctl restart unit</code></pre><h1 id="安裝-samba"><a href="#安裝-samba" class="headerlink" title="安裝 samba "></a>安裝 samba </h1><p>使用 pacman 安裝套件</p><pre><code>pacman -S samba</code></pre><p>進入 <code>/etc/samba/</code>，把 <code>smb.conf.default</code> cp一份為 <code>smb.conf</code>，並且修改 <code>smb.conf</code>修改conf這邊不再贅述，若不懂的話，請參閱本站 samba 設定</p><p>跑不起來的話, 看看 samba 狀態</p><pre><code>systemctl status samba </code></pre><p>如果出現</p><pre><code>&gt; I disabled starting &quot;samba&quot; and enabled only smbd.service and nmbd.service.&gt; Now I can see Raspberry in my second computer, but I cant connect to it, &gt; it fails with &quot;you have no permission to connect&quot;</code></pre><p>代表你需要帳號密碼</p><p>samba 需要帳號密碼存取</p><pre><code>smbpasswd -a pi</code></pre><p>其中pi是要已經存在的帳號，這樣一來應該就可以成功啟動 samba </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;簡短的紀錄一下 Raspberry pi 如何安裝 Archlinux，並且使用 pacman 安裝幾個套件  &lt;/p&gt;
&lt;p&gt;一樣去下載頁面下載 arch linux OS 回來後，解壓縮可以得到 img 檔，
安裝完後，開機，使用使用 pietty(talnet 軟體) 連線後登入，此時的安裝方式都與 wheezy 相同  &lt;/p&gt;
&lt;h1 id=&quot;更新-pacman&quot;&gt;&lt;a href=&quot;#更新-pacman&quot; class=&quot;headerlink&quot; title=&quot;更新 pacman&quot;&gt;&lt;/a&gt;更新 pacman&lt;/h1&gt;&lt;p&gt;要先更新 pacman ，否則某些套件會找不到&lt;/p&gt;
&lt;p&gt;輸入以下指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pacman -Syy
pacman -Syu&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>Policy-Based Programming</title>
    <link href="http://wwssllabcd.github.io/2013/10/08/policy-based-template-programming/"/>
    <id>http://wwssllabcd.github.io/2013/10/08/policy-based-template-programming/</id>
    <published>2013-10-08T11:02:00.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>考慮以下的 code 是<code>找出vector&quot;中，相同的item出來，並放在另一個vector中</code>，但是有時後放入vector 的item是 native type( 如 int， char， 等)，有時卻是使用pair type，而這兩個 template 基本上只差在一個地方，就是取 addr 的部份，一個 native 版本是直接取，如<code>addr = (*iDBlock);</code> ，而 pair 版本是取他的 first 出來，如 <code>addr = (*iDBlock).first;</code></p><p>Native type 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt;bool flag, class T, class U&gt;</span><br><span class="line">static void findDupItem(vector&lt;T&gt;&amp; source, vector&lt;U&gt;&amp; dupColl)&#123;</span><br><span class="line">typename vector&lt;T&gt;::iterator iDBlock;</span><br><span class="line">dupColl.clear();</span><br><span class="line"></span><br><span class="line">T addr&#x3D;0;</span><br><span class="line"></span><br><span class="line">for(iDBlock &#x3D; source.begin(); iDBlock!&#x3D;source.end(); iDBlock++)&#123;</span><br><span class="line">addr &#x3D; (*iDBlock);</span><br><span class="line">if( _isHit( addr ) &#x3D;&#x3D; true )&#123;</span><br><span class="line">dupColl.push_back((*iDBlock));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pair 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class T, class U &gt;</span><br><span class="line">static void findDupItem(vector&lt; pair&lt;T, U&gt; &gt;&amp; source, vector&lt; pair&lt;T, U&gt; &gt;&amp; dupColl)&#123;</span><br><span class="line">typename vector&lt; pair&lt;T, U&gt;  &gt;::iterator iDBlock;</span><br><span class="line">dupColl.clear();</span><br><span class="line"></span><br><span class="line">T addr&#x3D;0;</span><br><span class="line">for(iDBlock &#x3D; source.begin(); iDBlock!&#x3D;source.end(); iDBlock++)&#123;</span><br><span class="line">addr &#x3D; (*iDBlock).first;</span><br><span class="line">if( _isHit( addr) &#x3D;&#x3D; true )&#123;</span><br><span class="line">dupColl.push_back((*iDBlock));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>基本上 99% 的東西都一樣，違反 DRY( Don&#39;t repeat yourself)原則，但那要如何把他合併起來呢？使用一個 flag 也許可以解決問題</p><pre><code>if ( isPairType )&#123;    addr = (*iDBlock).first;&#125;else&#123;    addr = (*iDBlock);&#125;</code></pre><p>這解法我們早就做過 N 遍了--   一個醜陋但堪用的解法<br>你我都知道，這個解法一旦複雜度變高可能會變得難以 maintain，接下來就是看誰倒楣</p><p>也許一個 function pointer 去包裝他可能是一個好方法，如</p><pre><code>static void findDupItem(vector&lt; pair&lt;T, U&gt; &gt;&amp; source, vector&lt; pair&lt;T, U&gt; &gt;&amp; dupColl, FP pFun )&#123;..略..for(iDBlock = source.begin(); iDBlock!=source.end(); iDBlock++)&#123;    addr = pFun(iDBlock);    ..略..&#125;</code></pre><p>嗯，是可以解，但沒有驚喜，有沒有一個更好的解法呢？</p><h1 id="Policy-Based-Programming"><a href="#Policy-Based-Programming" class="headerlink" title="Policy-Based Programming"></a>Policy-Based Programming</h1><p><a href="http://zh.wikipedia.org/zh-tw/%E5%9F%BA%E6%96%BC%E5%8E%9F%E5%89%87%E8%A8%AD%E8%A8%88">Policy-Based Class Design</a>首見於 Andrei Alexandrescu 出版的 《Modern C++ Design》一書，詳細的內容可以參考該書的第一章(見本篇後記)。     </p><ul><li><p>Interface design 的缺點<br>Interface design 不是不好， Interface design 有時也會出現力有未逮的情況，當軟體規模擴大到一定程度時，有時會很難避免出現某些 sub class 繼承 interface 時，不需要該 interface 的某些 constraints(約束條件)，對於實務上遇到這種況狀，通常會故意忽略掉那些參數(例如傳一個 Null 值進去)，好讓 compiler 可以順利編譯，這種語法有效，但語意無效的介面意味著 interface 出現過度設計的 bad smell。    </p></li><li><p>把每個功能切割成為小class<br>對於 interface 出現過度設計的狀況，縮小設計規模可能是一種解法，但是這種作法又會產生大量的設計組合，以 smart point 為例，你就會有一堆 class 如下   </p></li></ul><pre><code>SingleThreadSmartPtr  MultiThreadSmartPtr  RefCountSmartPtr   RefLinkSmartPrt  </code></pre><p>若增加一個選項則會面臨大量設計組合，複雜度曲線上升  </p><ul><li>利用多重繼承來處理設計組合？<br>若是利用繼承 BaseSmartPoint去組合SingleThread，RefCount 這些 class 所產生的 SmartPoint，的確是可以讓設計組合降低，但除非設計單純，否則大多數得小心繼承帶來的痛苦，特別是要去協調那些 class的運轉，就實務上來說繼承並不討喜。  </li></ul><p>繼承組合而來的 class 面對著型別又有著困擾，假設你使用一個 DeepCopy Class 來為你的 SmartPointer 實作 DeepCopy，但是 DeepCopy 是怎樣的介面呢？ 舉例來說，假設他要回傳某個東西，那回傳的 type 又是什麼？   </p><p>多重繼承本質上的確是一種<code>組合</code>，但似乎沒有辦法單獨的解決這種問題，特別是 user 在設計時，面對型別的多樣性。   </p><ul><li>Template 帶來曙光<br>哪裡型別最多？就是 Template，那裡擁有大量的型別，而這兩種設計並不衝突，有時還相輔相成，比較一下多重繼承與 template，例如 多重繼承 往往缺乏型別，而 temaplte 擁有大量型別。   </li></ul><p>而且一個良好的設計應該在編譯時期強制表現出大部分的 constraints (約束條件)，而 Template 剛好可以在 compile time 表現出 constraints 的機制。   </p><p>用多重繼承 + template 來實現有機會產生非常彈性的裝置來當作我們的設計元素。</p><h1 id="實作-Policy-Classes-Design"><a href="#實作-Policy-Classes-Design" class="headerlink" title="實作 Policy Classes Design"></a>實作 Policy Classes Design</h1><p>根據上述的解釋，修改 code 如下  </p><p>先把 GetItem使用 Policy class 封裝起來，由於我們不知道他的 ReturnType 與 Collection 的 Iterator 是什麼，反正缺 Type 就往 Template 那邊找就對了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt; typename Iter, class RT &gt;</span><br><span class="line">struct GetNornalData&#123;</span><br><span class="line">static RT getItem(Iter iter)&#123;</span><br><span class="line">return (*iter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt; typename Iter, class RT &gt;</span><br><span class="line">struct GetPair_first&#123;</span><br><span class="line">static RT getItem(Iter iter)&#123;</span><br><span class="line">return (*iter).first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以 vector<int> 來說，這邊的 ReturnType 就是 Int， 而 iter 就是 Vector<int>::iterator 了，有了policy，接下來就可以改寫 main function 了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class T, class ReturnType, class GetDataPolicy &gt;</span><br><span class="line">class FindDpu : public GetDataPolicy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">static void run(vector&lt;T&gt;&amp; source, vector&lt;T&gt;&amp; duplicateColl)&#123;</span><br><span class="line">typedef vector&lt;T&gt;::iterator Iter;</span><br><span class="line"></span><br><span class="line">Iter iter;</span><br><span class="line">ReturnType addr&#x3D;0;</span><br><span class="line"></span><br><span class="line">...略...</span><br><span class="line"></span><br><span class="line">for(iter &#x3D; source.begin(); iter!&#x3D;source.end(); iter++)&#123;</span><br><span class="line">addr &#x3D; getItem(iter); &#x2F;&#x2F; 利用繼承而獲得的 function</span><br><span class="line">...略...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用的時候如下，先宣告你要那個 Policy，再利用 Policy 去產生哪種 FindDpu class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; source, target;</span><br><span class="line">typedef GetNornalData&lt; vector&lt;int&gt;::iterator, int &gt; Policy;</span><br><span class="line"></span><br><span class="line">FindDpu&lt; int, int, Policy &gt;  fvpd_int;</span><br><span class="line">fvpd_int.run(source, target);</span><br></pre></td></tr></table></figure><p>如果是 pair 的時候，可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;char, char&gt; MyPairType;</span><br><span class="line"></span><br><span class="line">vector&lt;MyPairType&gt; source, target;</span><br><span class="line">typedef GetPair_first&lt; vector&lt;MyPairType&gt;::iterator, MyPairType::first_type &gt; Policy;</span><br><span class="line"></span><br><span class="line">FindDpu&lt; MyPairType, char, Policy &gt; fvpd_pair;</span><br><span class="line">fvpd_pair.run(source, target);</span><br></pre></td></tr></table></figure><h1 id="一點也不美麗的呼叫方式"><a href="#一點也不美麗的呼叫方式" class="headerlink" title="一點也不美麗的呼叫方式"></a>一點也不美麗的呼叫方式</h1><p>的確是使用了 Policy，但使用上前置作業要好幾行，在使用之前先宣告想要的 Policy，呼叫的時候傳入Policy ，這似乎合情合理，但使用 pair 的時候傳入 pair policy，使用int的時候傳入 int Policy 又顯得多餘又危險 -- 我總不可能使用 vector &lt; pair &gt; 傳入 int Policy 吧？</p><h1 id="模版偏特化-partial-specialization"><a href="#模版偏特化-partial-specialization" class="headerlink" title="模版偏特化( partial specialization )"></a>模版偏特化( partial specialization )</h1><p>能不能看到我傳 pair 的時候就預設 pair Policy 呢？翻了一下書，利用模版偏特化( partial specialization )也許有機會</p><p>可以看以下例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">Class Test;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">Class Test&lt;char&gt;&#123;</span><br><span class="line">typedef char ReturnType;</span><br><span class="line">string show()&#123;</span><br><span class="line">pringf(&quot;ReturnType &#x3D; char&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">Class Test&lt;int&gt;&#123;</span><br><span class="line">typedef int ReturnType;</span><br><span class="line">string show()&#123;</span><br><span class="line">pringf(&quot;ReturnType &#x3D; int&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時如果使用</p><pre><code>Test&lt;char&gt; t;t.show()</code></pre><p>則會顯示</p><pre><code>`ReturnType = char`</code></pre><p>compiler 藉由型別推導選擇了不同的 class，看來我們有機會藉由輸入不同的 Type，而去選擇不同的 Class </p><h1 id="重新打造-Policy-Class"><a href="#重新打造-Policy-Class" class="headerlink" title="重新打造 Policy Class"></a>重新打造 Policy Class</h1><p>根據我們傳入的 T，利用 compiler 型別推導機制，來幫 Policy 作偏特化，藉以自動選擇哪種 Policy，重新設計 Policy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename RT &gt; </span><br><span class="line">struct GetDataPolicy;</span><br><span class="line"></span><br><span class="line">template&lt; typename RT&gt; </span><br><span class="line">struct GetDataPolicy &lt; std::vector&lt; RT &gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">...略...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt; typename RT, typename U &gt; </span><br><span class="line">struct GetDataPolicy &lt; std::vector&lt; std::pair&lt;RT, U&gt; &gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">...略...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這樣一來，只有 <code>T = pair&lt;RT, U&gt;</code> 的時候，compiler 會自動推導 pair Policy 為最佳解，其餘的都是 vector&lt; RT &gt; 解，而且是符合最佳解的才會被編譯出來，也就是說，沒用到的 compiler 根本就不會編譯他  </p><p>回到主程式來，先利用預設模版，然後拿 T 當作 Policy 的參數，而 compiler 會拿 T 去 Policy 作型別推導找出最佳解出來  </p><pre><code>template&lt; class T, class ReturnType, class GetDataPolicy&lt;T&gt; &gt;class FindDuplicateItem : public Policy&#123;    ...略...&#125;</code></pre><h1 id="拿掉多餘的-template-parameter-使用-Traits"><a href="#拿掉多餘的-template-parameter-使用-Traits" class="headerlink" title="拿掉多餘的 template parameter -- 使用 Traits"></a>拿掉多餘的 template parameter -- 使用 Traits</h1><p>觀察 main function 中的 ReturnType</p><pre><code>template&lt; class T, class ReturnType, class GetDataPolicy&lt;T&gt; &gt;class FindDuplicateItem : public Policy&#123;    ...略...&#125;</code></pre><p>基本上 ReturnType 也是一開始就知道的資訊，若使用偏特化的機制，也是讓我們有機會拿掉他，檢視一下整個程式可能會需要用到的 Type  </p><ul><li>getItem 所用到的 ReturnType</li><li>用以作for 迴圈的 vector<T>::iterator</li></ul><p>只要在 Policy 中重新定義就好</p><pre><code>template&lt; typename RT&gt; struct GetDataPolicy &lt; std::vector&lt; RT &gt; &gt;    &#123;    typedef typename RT ReturnType;    typedef typename std::vector&lt; RT &gt;::iterator CollItor;    ...略...&#125;;</code></pre><p>甚至可以建立一個專門作 Trais 的 template，這樣一來所需要的資訊都在 Traits 裡面了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt; typename Return_Type, typename Colls_Iter  &gt; </span><br><span class="line">struct GetDataPolicyTraits</span><br><span class="line">&#123;</span><br><span class="line">typedef typename Return_Type  ReturnType;</span><br><span class="line">typedef typename Colls_Iter   CollsIter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt; typename RT&gt; </span><br><span class="line">struct GetDataPolicy &lt; std::vector&lt; RT &gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">typedef GetDataPolicyTraits&lt;RT, typename std::vector&lt;RT&gt;::iterator&gt; Traits;</span><br><span class="line">typename Traits::ReturnType getItem(typename Traits::CollsIter iter)&#123;</span><br><span class="line">return (*iter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 main function 中，使用的時候像這樣</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt; typename T, typename Policy &#x3D; GetDataPolicy&lt;T&gt; &gt;</span><br><span class="line">class FindDuplicateItem : public Policy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void run(T&amp; source, T&amp; duplicateColl)&#123;</span><br><span class="line">Policy::Traits::CollsIter  iter;</span><br><span class="line">Policy::Traits::ReturnType addr&#x3D;0;</span><br><span class="line">...略...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有趣的是，明明 main function 傳入的是一個被泛化的 Type T，居然可以取出<code>std::vector&lt; RT &gt;</code> 或是<code>std::vector&lt; std::pair&lt;RT, U&gt; &gt;</code>的 ReturnType 與 Iterator</p><p>Traits 是一種<code>把T丟進去某個特徵萃取機制中，取出特定特徵</code>的技巧，當然不僅僅只是定義 type 而已，參考以下程式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class TypeTraits</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">template &lt;class U&gt; struct PointerTraits</span><br><span class="line">&#123;</span><br><span class="line">enum &#123; result &#x3D; false &#125;;</span><br><span class="line">typedef NullType PointeeType;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;class U&gt; struct PointerTraits&lt;U*&gt;</span><br><span class="line">&#123;</span><br><span class="line">enum &#123; result &#x3D; true &#125;;</span><br><span class="line">typedef U PointeeType;</span><br><span class="line">&#125;;</span><br><span class="line">public:</span><br><span class="line">enum &#123; isPointer &#x3D; PointerTraits&lt;T&gt;::result &#125;;</span><br><span class="line">typedef PointerTraits&lt;T&gt;::PointeeType PointeeType;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>現在我們可以來猜看看，vector<int>::iterator 是不是int 的 pointer ?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const bool iterIsPtr &#x3D; TypeTraits&lt; vector&lt;int&gt;::iterator &gt;::isPointer;</span><br><span class="line">cout &lt;&lt; &quot;vector&lt;int&gt;::iterator is &quot; &lt;&lt; iterIsPtr ? &quot;fast&quot; : &quot;smart&quot; &lt;&lt; &#39;\n&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="把一切組裝起來"><a href="#把一切組裝起來" class="headerlink" title="把一切組裝起來"></a>把一切組裝起來</h1><p>藉由 Traits 把缺的 main function 中的 Type 給補足</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">template&lt; typename Return_Type, typename Colls_Iter  &gt; </span><br><span class="line">struct GetDataPolicyTraits</span><br><span class="line">&#123;</span><br><span class="line">typedef typename Return_Type  ReturnType;</span><br><span class="line">typedef typename Colls_Iter   CollsIter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename RT &gt; </span><br><span class="line">struct GetDataPolicy;</span><br><span class="line"></span><br><span class="line">template&lt; typename RT&gt; </span><br><span class="line">struct GetDataPolicy &lt; std::vector&lt; RT &gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">typedef GetDataPolicyTraits&lt;RT, typename std::vector&lt;RT&gt;::iterator&gt; Traits;</span><br><span class="line">typename Traits::ReturnType getItem(typename Traits::CollsIter iter)&#123;</span><br><span class="line">return (*iter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt; typename RT, typename U &gt; </span><br><span class="line">struct GetDataPolicy &lt; std::vector&lt; std::pair&lt;RT, U&gt; &gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">typedef GetDataPolicyTraits&lt; RT, typename std::vector&lt; std::pair&lt;RT, U&gt; &gt;::iterator &gt; Traits;</span><br><span class="line">typename Traits::ReturnType getItem(typename Traits::CollsIter iter)&#123;</span><br><span class="line">return (*iter).first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt; typename T, typename Policy &#x3D; GetDataPolicy&lt;T&gt; &gt;</span><br><span class="line">class FindDuplicateItem : public Policy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void run(T&amp; source, T&amp; duplicateColl)&#123;</span><br><span class="line">Policy::Traits::CollsIter  iter;</span><br><span class="line">Policy::Traits::ReturnType addr&#x3D;0;</span><br><span class="line"></span><br><span class="line">duplicateColl.clear();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;let sorting time approach to Big(1) by bitMap</span><br><span class="line">const size_t MAP_SIZE &#x3D; 0x80000;</span><br><span class="line">BYTE map[MAP_SIZE]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">for(iter &#x3D; source.begin(); iter!&#x3D;source.end(); iter++)&#123;</span><br><span class="line">addr &#x3D; this-&gt;getItem(iter);</span><br><span class="line">if( _isHit( addr, map, MAP_SIZE) &#x3D;&#x3D; true )&#123;</span><br><span class="line">duplicateColl.push_back((*iter));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">bool _isHit(ULONG value, BYTE* pMap, size_t mapSize)&#123;</span><br><span class="line"></span><br><span class="line">if( value &gt;&#x3D;mapSize)&#123;</span><br><span class="line">throw MyException(UTI_PARAM_ERROR, &quot;value&gt;&#x3D;mapSize&quot;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool result &#x3D; true;</span><br><span class="line">if( pMap[ value ] &#x3D;&#x3D;0)&#123;</span><br><span class="line">pMap[ value ] &#x3D;1;</span><br><span class="line">result &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>呼叫的時候，也只要傳入最低限度的type即可</p><pre><code>vector&lt;int&gt; source, target;FindDuplicateItem&lt; vector&lt;int&gt; &gt; fvpd;fvpd.run(source, target);</code></pre><p>這邊沒有選擇使用<code>template template parameter</code>的方式去作，是因為我希望可以在源頭就直接抽換掉 Policy Class 而不受到 &lt; T &gt; 的影響。</p><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>其實對於軟體工程而言，完成一件事情可以用很多種不同的作法，而且解法似乎一樣好，但是也許就是選擇太多，導致沒經驗的工程師選擇了對未來有 side effect 的方案，導致專案越來越難進行，這只是一個簡單的 template ，幹嘛搞的那麼複雜，主要的還是觀念上的改變 -- 使用 if else 與使用 Policy 的區別， </p><p>以下兩個 link 對於 Policy-Based Class Design 我覺得寫的很好，版主很用心再寫，可以參考看看  </p><ul><li><a href="http://blog.monkeypotion.net/gameprog/beginner/exploring-the-field-of-policy-based-class-design">探索Policy-Based Class Design新視界</a>  </li><li><a href="http://blog.monkeypotion.net/gameprog/advanced/diving-into-policy-based-class-design">深入Policy-Based Class Design新大陸</a>  </li></ul><p>本篇很多案例是參考 <a href="http://jjhou.boolan.com/jjtbooks-modern-cpp-design.htm">Modern C++ Design</a>，及 <a href="http://shopping.pchome.com.tw/?mod=item&func=exhibit&IT_NO=DJAR0F-A16046100">C++ template 全覽</a>，</p><p>而 Policy-based programming 在 Modern C++ Design 的 ch1 有詳細的介紹，棒的是，侯傑有 <a href="http://jjhou.boolan.com/jjtbooks-modern-cpp-design.htm">ch1~ch4 的預覽版本可供下載</a>(真的是佛心來著)，有興趣的朋友可以參考看看</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;考慮以下的 code 是&lt;code&gt;找出vector&amp;quot;中，相同的item出來，並放在另一個vector中&lt;/code&gt;，
但是有時後放入vector 的item是 native type( 如 int， char， 等)，有時卻是使用pair type，
而這兩個 template 基本上只差在一個地方，就是取 addr 的部份，
一個 native 版本是直接取，如&lt;code&gt;addr = (*iDBlock);&lt;/code&gt; ，而 pair 版本是取他的 first 出來，如 &lt;code&gt;addr = (*iDBlock).first;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Native type 版本&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;template&amp;lt;bool flag, class T, class U&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static void findDupItem(vector&amp;lt;T&amp;gt;&amp;amp; source, vector&amp;lt;U&amp;gt;&amp;amp; dupColl)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	typename vector&amp;lt;T&amp;gt;::iterator iDBlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dupColl.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	T addr&amp;#x3D;0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for(iDBlock &amp;#x3D; source.begin(); iDBlock!&amp;#x3D;source.end(); iDBlock++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		addr &amp;#x3D; (*iDBlock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if( _isHit( addr ) &amp;#x3D;&amp;#x3D; true )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			dupColl.push_back((*iDBlock));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Pair 版本&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;template&amp;lt; class T, class U &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static void findDupItem(vector&amp;lt; pair&amp;lt;T, U&amp;gt; &amp;gt;&amp;amp; source, vector&amp;lt; pair&amp;lt;T, U&amp;gt; &amp;gt;&amp;amp; dupColl)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	typename vector&amp;lt; pair&amp;lt;T, U&amp;gt;  &amp;gt;::iterator iDBlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dupColl.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	T addr&amp;#x3D;0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for(iDBlock &amp;#x3D; source.begin(); iDBlock!&amp;#x3D;source.end(); iDBlock++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		addr &amp;#x3D; (*iDBlock).first;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if( _isHit( addr) &amp;#x3D;&amp;#x3D; true )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			dupColl.push_back((*iDBlock));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://wwssllabcd.github.io/tags/C/"/>
    
    <category term="Modern C++ Design" scheme="http://wwssllabcd.github.io/tags/Modern-C-Design/"/>
    
  </entry>
  
  <entry>
    <title>讓 Raspberry pi 變成多媒體播放機 -- 安裝Raspbmc</title>
    <link href="http://wwssllabcd.github.io/2013/04/22/how-to-setup-raspbmc-in-raspberry-pi/"/>
    <id>http://wwssllabcd.github.io/2013/04/22/how-to-setup-raspbmc-in-raspberry-pi/</id>
    <published>2013-04-22T08:26:00.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>RPi可以透過安裝 XBMC，讓自己可以變成類似 <a href="http://www.himedia-tech.cn/">海美迪(Himedia)</a> 那種高清播放機的功能，也有插件可以看PPS等網路電視，不過他不像 transmission、samba等 service 只要裝套件就好了，必須要安裝他們的OS image，所以比較常見的方法是再拿一張SD卡專門使用</p><h1 id="安裝-RaspBMC"><a href="#安裝-RaspBMC" class="headerlink" title="安裝 RaspBMC"></a>安裝 RaspBMC</h1><h2 id="下載與安裝"><a href="#下載與安裝" class="headerlink" title="下載與安裝"></a>下載與安裝</h2><p>到<a href="http://www.raspbmc.com/">Raspbmc</a>網站下載image，下載有兩種方式  </p><ul><li>一種是下載16mb大小的前導，安裝完後，他會自己下載剩下的程式安裝  </li><li>Standalone Image 是下載完整的離線安裝檔  </li></ul><p>我推薦下載<a href="http://download.raspbmc.com/downloads/bin/filesystem/prebuilt/raspbmc-final.img.gz">Standalone Image</a>，因為有時後用前導的方式會下載很久，Standalone Image的檔案下載回來後解壓縮，會得到一個img file，安裝的方式就跟官方OS一樣，使用<a href="https://launchpad.net/win32-image-writer/+download">Win32DiskImager</a>寫入即可</p><p>寫入完成後，插上RPI並接上網路，等個10min，就差不多安裝好了，基本上安裝不會有什麼大問題，順利的話，就會直接進入到 XBMC 的畫面。</p><a id="more"></a><h2 id="HDMI-設定問題"><a href="#HDMI-設定問題" class="headerlink" title="HDMI 設定問題"></a>HDMI 設定問題</h2><p>若你的顯示器比較新可能就不會有問題，若是比較舊的就有可能無法正常顯示，  </p><p>有時候顯示裝置老舊， 就必須要特別設定hdmi參數，首先找到 SD 卡根目錄下面的<code>config.txt</code>，打開來， 開始設定參數(若找不到該參數， 則自己加上去即可)設定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sdtv_mode &#x3D; 0</span><br><span class="line">sdtv_aspect &#x3D; 3</span><br><span class="line">hdmi_group &#x3D; 1</span><br><span class="line">hdmi_mode &#x3D; 1</span><br></pre></td></tr></table></figure><p>sdtv_aspect 代表你的螢幕比例，定義如下</p><pre><code>sdtv_aspect=1  4:3sdtv_aspect=2  14:9sdtv_aspect=3  16:9</code></pre><p>hdmi_group=1 及 hdmi_mode=1 是代表使用 CEA + VGA 模式， 通常設定完 HDMI 會以最低標準顯示，這兩個參數模式的組合在<a href="http://elinux.org/RPi_config.txt#Video_mode_options">RPi_config.txt Video_mode_options)</a>有列出來，這裡不再解釋</p><p>接下來你可以讓 RPI抓你的螢幕有哪些模式可以選，輸入以下指令</p><pre><code>/opt/vc/bin/tvservice -d edid.dat/opt/vc/bin/edidparser edid.dat</code></pre><p>edidparser 會列出建議的組合，照著設定就可以了</p><h1 id="登入-Raspbmc"><a href="#登入-Raspbmc" class="headerlink" title="登入 Raspbmc"></a>登入 Raspbmc</h1><h2 id="遠端控制-Raspbmc"><a href="#遠端控制-Raspbmc" class="headerlink" title="遠端控制 Raspbmc"></a>遠端控制 Raspbmc</h2><p>當你順利的進入到主畫面，除了利用滑鼠鍵盤操作外，XBMC 也提供方便的遠端控制，只要在瀏覽器上面，輸入Raspbmc的 ip 即可，如 <a href="http://192.168.0.20/">http://192.168.0.20/</a>  ，就可以用網頁的方式遙控 XBMC，也可以用手機遙控 XBMC，裝一個叫XBMC remote 的軟體即可</p><h2 id="改成中文選單"><a href="#改成中文選單" class="headerlink" title="改成中文選單"></a>改成中文選單</h2><p>切換成中文前，要先選擇字體，因為預設的字體不能顯示中文，在<code>system/ settings/ appearance/ skin / fonts</code>，選擇 <code>arial based</code> 即可，這樣在英文界面下也可看到中文字</p><p>接著切換成中文選單，選取 <code>system/ settings/ appearance/ international/ language</code> 後，選擇 <code>Chinese Traditional</code> 即可</p><h2 id="校正螢幕"><a href="#校正螢幕" class="headerlink" title="校正螢幕"></a>校正螢幕</h2><p>若你的螢幕顯示不太正確，像是歪掉，上下左右沒對齊的可以在 <code>系統/ 視訊輸出/ 視訊校正</code> 這邊做出校正，選取之後，他可以讓你手動拉拉右上角與左下的，以調整視訊的範圍  </p><p>我的心得是，先拉左上角與右下角，先把它拉小，可以先看出整個畫面是長怎樣的之後， 再去做調整，中間的部分是拉一個正方形出來，正下方的部分是拉字幕的高度</p><h2 id="新增播放影片"><a href="#新增播放影片" class="headerlink" title="新增播放影片"></a>新增播放影片</h2><p>這邊以 window 8 的共享資料夾內的影片來當作例子，首先你必須先建立好共享資料夾(這不再贅述)，在<code>新增視訊來源</code>的介面上， 選瀏覽後，選擇<code>window網路 (SMB)</code>，找到你 share 的網路與 folder 後， 看一下下方是否有顯示<code>smb://MyPC/ShareFD/</code>，如果有，就按下確定鍵( 代表你選擇這個目錄)，接著你會回到<code>新增視訊來源</code>那邊，再按下&quot;確定&quot;就可以了</p><p>注意:  </p><pre><code>windows 8 即使在共享資料夾那邊選擇存取帳號為 everyone 時，也是需要帳號密碼，若是不想要輸入網路資料夾的密碼的話，則必須要關閉 windows 8 分享資料夾密碼保護的功能，若要以 window 8 的檔案撥放的話，要關掉共用密碼保護設定  </code></pre><p><code>選擇網路和網際網路/網路和共用中心/變更進階共用設定/所有網路</code>在<code>以密碼保護的共用</code>項目下，勾選<code>關閉以密碼保護的共用</code>，按<code>儲存變更</code>。這樣分享的資料夾就可以使用 everyone 而不用輸入密碼了</p><h2 id="安裝PPS等插件"><a href="#安裝PPS等插件" class="headerlink" title="安裝PPS等插件"></a>安裝PPS等插件</h2><p>使用 terminal 登入後，使用 wget 下載<a href="https://code.google.com/p/xbmc-addons-chinese/">XBMC媒體中心的中文擴展功能腳本</a>回來後，到設定那邊安裝即可</p><h2 id="修改遠端密碼"><a href="#修改遠端密碼" class="headerlink" title="修改遠端密碼"></a>修改遠端密碼</h2><p>建議還是用 terminal 登入進去改一下帳號密碼就是了遠端的帳號密碼預設還是 pi/ raspberry，第一次登入會強制執行語言與地區的設定，就跟 RPI設定一樣，選 <code>en_us.utf8</code> 與 <code>zh_tw.utf8</code> 即可，預設為 <code>en_us.utf8</code>，設定好之後，回到 terminal 畫面後再輸入 <code>sudo passwd</code> ，改變登入的密碼</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://learning.wingsv.org/raspberry-pi-%E7%B0%A1%E6%98%93%E5%AE%89%E8%A3%9D-xbmc/">Raspberry Pi 簡易安裝 XBMC</a><br><a href="https://vistb.net/2012/12/raspberrypi-tour-use-raspbmc-build-htpc/">Raspberry Pi 使用手記 -- 簡介及利用Raspbmc搭建媒體播放器</a><br><a href="http://blog.sina.com.cn/s/blog_6ab7ecff0101afot.html">Raspberry Pi的HDMI輸出問題解法</a><br><a href="http://elinux.org/RPi_config.txt#Video_mode_options">RPiconfig</a><br><a href="https://code.google.com/p/xbmc-addons-chinese/">XBMC媒體中心的中文擴展功能腳本</a><br><a href="http://support2.microsoft.com/kb/2702421/zh-tw">如何解決連接至已經設定允許 Everyone 讀取的共用資料夾時，仍出現詢問帳號密碼對話視窗</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RPi可以透過安裝 XBMC，讓自己可以變成類似 &lt;a href=&quot;http://www.himedia-tech.cn/&quot;&gt;海美迪(Himedia)&lt;/a&gt; 那種高清播放機的功能，也有插件可以看PPS等網路電視，
不過他不像 transmission、samba等 service 只要裝套件就好了，必須要安裝他們的OS image，所以比較常見的方法是再拿一張SD卡專門使用&lt;/p&gt;
&lt;h1 id=&quot;安裝-RaspBMC&quot;&gt;&lt;a href=&quot;#安裝-RaspBMC&quot; class=&quot;headerlink&quot; title=&quot;安裝 RaspBMC&quot;&gt;&lt;/a&gt;安裝 RaspBMC&lt;/h1&gt;&lt;h2 id=&quot;下載與安裝&quot;&gt;&lt;a href=&quot;#下載與安裝&quot; class=&quot;headerlink&quot; title=&quot;下載與安裝&quot;&gt;&lt;/a&gt;下載與安裝&lt;/h2&gt;&lt;p&gt;到&lt;a href=&quot;http://www.raspbmc.com/&quot;&gt;Raspbmc&lt;/a&gt;網站下載image，下載有兩種方式  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一種是下載16mb大小的前導，安裝完後，他會自己下載剩下的程式安裝  &lt;/li&gt;
&lt;li&gt;Standalone Image 是下載完整的離線安裝檔  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我推薦下載&lt;a href=&quot;http://download.raspbmc.com/downloads/bin/filesystem/prebuilt/raspbmc-final.img.gz&quot;&gt;Standalone Image&lt;/a&gt;，因為有時後用前導的方式會下載很久，
Standalone Image的檔案下載回來後解壓縮，會得到一個img file，安裝的方式就跟官方OS一樣，使用&lt;a href=&quot;https://launchpad.net/win32-image-writer/+download&quot;&gt;Win32DiskImager&lt;/a&gt;寫入即可&lt;/p&gt;
&lt;p&gt;寫入完成後，插上RPI並接上網路，等個10min，就差不多安裝好了，基本上安裝不會有什麼大問題，順利的話，就會直接進入到 XBMC 的畫面。&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry pi: 設定無線網路</title>
    <link href="http://wwssllabcd.github.io/2013/04/22/how-to-setup-wireless-in-raspberry-pi/"/>
    <id>http://wwssllabcd.github.io/2013/04/22/how-to-setup-wireless-in-raspberry-pi/</id>
    <published>2013-04-22T08:21:00.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安裝-wireless-usb"><a href="#安裝-wireless-usb" class="headerlink" title="安裝 wireless usb "></a>安裝 wireless usb </h2><p>經過我的實驗，UsbHub 對於無線傳輸會不會當機佔了很大的因素，我之前使用 D-link Dub H7 用samba拉檔案，約 5min 後就會當機，起初還以為RPi本身的問題，後來換了Belkin F5U237之後，試了兩張網卡( SMC-usb-wireless-G，TL-821Nv3)都沒有問題。</p><p>最好是買有內建驅動不用再折騰的如 EW-7811Un、TL-821Nv3 等，你也可以在<a href="http://elinux.org/RPi_VerifiedPeripherals#USB_Wi-Fi_Adapters">Wifi硬體清單</a>中選一張。  </p><a id="more"></a><h1 id="安裝驅動程式"><a href="#安裝驅動程式" class="headerlink" title="安裝驅動程式  "></a>安裝驅動程式  </h1><p>接下來進入主題，安裝驅動程式<br>先把usb插上去之後，輸入<code>lsusb</code>，查看看型號為何，我這邊是以 SMC-usb-wireless-G 為例子，所以這邊查到的是 zd1211rw  </p><p>使用apt裝驅動程式</p><pre><code>sudo apt-get update</code></pre><p>使用 apt-cache來查看有哪些驅動</p><pre><code>apt-cache search zd1211</code></pre><p>顯示</p><pre><code>zd1211-firmware - Firmware images for the zd1211rw wireless driver</code></pre><p>所以這邊知道要安裝 zd1211-firmware</p><pre><code>sudo apt-get install zd1211-firmware</code></pre><p>使用<code>lsmod</code>，查看看 zd1211有沒有被載入，</p><pre><code>使用`ifconfig`，看看wlan0有沒有起來</code></pre><p>呼叫wlan0掃瞄附近的 AP</p><pre><code>sudo iwlist wlan0 scan</code></pre><p>或是</p><pre><code>sudo iwlist wlan0 scan | grep SSID</code></pre><p>如果有掃瞄到，代表有正確的驅動起來，現在連上無線 AP</p><p>安裝 wpa client 驅動，預設已經安裝，若沒有可以輸入以下指令</p><pre><code>sudo apt-get install wpasupplicant</code></pre><p>編輯 interfaces </p><pre><code>sudo nano /etc/network/interfaces</code></pre><p>加入以下設定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line">allow-hotplug wlan0</span><br><span class="line">iface wlan0 inet dhcp #使用dhcp配置</span><br><span class="line"></span><br><span class="line">#wpa-roam &#x2F;etc&#x2F;wpa_supplicant&#x2F;wpa_supplicant.conf</span><br><span class="line">#iface default inet dhcp</span><br><span class="line"></span><br><span class="line">#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; new setting &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#auto eth0  #如果 eth0 抓不到的話， 可以試著把它打開</span><br><span class="line">#auto wlan0 #自動開啟wlan0</span><br><span class="line">wpa-conf &#x2F;etc&#x2F;wpa.conf  # wpa 檔案放在此</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>新增 wpa.conf 檔</p><pre><code>sudo nano /etc/wpa.conf</code></pre><p>而 wpa.config 的內容如下，其中的SSID更換成要連的無線 AP SSID，而 psk 填入連線的密碼(ex:123456)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">network&#x3D;&#123;</span><br><span class="line">ssid&#x3D;&quot;MyAP&quot;</span><br><span class="line">psk&#x3D;&quot;12345678&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不過這邊使用密碼是明碼不太好, 可以使用 wpa_passphrase 把密碼加密一下, wpa_passphrase的輸入格式如下  </p><pre><code>wpa_passphrase &lt;ssid&gt; [passphrase]</code></pre><p>所以輸入 wpa_passphrase MyAP 12345678 就會出現  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network&#x3D;&#123;</span><br><span class="line">ssid&#x3D;&quot;MyAp&quot;</span><br><span class="line">       #psk&#x3D;&quot;12345678&quot;</span><br><span class="line">       psk&#x3D;b2449175398db27f75a0790f780cdacd0cbf8529e9e29fa051bdf3248f1fd595</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再把他產生出來的 psk 這段貼入wpa.conf中就可以了, 若是想建立多個AP的密碼表，可以這樣做  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#asus rt-n18u</span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">ssid&#x3D;&quot;EricWangAp_CH&quot;</span><br><span class="line">    psk&#x3D;&quot;12345678&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#asus 520gu</span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">        ssid&#x3D;&quot;EricWangAp&quot;</span><br><span class="line">        psk&#x3D;&quot;12345678&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停用/啟用網卡</p><pre><code>sudo ifdown wlan0sudo ifup wlan0</code></pre><p>使用 <code>ifconfig</code> 觀察是否正常取得 ip  </p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>這邊也提供其他網頁的資料，供各位參考<br><a href="http://www.raspberrypi.com.tw/2152/setting-up-wifi-with-the-command-line/">命令列設置無線網路.</a>   </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;安裝-wireless-usb&quot;&gt;&lt;a href=&quot;#安裝-wireless-usb&quot; class=&quot;headerlink&quot; title=&quot;安裝 wireless usb &quot;&gt;&lt;/a&gt;安裝 wireless usb &lt;/h2&gt;&lt;p&gt;經過我的實驗，UsbHub 對於無線傳輸會不會當機佔了很大的因素，我之前使用 D-link Dub H7 用samba拉檔案，約 5min 後就會當機，起初還以為RPi本身的問題，
後來換了Belkin F5U237之後，試了兩張網卡( SMC-usb-wireless-G，TL-821Nv3)都沒有問題。&lt;/p&gt;
&lt;p&gt;最好是買有內建驅動不用再折騰的如 EW-7811Un、TL-821Nv3 等，
你也可以在&lt;a href=&quot;http://elinux.org/RPi_VerifiedPeripherals#USB_Wi-Fi_Adapters&quot;&gt;Wifi硬體清單&lt;/a&gt;中選一張。  &lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry pi 上安裝 samba (網路芳鄰)</title>
    <link href="http://wwssllabcd.github.io/2013/04/22/how-to-setup-samba-in-raspberry-pi/"/>
    <id>http://wwssllabcd.github.io/2013/04/22/how-to-setup-samba-in-raspberry-pi/</id>
    <published>2013-04-22T08:19:00.000Z</published>
    <updated>2016-06-05T16:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-apt-安裝"><a href="#使用-apt-安裝" class="headerlink" title="使用 apt 安裝"></a>使用 apt 安裝</h1><p>使用 apt 安裝, 就那麼簡單</p><pre><code>sudo apt-get install samba</code></pre><h1 id="設定-conf-檔"><a href="#設定-conf-檔" class="headerlink" title="設定 conf 檔"></a>設定 conf 檔</h1><p>設定 conf 檔之前，先備份</p><pre><code>sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.org</code></pre><p>編輯 smb.conf</p><pre><code>sudo nano /etc/samba/smb.conf</code></pre><a id="more"></a><p>在conf檔最下面加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[myusb]</span><br><span class="line">comment &#x3D; Mydrive</span><br><span class="line">read only &#x3D; no</span><br><span class="line">locking &#x3D; no</span><br><span class="line">path &#x3D; &#x2F;media&#x2F;myusb</span><br><span class="line">guest ok &#x3D; yes</span><br><span class="line">force user &#x3D; pi</span><br><span class="line">writeable &#x3D; Yes</span><br><span class="line">only guest &#x3D; Yes</span><br><span class="line">create mask &#x3D; 0777</span><br><span class="line">directory mask &#x3D; 0777</span><br></pre></td></tr></table></figure><p>注意, 其中 force user 這邊, 因為 RP I登入的帳號是 pi, 若是換了其他系統(如 Lamoba-m1, banana pi香蕉派之類的) 要注意這邊的 force user 可能是 root   </p><p>其中 [myusb]是顯示的資料夾名稱，設定好後重啟服務</p><pre><code>sudo /etc/init.d/samba restart</code></pre><p>也可以設定 samba 使用者及密碼 ( 要先執行 sudo apt-get install samba-common-bin )</p><pre><code>sudo smbpasswd -a lifeshow </code></pre><h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><p>samba 的 debug 的 log 檔可以從 smb.conf 中找到, 打開 smb.conf, 搜尋 log 關鍵字, 可以找到</p><pre><code>#### Debugging/Accounting ##### This tells Samba to use a separate log file for each machine# that connects    log file = /var/log/samba/log.%m</code></pre><p>即可得知 log 檔放在<code> /var/log/samba/log.%m</code> </p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>這邊也提供其他網頁的資料，供各位參考<br><a href="http://simonthepiman.com/how_to_setup_windows_file_server.php">How2SetUp a Raspberry Pi Windows NAS storage server</a>  </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用-apt-安裝&quot;&gt;&lt;a href=&quot;#使用-apt-安裝&quot; class=&quot;headerlink&quot; title=&quot;使用 apt 安裝&quot;&gt;&lt;/a&gt;使用 apt 安裝&lt;/h1&gt;&lt;p&gt;使用 apt 安裝, 就那麼簡單&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install samba&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;設定-conf-檔&quot;&gt;&lt;a href=&quot;#設定-conf-檔&quot; class=&quot;headerlink&quot; title=&quot;設定 conf 檔&quot;&gt;&lt;/a&gt;設定 conf 檔&lt;/h1&gt;&lt;p&gt;設定 conf 檔之前，先備份&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.org&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;編輯 smb.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo nano /etc/samba/smb.conf&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>打造脫機下載農場，使用Raspberry pi + transmission-daemon</title>
    <link href="http://wwssllabcd.github.io/2013/04/22/how-to-setup-transmission-deamon-in-raspberry-pi/"/>
    <id>http://wwssllabcd.github.io/2013/04/22/how-to-setup-transmission-deamon-in-raspberry-pi/</id>
    <published>2013-04-22T08:13:00.000Z</published>
    <updated>2016-06-05T16:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>RPi 也是可以脫機下載當成農場在使用的，只要安裝 BT Client -- transmission-daemon( 簡稱 TD )就可以輕鬆當起農場主人，就我使用的狀況來說，以 RPi 的硬體來看，700 MHz + 512 RAM 還算足夠，且現在的 transmission 很穩，下載速度更是不俗，我有看過 3.5MB 的下載速度，我家電腦使用 uTorrent 也沒那麼快過，連續開一兩個禮拜也沒當機，所以 RPi 拿來當作 NAS 我想是很 ok 的。</p><h1 id="使用-apt-安裝"><a href="#使用-apt-安裝" class="headerlink" title="使用 apt 安裝"></a>使用 apt 安裝</h1><pre><code>sudo apt-get install transmission-daemon  </code></pre><p>安裝完後，要修改組態檔，在修改之前，最好先停掉BT程式，以免修改過的 settings.json 被覆蓋掉，執行以下命令停掉 transmission-daemon</p><pre><code>sudo killall transmission-daemon</code></pre><a id="more"></a><h1 id="修改設定檔"><a href="#修改設定檔" class="headerlink" title="修改設定檔"></a>修改設定檔</h1><p>輸入  </p><pre><code>sudo nano /etc/transmission-daemon/settings.json</code></pre><p>新版的好像換位置了，是在    </p><pre><code>sudo nano /var/lib/transmission-daemon/info/settings.json</code></pre><p>接下來就是修改設定檔，以下只列出我有修改過的，詳細設定請看<a href="https://trac.transmissionbt.com/wiki/ConfigurationParameters">TD 參數說明</a><br>下載完成路徑:記得要去對應的磁碟看有無建立該目錄  </p><pre><code>&quot;download-dir&quot;: &quot;/media/myusb/bt/downloads&quot;,</code></pre><p><code>PS:nano 使用&quot;Ctrl + K&quot; 來刪除整行</code></p><p>未完成檔案路徑:記得要去對應的磁碟看有無建立該目錄，我通常會把他enable，這樣就可以區分哪些是抓好的，哪些是還在抓的。</p><pre><code>&quot;incomplete-dir&quot;: &quot;/media/myusb/bt/incomplete&quot;,&quot;incomplete-dir-enabled&quot;: true,</code></pre><p>download-queue-size 我也有調整</p><pre><code>&quot;download-queue-size&quot;: 10,</code></pre><p>指定節點的加密模式這項我是設為0</p><pre><code>&quot;encryption&quot;: 0,</code></pre><p>lazy-bitfield-enabled <code>聽說</code>可以躲過 ISP 追查</p><pre><code>&quot;lpd-enabled&quot;: true,</code></pre><p>max-peers-global 與 peer-limit-global 與 peer-limit-per-torrent 我這邊設定是 500, 400, 150</p><pre><code>&quot;max-peers-global&quot;: 240,&quot;peer-limit-global&quot;: 60,&quot;peer-limit-per-torrent&quot;: 30,</code></pre><p>請注意，如果你的 max-peers-global 設太高，可能就會造成 CPU 常常在 100% 的現象，原因不明  </p><p>port-forwarding-enabled 如果無線 AP也開啟了uPnP，則 AP 會做 port mapping，是如果網內有好幾台機器同時使用 transmission，就必須更改peer-port值為不一樣  </p><pre><code>&quot;port-forwarding-enabled&quot;: false, </code></pre><p>rpc 遠端管理介面 是否要使用帳號認證, 設定為 false 的話, 就是不用帳號密碼也可以登入  </p><pre><code>&quot;rpc-authentication-required&quot;: false,</code></pre><p>rpc 遠端管理介面 port 號 &amp; 路徑設定</p><pre><code>&quot;rpc-port&quot;: 9091, &quot;rpc-url&quot;: &quot;/transmission/&quot;, </code></pre><p>rpc 登入名稱</p><pre><code>&quot;rpc-username&quot;: &quot;yourName&quot;,</code></pre><p>rpc 登入密碼，這邊先輸入明文，等到trans再次啟動時，這邊會經過加密</p><pre><code> &quot;rpc-password&quot;: &quot;YourPassWord&quot;</code></pre><p>登入白名單: 基本上為方便起見是沒設定白名單</p><pre><code>&quot;rpc-whitelist&quot;: &quot;*.*.*.*&quot;,&quot;rpc-whitelist-enabled&quot;: false,</code></pre><p>torrent 限速部分如下</p><pre><code>&quot;speed-limit-down&quot;: 2500,&quot;speed-limit-down-enabled&quot;: true,&quot;speed-limit-up&quot;: 100,&quot;speed-limit-up-enabled&quot;: true,</code></pre><p>這邊我建議設定一下限速,因為如果讓他 unlimit 在跑的話,跑到 3M 會讓 cpu 負載到 9x%，限速到2M時，cpu 變成 7x%，為了系統穩定，還是慢一點好</p><p>預設權限設定</p><pre><code>&quot;umask&quot;: 0,</code></pre><p>這邊稍微解釋一下 umask 的意思，umask 的分數指的是預設值需要<code>減掉</code>的權限，因為read、Write、execute 的分數分別是 4、2、1 分，所以 umask 設 0 的話，就是預設 777 - 000，就是權限全開的意思  </p><p>這邊預設是 18，也就是 0777(預設八進位) - 0022(18的八進位) = 0755 =&gt; -rwxr-xr-x，因為我是以網路芳鄰的方式，來管理下載完的檔案，如果不修改的話，到時候下載回來的檔案因為權限的關係，是無法做刪除的動作，所以最好是修改為 0，雖然設 777 有安全上顧慮，但我想也還好(懶)。若真的要想要安全的話，就把Samba Server中的 user 加入到 transmission 的 group，應該就可以改 umask 了。</p><p>若開啟下載相對應的目錄建立好後, 順便修改讀寫權限, 從bt這個根目錄改起, 可使用<code>-R</code>參數, 代表 recursive</p><pre><code>sudo chmod 777 -R bt</code></pre><h1 id="重新啟動-transmission-daemon"><a href="#重新啟動-transmission-daemon" class="headerlink" title="重新啟動 transmission-daemon  "></a>重新啟動 transmission-daemon  </h1><pre><code>sudo service transmission-daemon reloadsudo service transmission-daemon restartsudo service transmission-daemon status</code></pre><p>最後最好確認一下 status 的狀況，我碰過 restart 出現 ok，但 status 出現 fail 的情況，若出現 ok 字樣，就代表正常啟動。</p><h1 id="進入管理介面"><a href="#進入管理介面" class="headerlink" title="進入管理介面"></a>進入管理介面</h1><p>連線到 web 管理介面：接下來就可以連線到 web 管理介面，即設定檔中的rpc的位置，若 RPI 的 ip 為 192.168.0.20 的話，則管理介面為 <a href="http://192.168.0.20:9091/transmission">http://192.168.0.20:9091/transmission</a> ， 當然也有 PC 端的管理軟體<br>遠端管理軟體：與其使用 brower 管理，我更推薦使用<a href="http://code.google.com/p/transmisson-remote-gui/">transmisson-remote-gui</a>會比較方便   </p><p>若還是登入不進去的話, 可以先把設定檔中的 </p><pre><code>&quot;rpc-authentication-required&quot;: false,</code></pre><p>設定成 false , 在登入試看看是否為帳號密碼的問題</p><h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><h2 id="若遇到-Status-Fail-的情況"><a href="#若遇到-Status-Fail-的情況" class="headerlink" title="若遇到 Status Fail 的情況"></a>若遇到 Status Fail 的情況</h2><p>老實說我也不知道，目前只能用  </p><pre><code>sudo killall transmission-daemon</code></pre><p>再把 TD( transmission-daemon) 移除掉     </p><pre><code>sudo apt-get autoremove transmission-daemon  </code></pre><p>接下來再把 TD 的目錄砍掉  </p><pre><code>sudo rm -r /var/lib/transmission-daemon/  sudo rm -r /etc/transmission-daemon/  </code></pre><p>再重新安裝即可，聽起來很悲情，但至少不用重灌整個系統，重灌更悲情</p><h1 id="有幾點要提醒"><a href="#有幾點要提醒" class="headerlink" title="有幾點要提醒  "></a>有幾點要提醒  </h1><ul><li>transmission 的 port 號也要去 無線 AP 那邊做對應  </li><li>外掛硬碟格式：建議外掛的 usb 最好 format ext4的格式，因為如果使用 NTFS 的話，必須掛上 NTFS-3G，會佔很多系統的資源。  </li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference  "></a>Reference  </h1><p><a href="http://bbs.dualwan.cn/archiver/?tid-124872.html">詳細的settings.json介紹</a><br><a href="https://trac.transmissionbt.com/wiki/EditConfigFiles">設定介紹</a>   </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RPi 也是可以脫機下載當成農場在使用的，只要安裝 BT Client -- transmission-daemon( 簡稱 TD )就可以輕鬆當起農場主人，就我使用的狀況來說，
以 RPi 的硬體來看，700 MHz + 512 RAM 還算足夠，且現在的 transmission 很穩，下載速度更是不俗，我有看過 3.5MB 的下載速度，
我家電腦使用 uTorrent 也沒那麼快過，連續開一兩個禮拜也沒當機，所以 RPi 拿來當作 NAS 我想是很 ok 的。&lt;/p&gt;
&lt;h1 id=&quot;使用-apt-安裝&quot;&gt;&lt;a href=&quot;#使用-apt-安裝&quot; class=&quot;headerlink&quot; title=&quot;使用 apt 安裝&quot;&gt;&lt;/a&gt;使用 apt 安裝&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;sudo apt-get install transmission-daemon  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安裝完後，要修改組態檔，在修改之前，最好先停掉BT程式，以免修改過的 settings.json 被覆蓋掉，
執行以下命令停掉 transmission-daemon&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo killall transmission-daemon&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
</feed>
