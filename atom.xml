<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>printf(&quot; I&#39;m EricWang &quot;)</title>
  
  
  <link href="http://wwssllabcd.github.io/atom.xml" rel="self"/>
  
  <link href="http://wwssllabcd.github.io/"/>
  <updated>2021-02-14T15:56:25.247Z</updated>
  <id>http://wwssllabcd.github.io/</id>
  
  <author>
    <name>EricWang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>從零開始的 Gameboy 模擬器開發 -- Step 5</title>
    <link href="http://wwssllabcd.github.io/2021/02/14/how-to-build-a-gameboy-emulator-5/"/>
    <id>http://wwssllabcd.github.io/2021/02/14/how-to-build-a-gameboy-emulator-5/</id>
    <published>2021-02-13T16:24:46.000Z</published>
    <updated>2021-02-14T15:56:25.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gameboy-的輸入系統"><a href="#Gameboy-的輸入系統" class="headerlink" title="Gameboy 的輸入系統"></a>Gameboy 的輸入系統</h1><p>接著要來做有關輸入系統的部分，也就是搖桿，其實不會太困難，甚至這是整系列最簡單的一部分，作法就是我們要想辦法從 sdl2 那邊收到外部的輸入後，再模擬成 z80 收到外部輸入的樣子即可</p><p>從 sdl2 接收輸入很簡單，他已經幫我們弄好了 void process_events() 算是定番了，照著打就對了，最後會轉一手傳入到 key_down_event() or key_up_event() 裡面</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">    GB_KEY_NULL &#x3D; 0,</span><br><span class="line">    GB_KEY_UP,</span><br><span class="line">    GB_KEY_DOWN,</span><br><span class="line">    GB_KEY_LEFT,</span><br><span class="line">    GB_KEY_RIGHT,</span><br><span class="line">    GB_KEY_A,</span><br><span class="line">    GB_KEY_B,</span><br><span class="line">    GB_KEY_SELECT,</span><br><span class="line">    GB_KEY_START,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">eu8 get_gb_key_event_code(SDL_Keycode keyCode) &#123;</span><br><span class="line">    switch (keyCode) &#123;</span><br><span class="line">        case SDLK_UP: return GB_KEY_UP;</span><br><span class="line">        case SDLK_DOWN: return GB_KEY_DOWN;</span><br><span class="line">        case SDLK_LEFT: return GB_KEY_LEFT;</span><br><span class="line">        case SDLK_RIGHT: return GB_KEY_RIGHT;</span><br><span class="line">        case SDLK_k: return GB_KEY_A;</span><br><span class="line">        case SDLK_l: return GB_KEY_B;</span><br><span class="line">        case SDLK_SPACE: return GB_KEY_SELECT;</span><br><span class="line">        case SDLK_RETURN: return GB_KEY_START;</span><br><span class="line">        default: return GB_KEY_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void get_sdl2_key_events(SDL_Keycode keyCode, bool isKeyDown) &#123;</span><br><span class="line">    eu8 event_code &#x3D; get_gb_key_event_code(keyCode);</span><br><span class="line">    if (isKeyDown) &#123;</span><br><span class="line">        key_down_event(event_code);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        key_up_event(event_code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void process_events() &#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line"></span><br><span class="line">    while (SDL_PollEvent(&amp;event)) &#123;</span><br><span class="line">        switch (event.type) &#123;</span><br><span class="line">            case SDL_KEYDOWN:</span><br><span class="line">                if (event.key.repeat &#x3D;&#x3D; true) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                get_sdl2_key_events(event.key.keysym.sym, true);</span><br><span class="line">                break;</span><br><span class="line">            case SDL_KEYUP:</span><br><span class="line">                if (event.key.repeat &#x3D;&#x3D; true) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                get_sdl2_key_events(event.key.keysym.sym, false);</span><br><span class="line">                break;</span><br><span class="line">            case SDL_WINDOWEVENT:</span><br><span class="line">                if (event.window.event &#x3D;&#x3D; SDL_WINDOWEVENT_CLOSE) &#123;</span><br><span class="line">                    g_cpu.running &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case SDL_QUIT:</span><br><span class="line">                g_cpu.running &#x3D; false;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>key_down_event 與 key_up_event 會把 一些 flag 立起來，代表目前 joypad 的狀況</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">typedef union &#123;</span><br><span class="line">    eu8 all;</span><br><span class="line">    struct &#123;</span><br><span class="line">        bool up;</span><br><span class="line">        bool down;</span><br><span class="line">        bool left;</span><br><span class="line">        bool right;</span><br><span class="line">        bool a;</span><br><span class="line">        bool b;</span><br><span class="line">        bool select;</span><br><span class="line">        bool start;</span><br><span class="line">        bool button_switch;</span><br><span class="line">        bool direction_switch;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;GbKey;</span><br><span class="line"></span><br><span class="line">GbKey g_key &#x3D; &#123;</span><br><span class="line">    .up &#x3D; false,</span><br><span class="line">    .down &#x3D; false,</span><br><span class="line">    .left &#x3D; false,</span><br><span class="line">    .right &#x3D; false,</span><br><span class="line">    .a &#x3D; false,</span><br><span class="line">    .b &#x3D; false,</span><br><span class="line">    .select &#x3D; false,</span><br><span class="line">    .start &#x3D; false,</span><br><span class="line">    .button_switch &#x3D; false,</span><br><span class="line">    .direction_switch &#x3D; false,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void input_write(eu8 value) &#123;</span><br><span class="line">    &#x2F;&#x2F; maybe reset joypad</span><br><span class="line">    g_key.direction_switch &#x3D; !CHECK_BIT(value, 4);</span><br><span class="line">    g_key.button_switch &#x3D; !CHECK_BIT(value, 5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 input_read() &#123;</span><br><span class="line">    eu8 buttons &#x3D; 0b1111;</span><br><span class="line">    if (g_key.direction_switch) &#123;</span><br><span class="line">        SET_BIT_TO(buttons, 0, !g_key.right);</span><br><span class="line">        SET_BIT_TO(buttons, 1, !g_key.left);</span><br><span class="line">        SET_BIT_TO(buttons, 2, !g_key.up);</span><br><span class="line">        SET_BIT_TO(buttons, 3, !g_key.down);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (g_key.button_switch) &#123;</span><br><span class="line">        SET_BIT_TO(buttons, 0, !g_key.a);</span><br><span class="line">        SET_BIT_TO(buttons, 1, !g_key.b);</span><br><span class="line">        SET_BIT_TO(buttons, 2, !g_key.select);</span><br><span class="line">        SET_BIT_TO(buttons, 3, !g_key.start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SET_BIT_TO(buttons, 4, !g_key.direction_switch);</span><br><span class="line">    SET_BIT_TO(buttons, 5, !g_key.button_switch);</span><br><span class="line"></span><br><span class="line">    return buttons;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set_button(eu8 code, bool is_key_down) &#123;</span><br><span class="line">    if (code &#x3D;&#x3D; GB_KEY_NULL) &#123;return; &#125;</span><br><span class="line"></span><br><span class="line">    if (code &#x3D;&#x3D; GB_KEY_UP) &#123; g_key.up &#x3D; is_key_down; &#125;</span><br><span class="line">    if (code &#x3D;&#x3D; GB_KEY_DOWN) &#123; g_key.down &#x3D; is_key_down; &#125;</span><br><span class="line">    if (code &#x3D;&#x3D; GB_KEY_LEFT) &#123; g_key.left &#x3D; is_key_down; &#125;</span><br><span class="line">    if (code &#x3D;&#x3D; GB_KEY_RIGHT) &#123; g_key.right &#x3D; is_key_down; &#125;</span><br><span class="line">    if (code &#x3D;&#x3D; GB_KEY_A) &#123; g_key.a &#x3D; is_key_down; &#125;</span><br><span class="line">    if (code &#x3D;&#x3D; GB_KEY_B) &#123; g_key.b &#x3D; is_key_down; &#125;</span><br><span class="line">    if (code &#x3D;&#x3D; GB_KEY_SELECT) &#123; g_key.select &#x3D; is_key_down; &#125;</span><br><span class="line">    if (code &#x3D;&#x3D; GB_KEY_START) &#123; g_key.start &#x3D; is_key_down; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void key_down_event(eu8 code) &#123;</span><br><span class="line">    set_button(code, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void key_up_event(eu8 code) &#123;</span><br><span class="line">    set_button(code, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後 input_read 會負責丟給 fw，那怎麼丟給 fw 呢? joypad 與 fw 的溝通是靠 0xFF00 這個位置，而這個位置有特定的格式，大家再去找手冊看吧</p><p>也就是說，我們的 input_read() 會假裝成 0xFF00 的那個 byte, 而這個 byte 的內容就是根據目前 joypad 的 flag 所產生的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define IO_P1                        (0xFF00)</span><br><span class="line">#define IO_SERIAL                    (0xFF02)</span><br><span class="line">#define IO_TIMER_MODULE              (0xFF06)</span><br><span class="line">#define IO_TIMER_CTRL                (0xFF07)</span><br><span class="line">#define IO_DMA                       (0xFF46)</span><br><span class="line">#define BOOT_ROM_ENABLE_ADDR         (0xFF50)</span><br><span class="line"></span><br><span class="line">eu8 get_ram(RamAddr addr) &#123;</span><br><span class="line">    if (addr &#x3D;&#x3D; IO_P1) &#123;</span><br><span class="line">        return input_read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fix 0xFF</span><br><span class="line">    if (addr &#x3D;&#x3D; IO_SERIAL) &#123;</span><br><span class="line">        return 0xFF;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; DMA, fix 0</span><br><span class="line">    if (addr &#x3D;&#x3D; IO_DMA) &#123;</span><br><span class="line">        return 0x0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (*get_ram_ptr(addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊就不著墨太多了，因為蠻簡單的，自己看個幾遍就會理解嚕</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Gameboy-的輸入系統&quot;&gt;&lt;a href=&quot;#Gameboy-的輸入系統&quot; class=&quot;headerlink&quot; title=&quot;Gameboy 的輸入系統&quot;&gt;&lt;/a&gt;Gameboy 的輸入系統&lt;/h1&gt;&lt;p&gt;接著要來做有關輸入系統的部分，也就是搖桿，其實不會太困難，甚至這是整系列最簡單的一部分，作法就是我們要想辦法從 sdl2 那邊收到外部的輸入後，再模擬成 z80 收到外部輸入的樣子即可&lt;/p&gt;
&lt;p&gt;從 sdl2 接收輸入很簡單，他已經幫我們弄好了 void process_events() 算是定番了，照著打就對了，最後會轉一手傳入到 key_down_event() or key_up_event() 裡面&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="C" scheme="http://wwssllabcd.github.io/tags/C/"/>
    
    <category term="Emulator" scheme="http://wwssllabcd.github.io/tags/Emulator/"/>
    
  </entry>
  
  <entry>
    <title>從零開始的 Gameboy 模擬器開發 -- Step 4</title>
    <link href="http://wwssllabcd.github.io/2021/02/12/how-to-build-a-gameboy-emulator-4/"/>
    <id>http://wwssllabcd.github.io/2021/02/12/how-to-build-a-gameboy-emulator-4/</id>
    <published>2021-02-11T16:24:46.000Z</published>
    <updated>2021-02-14T16:53:49.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gameboy-的-tile-系統與繪圖"><a href="#Gameboy-的-tile-系統與繪圖" class="headerlink" title="Gameboy 的 tile 系統與繪圖"></a>Gameboy 的 tile 系統與繪圖</h1><p>接著要來做有關繪圖的部分，這部分說簡單也不簡單，說難也不會難，難的部分是因為我們沒有碰過 tile 系統，所以要花點時間去理解，當理解後，實作部分其實很簡單一點也不難，如果你還沒去看最前面介紹的影片，我建議你趕快去看，因為看完之後會比較好理解</p><p>首先我再幫大家整理一下概念</p><ul><li>一個 tile 由 8*8 個 pixel 所組成</li><li>GB 整個顯示的部分是 256 * 256 個 pixel ，換算成 tile 就是 32 * 32 個 tile, 在code 裡面我們會以 scroll_px_x, scroll_px_y 來表示<ul><li>好像有人稱作虛擬螢幕</li></ul></li><li>但是  GB 能顯示的螢幕(screen)卻只有 160 * 144 個 pixel ，也就是說他只會顯示上述畫面的一部分<ul><li>他的用意在於，他可以利用這種窗口，去實現類似鏡頭平移的的功能，這邊的 demo 你可以在影片中看到</li><li>對於螢幕的 x, y ，在code 裡面會以 screen_px_x 與 screen_px_y 來表示</li></ul></li><li>總結就是，cpu 內設計的螢幕結構是 256<em>256 的，但是你只能看到這 256</em>256  的 160*144 ，<ul><li>這樣設計的原因就是他可以做出一些視覺的效果</li><li>例如網球比賽的鏡頭，馬力歐跳躍時的畫面移動，或是橫向捲軸遊戲的效果</li></ul></li></ul><hr><p>像我對於這東西就困擾很久，想說這什麼鬼東西，為什麼任天堂的螢幕不弄得跟他內部一樣都是  256*256 等等，反正你不要想得太複雜，以下做個比喻</p><ul><li>地上有個由 32 *32 個巧拼所組成的正方形背景拚圖，每個巧拼為 8 * 8 cm，所以整個拼背景圖大小為 256 cm * 256 cm</li><li>然後你手上有個 160 cm * 144 cm 的白色方框，這個代表你所能看到的區域</li><li>然後你試著把方框在那個拼圖上任意移動，然後觀察方框內的畫面，這個就像是GB 的畫面移動方式</li><li>然後你在方框內平放一個 8 * 8 cm 的巧拼，上面畫有一個馬力歐，讓他在方框內任意移動，當紙娃娃向右移動快移出方框的時候，你也同步的把方框往右移</li><li>GB 的顯示系統大概就是這個樣子，拼圖代表 256 * 256 pixel 的虛擬螢幕(scroll)，巧拼代表 8 * 8  pixel 的 tile，方框代表 144* 160 pixel 的顯示螢幕(screen)，而馬力歐代表一個 sprite ，他由1個 or 2 個 tile 組成</li></ul><a id="more"></a><hr><p>我們再來講一下 screen 的部分</p><ul><li>screen 會由三種東西組成，分別是 BG, Windw, sprite</li><li>而 sprite 在任天堂內部稱作 Object ，而他的屬性就稱作 OAM(Object Attribute Memory)，sprite 與 object 他們是一樣的東西 ，只是一個是美國稱作 sprite ，任天堂叫做 Object</li><li>所以畫面的產生方式就是<ul><li>先畫出 BG </li><li>再背景上面畫 window </li><li>最後再把 sprite 覆蓋上去</li><li>以這種順序來畫的話，他的圖層就會是 sprite 是最高，最低的就是 bg</li></ul></li></ul><p>你拿之前我們那個拼圖的比喻去理解就可以了</p><p>PS: 順帶一提的是這邊可能有錯，理論上 window 應該是最高，不過我看的那個 project  的順序是這樣，所以我就先 fallow 了</p><p>其實作的方式就是我們會有一個二維陣列叫 frame_buffer[144][160] , 負責把畫面上的每個 pixel 收集起來後，最後再輸出到 sdl2 上面那我們的 psudo code 會長成這樣 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eu8 frame_buffer[144][160];</span><br><span class="line">init_frame_buffer(frame_buffer)</span><br><span class="line">get_bg_data(frame_buffer)</span><br><span class="line">get_window_data(frame_buffer)</span><br><span class="line">get_sprite_data(frame_buffer)</span><br><span class="line">draw_by_sdl2(frame_buffer)</span><br></pre></td></tr></table></figure><p>frame_buffer 會去收集整個畫面的 pixel 後，window 與 sprite 又會把跟著把剛剛收集到的點蓋過去，用這種方式可以做出不同的圖層的效果</p><h1 id="開始建置顯示系統"><a href="#開始建置顯示系統" class="headerlink" title="開始建置顯示系統"></a>開始建置顯示系統</h1><h2 id="產生-cpu-clock"><a href="#產生-cpu-clock" class="headerlink" title="產生 cpu clock "></a>產生 cpu clock </h2><p>要先做顯示系統之前，我們必須加入 cpu clock 的計算，也就是我們要模擬 cpu 經過的時間，每個 op code 都會花不同的 cycle 時間，所以我們只要根據 op code 去查表就可以得知這次所花的 cycle 數</p><p>新增一個檔案叫 cpu_cycle.c ，對外提供一個 function 叫做 get_op_cycle()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">const eu8 g_opcodeCycles[256] &#x3D; &#123;</span><br><span class="line">    1, 3, 2, 2, 1, 1, 2, 1, 5, 2, 2, 2, 1, 1, 2, 1, </span><br><span class="line">    1, 3, 2, 2, 1, 1, 2, 1, 3, 2, 2, 2, 1, 1, 2, 1, </span><br><span class="line">    2, 3, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 1, 1, 2, 1, </span><br><span class="line">    2, 3, 2, 2, 3, 3, 3, 1, 2, 2, 2, 2, 1, 1, 2, 1, </span><br><span class="line">    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, </span><br><span class="line">    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, </span><br><span class="line">    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, </span><br><span class="line">    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, </span><br><span class="line">    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, </span><br><span class="line">    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, </span><br><span class="line">    1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, </span><br><span class="line">    2, 3, 3, 4, 3, 4, 2, 4, 2, 4, 3, 0, 3, 6, 2, 4,</span><br><span class="line">    2, 3, 3, 0, 3, 4, 2, 4, 2, 4, 3, 0, 3, 0, 2, 4, </span><br><span class="line">    3, 3, 2, 0, 0, 4, 2, 4, 4, 1, 4, 0, 0, 0, 2, 4, </span><br><span class="line">    3, 3, 2, 1, 0, 4, 2, 4, 3, 2, 4, 1, 0, 0, 2, 4</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const eu8 g_opcodeCycles_cb[256] &#x3D; &#123;</span><br><span class="line">    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2,</span><br><span class="line">    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, </span><br><span class="line">    2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">eu8 get_cycle(eu8 opcode) &#123;</span><br><span class="line">    return g_opcodeCycles[opcode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 get_cb_cycle(eu8 opcode) &#123;</span><br><span class="line">    return g_opcodeCycles_cb[opcode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 get_op_cycle(bool is_cb_cmd, eu8 opcode) &#123;</span><br><span class="line">    if (is_cb_cmd) &#123;</span><br><span class="line">        return get_cb_cycle(opcode);</span><br><span class="line">    &#125;</span><br><span class="line">    return get_cycle(opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>並修改cpu.c 中的 execute_opcode() 與 void tick()，加入回傳 clock 後，在把 clock 傳入到  video_tick() 中，這個 function 是放在 video.c 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">eu8 execute_opcode() &#123;</span><br><span class="line">    eu8 opcode &#x3D; fetch();</span><br><span class="line">    opcode_fun_usp op_map &#x3D; g_opcode_fun_map;</span><br><span class="line">    bool is_cb_cmd &#x3D; false;</span><br><span class="line"></span><br><span class="line">    if (opcode &#x3D;&#x3D; PREFIX_CMD) &#123;</span><br><span class="line">        opcode &#x3D; fetch();</span><br><span class="line">        op_map &#x3D; g_opcode_cb_fun_map;</span><br><span class="line">        is_cb_cmd &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    op_map[opcode]();</span><br><span class="line"></span><br><span class="line">    eu8 clock &#x3D; get_op_cycle(is_cb_cmd, opcode);</span><br><span class="line">    return clock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tick() &#123; </span><br><span class="line">    eu8 clock &#x3D; cpu_tick(); </span><br><span class="line">    video_tick(clock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 video.c ，並加入以下的 code </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define CLOCKS_PER_HBLANK (204)         &#x2F;&#x2F; Mode 0  </span><br><span class="line">#define CLOCKS_PER_SCANLINE_OAM (80)    &#x2F;&#x2F; Mode 2  </span><br><span class="line">#define CLOCKS_PER_SCANLINE_VRAM (172)  &#x2F;&#x2F; Mode 3  </span><br><span class="line">#define CLOCKS_PER_SCANLINE (CLOCKS_PER_HBLANK + CLOCKS_PER_SCANLINE_OAM + CLOCKS_PER_SCANLINE_VRAM) </span><br><span class="line"></span><br><span class="line">#define STAT_HBLANK_PERIOD (0) </span><br><span class="line">#define STAT_VBLANK_PERIOD (1) </span><br><span class="line">#define STAT_SCAN_OAM_RAM (2) </span><br><span class="line">#define STAT_TRANSFER_DATA_TO_LCD_DRIVE (3) </span><br><span class="line"></span><br><span class="line">eu8 g_curMode &#x3D; 0; </span><br><span class="line">eu32 g_videoClock &#x3D; 0; </span><br><span class="line">eu8 g_screenFrameBuffer[SCREEN_HEIGHT][SCREEN_WIDTH];</span><br><span class="line"></span><br><span class="line">void video_tick(eu8 clock) &#123; </span><br><span class="line">    g_videoClock +&#x3D; clock; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊分別說明一下 code 的用途</p><ul><li>全域變數 g_videoClock: 紀錄目前 video 所使用的 clock</li><li>g_curMode: 紀錄目前 video 是處在什麼模式</li><li>g_screenFrameBuffer: 對應到 144*160 的顯示畫面</li></ul><p>video 顯示的方式是一條一條的 row (或稱 line) 在畫，畫 row 的時候，動作會依序著做 SCAN_OAM -&gt; TRANSFER_DATA_TO_LCD -&gt; HBLANK ，而 HBLANK 畫完一條之後，就會又回到 SCAN_OAM，當畫到 row &gt; 144 的時候，此時就不會跳回 SCAN_OAM，而是跳到 VBLANK，以下我會詳細說明</p><hr><p>我先把完整個 code 貼出來，再分別的解釋每個區塊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">switch (g_curMode) &#123; </span><br><span class="line">        case ACCESS_OAM: </span><br><span class="line">            if (g_videoClock &gt;&#x3D; CLOCKS_PER_SCANLINE_OAM) &#123; </span><br><span class="line">                g_videoClock &#x3D; g_videoClock % CLOCKS_PER_SCANLINE_OAM; </span><br><span class="line">                LCD_STAT.mode_flag &#x3D; STAT_TRANSFER_DATA_TO_LCD_DRIVE; </span><br><span class="line">                g_curMode &#x3D; ACCESS_VRAM; </span><br><span class="line">            &#125; </span><br><span class="line">            break; </span><br><span class="line">        case ACCESS_VRAM: </span><br><span class="line">            if (g_videoClock &gt;&#x3D; CLOCKS_PER_SCANLINE_VRAM) &#123; </span><br><span class="line">                g_videoClock &#x3D; g_videoClock % CLOCKS_PER_SCANLINE_VRAM; </span><br><span class="line">                &#x2F;&#x2F; if it is H-bank period </span><br><span class="line">                if (LCD_STAT.mode_00) &#123; </span><br><span class="line">                    IE.lcdc &#x3D; 1; </span><br><span class="line">                &#125; </span><br><span class="line">                check_and_set_lyc_flag(); </span><br><span class="line">                LCD_STAT.mode_flag &#x3D; STAT_HBLANK_PERIOD; </span><br><span class="line">                g_curMode &#x3D; HBLANK; </span><br><span class="line">            &#125; </span><br><span class="line">            break; </span><br><span class="line">        case HBLANK: </span><br><span class="line">            if (g_videoClock &gt;&#x3D; CLOCKS_PER_HBLANK) &#123; </span><br><span class="line">                g_videoClock &#x3D; g_videoClock % CLOCKS_PER_HBLANK; </span><br><span class="line">                write_scan_line(LCD.ly); </span><br><span class="line">                LCD.ly++; </span><br><span class="line">                 </span><br><span class="line">                if (LCD.ly &#x3D;&#x3D; 144) &#123; </span><br><span class="line">                    LCD_STAT.mode_flag &#x3D; STAT_VBLANK_PERIOD; </span><br><span class="line">                    IF.vblank &#x3D; 1; </span><br><span class="line">                    g_curMode &#x3D; VBLANK; </span><br><span class="line">                &#125; else &#123; </span><br><span class="line">                    LCD_STAT.mode_flag &#x3D; STAT_SCAN_OAM_RAM; </span><br><span class="line">                    g_curMode &#x3D; ACCESS_OAM; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            break; </span><br><span class="line">        case VBLANK: </span><br><span class="line">            if (g_videoClock &gt;&#x3D; CLOCKS_PER_SCANLINE) &#123; </span><br><span class="line">                g_videoClock &#x3D; g_videoClock % CLOCKS_PER_SCANLINE; </span><br><span class="line">                LCD.ly++; </span><br><span class="line">                if (LCD.ly &gt;&#x3D; 154) &#123; </span><br><span class="line">                    write_sprites(); </span><br><span class="line">                    draw(); </span><br><span class="line">                    LCD.ly &#x3D; 0; </span><br><span class="line">                    LCD_STAT.mode_flag &#x3D; STAT_SCAN_OAM_RAM; </span><br><span class="line">                    g_curMode &#x3D; ACCESS_OAM; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            break; </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="ACCESS-OAM"><a href="#ACCESS-OAM" class="headerlink" title="ACCESS_OAM:"></a>ACCESS_OAM:</h2><p>在開始畫線之前，vidoe hw 第一個動作是做 scan 線上面的 OAM物件(也就是sprite)，他會花 80 個 clock 做這件事，對於我們來說，我們只要在超過 80 clock之後，把流程導到 ACCESS_VRAM 即可，順便要把 LCD_STA(0xFF41) 的 mode_flag 設成 3，這個舉動可以通知 fw 目前是在 xfer data to lcd，不能 access VRAM </p><h2 id="ACCESS-VRAM"><a href="#ACCESS-VRAM" class="headerlink" title="ACCESS_VRAM "></a>ACCESS_VRAM </h2><p>這個時期是 hw transfer data 到 lcd 顯示器的時候，  fw 是不能 access  video ram 的，當經過 172  個 cycle 之後，就要進入到  HBLANK，在進入 之前一樣要把  LCD_STA(0xFF41) 的 mode_flag 設成 0，此時還要檢查目前的要畫的 line (ly) 是否與lyc(0xFF45) 相同，fw 會想要在hw 畫到某條 line 的時候通知 fw，以便 fw 能介入，所以 fw 會去填 0xFF45 register ，hw 若畫到這條 line 的時候會觸發一個中斷，此時 fw 便可介入去做一些事情，所以若畫的 line 與 lyc 相同的話，我們就要把 lcd  state 中的 bit 2 給設起來，這邊請去看手冊的 0xFF41 與 0xFF45 的解釋</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LCD_STAT.coincidence_flag &#x3D; (LCD.ly &#x3D;&#x3D; LCD.lyc);</span><br><span class="line">if (LCD_STAT.ly_c &amp;&amp; LCD_STAT.coincidence_flag) &#123;</span><br><span class="line">    IE.lcdc &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HBLANK"><a href="#HBLANK" class="headerlink" title="HBLANK"></a>HBLANK</h2><p>經過 204 個 cycle 之後，就會離開 HBLANK，離開前會收集本次 line 的 144個 pixel 的值，若是 ly &lt; 144，則就是繼續回去 SCAN_OAM，若超過則會進入到 VBLANK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">write_scan_line(LCD.ly);</span><br><span class="line">LCD.ly++;</span><br><span class="line">                </span><br><span class="line">if (LCD.ly &lt; 144) &#123; </span><br><span class="line">    LCD_STAT.mode_flag &#x3D; STAT_SCAN_OAM_RAM; </span><br><span class="line">    g_curMode &#x3D; ACCESS_OAM; </span><br><span class="line">&#125; else &#123; </span><br><span class="line">    LCD_STAT.mode_flag &#x3D; STAT_VBLANK_PERIOD; </span><br><span class="line">    IF.vblank &#x3D; 1; </span><br><span class="line">    g_curMode &#x3D; VBLANK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VBLANK"><a href="#VBLANK" class="headerlink" title="VBLANK"></a>VBLANK</h2><p>VBLANK 當 ly 超過 154 時，就會把整個畫面畫上去，並且 reset lcd.ly , 並且回到 SCAN_OAM 去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LCD.ly++;</span><br><span class="line">if (LCD.ly &gt;&#x3D; 154) &#123;</span><br><span class="line">    write_sprites();</span><br><span class="line">    draw();</span><br><span class="line"></span><br><span class="line">    LCD.ly &#x3D; 0;</span><br><span class="line">    LCD_STAT.mode_flag &#x3D; STAT_SCAN_OAM_RAM;</span><br><span class="line">    g_curMode &#x3D; ACCESS_OAM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="準備畫出一條線"><a href="#準備畫出一條線" class="headerlink" title="準備畫出一條線"></a>準備畫出一條線</h1><p>write_scan_line 如下，沒什麼特別的，這邊有作一些顯示的控制，fw 可以決定要不要顯示 bg or window，或是關掉整個 lcd ，所以我們必須要支援這些功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void write_scan_line(eu8 curLine) &#123;</span><br><span class="line">    if (!LCD_CTRL.lcd_control_operation) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (LCD_CTRL.bg_and_window_display) &#123;</span><br><span class="line">        get_bg_line_data(curLine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (LCD_CTRL.window_dispaly) &#123;</span><br><span class="line">        draw_window_line(curLine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比較複雜的就是怎樣畫出一條 line 的，我相信這也是很多人想了解的地方，在我們講解之前，我們要先做一些前置作業</p><h2 id="Sprite-相關-type"><a href="#Sprite-相關-type" class="headerlink" title="Sprite 相關 type"></a>Sprite 相關 type</h2><p>sprite(OAM) 就是對應到手冊的說明，而最多只會有 40 個 sprite，所以 type SpriteMap 只有40個 sprite</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> typedef struct &#123; </span><br><span class="line">    eu8 y; </span><br><span class="line">    eu8 x; </span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;Byte2: Pattern number 0-255，(Unlike some tile numbers, sprite pattern numbers are unsigned. LSB is ignored(treated as 0) in 8x16 mode.) </span><br><span class="line">    eu8 pattern_num; </span><br><span class="line">    union &#123; </span><br><span class="line">        eu8 all; </span><br><span class="line">        struct &#123; </span><br><span class="line">            eu8 : 4; </span><br><span class="line">            &#x2F;&#x2F;Bit 4, Sprite colors are taken from OBJ1PAL if this bit is set to 1 and from OBJ0PAL otherwise </span><br><span class="line">            eu8 palette_number : 1; </span><br><span class="line">            &#x2F;&#x2F;Bit 5, Sprite pattern is flipped horizontally if this bit is set to 1. </span><br><span class="line">            eu8 flap_x : 1; </span><br><span class="line">            &#x2F;&#x2F;Bit 6, Sprite pattern is flipped vertically   if this bit is set to 1. </span><br><span class="line">            eu8 flap_y : 1; </span><br><span class="line">            &#x2F;&#x2F;Bit 7, 0: sprite is displayed on top of background &amp; window </span><br><span class="line">            &#x2F;&#x2F;1: sprite will be hidden behind colors 1, 2, and 3 of the background &amp; window </span><br><span class="line">            eu8 priority : 1; </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125;flags; </span><br><span class="line">&#125;Sprite; </span><br><span class="line"></span><br><span class="line">#define TOTAL_SPRITE_CNT (40) </span><br><span class="line">typedef struct &#123; </span><br><span class="line">    Sprite spriteMap[TOTAL_SPRITE_CNT]; </span><br><span class="line">&#125;SpriteMap; </span><br></pre></td></tr></table></figure><hr><h2 id="Tile-相關-type"><a href="#Tile-相關-type" class="headerlink" title="Tile 相關 type"></a>Tile 相關 type</h2><p>一個 tile 的定義為 8 * 8 個 pixel，而一個 pixel 會花兩個 bit 來儲存他的四種顏色所以根據定義， tile 的 row(或稱 line)  共有 8 個 pixel ，會需要花 8*2 = 16 bit = 2 byte 來儲存</p><ul><li>TileLine:  一個 tile 的 row 會花兩個 byte 儲存，所以 TileLine 就是 代表那兩個 byte </li><li>TilePattern: 一個 tile 會有 8 個 TileLine，這個結構代表著整個 tile </li><li>TilePatternMap: 存放 tile pattern data 的地方，這個會根據 0xFF40的 bit4，來決定本次的pattern map 是使用 0x8000 or 0x8800 的地方</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    eu8 byte0;</span><br><span class="line">    eu8 byte1;</span><br><span class="line">&#125;TileLine;</span><br><span class="line"></span><br><span class="line">#define TILE_LINE_CNT     (0x8)</span><br><span class="line">#define TILE_PATTERN_SIZE (TILE_LINE_CNT*2)</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    TileLine line_map[TILE_LINE_CNT];</span><br><span class="line">&#125;TilePattern;</span><br><span class="line"></span><br><span class="line">#define TOTAL_TILE_PATTERN_CNT (256)</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    TilePattern pattern_map[TOTAL_TILE_PATTERN_CNT];</span><br><span class="line">&#125;TilePatternMap;</span><br></pre></td></tr></table></figure><p>最後一個是 TileIdMap，這個結構就是對應到之前講的 GB 內部那個 256 *256 pixel(32 * 32個 tile) 的完整螢幕的 tileMap，所以 tileMap 你可以看到他有兩種存取的方式，一種是線性一維的 map，一種是你可以用 <code>[y][x]</code> 的二維陣列存取，利用這種方式，可以讓我們等下的 code 簡化很多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define TILE_CNT_OF_SCREEN (32)</span><br><span class="line">#define TOTAL_TILE_CNT_OF_SCREEN (TILE_CNT_OF_SCREEN*TILE_CNT_OF_SCREEN)</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        eu8 map[TOTAL_TILE_CNT_OF_SCREEN];</span><br><span class="line">        eu8 map_xy[TILE_CNT_OF_SCREEN][TILE_CNT_OF_SCREEN];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;TileIdMap;</span><br><span class="line">ERIC_GEN_POINTER_TYPE(TileIdMap);</span><br></pre></td></tr></table></figure><h2 id="其他-type"><a href="#其他-type" class="headerlink" title="其他 type "></a>其他 type </h2><p>最後則是 ScrollPx 與 Palette，ScrollPx  這邊有個有趣的地方，我們利用它來取商數與餘數，也就是當你把 .all 設成 10 的時候，你會的到 tile_id = 1 與 tile_px =2而 Palette 就是照手冊設計</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef union &#123;</span><br><span class="line">    eu8 all;</span><br><span class="line">    struct &#123;</span><br><span class="line">        eu8 tile_px : 3;</span><br><span class="line">        eu8 tile_id : 5;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;ScrollPx;</span><br><span class="line"></span><br><span class="line">typedef union &#123;</span><br><span class="line">    eu8 all;</span><br><span class="line">    struct &#123;</span><br><span class="line">        &#x2F;&#x2F;This selects the shade of grays to use for the background(BG)&amp; window pixels.</span><br><span class="line">        &#x2F;&#x2F;Since each pixel uses 2 bits, the corresponding shade will be selected from here.</span><br><span class="line">        eu8 data_for_dot_data_00 : 2;</span><br><span class="line">        eu8 data_for_dot_data_01 : 2;</span><br><span class="line">        eu8 data_for_dot_data_10 : 2;</span><br><span class="line">        eu8 data_for_dot_data_11 : 2;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;Palette;</span><br></pre></td></tr></table></figure><h2 id="tile-pattern-map-與-tile-id-map-存放的位置"><a href="#tile-pattern-map-與-tile-id-map-存放的位置" class="headerlink" title="tile pattern map 與 tile id map 存放的位置"></a>tile pattern map 與 tile id map 存放的位置</h2><p>剛有提到 tile pattern map 與 tile id map 選擇的問題，是靠LCD_CTRL 中的 bg_and_window_tile_data_select 與 bg_tile_map_display_select 所指定，所以這邊也把 selection 的 function 做出來</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> TilePatternMap_p get_tile_data_table(eu8 select) &#123;</span><br><span class="line">    if (select) &#123;</span><br><span class="line">        return (TilePatternMap_p)(get_ram_ptr(TILE_PATTERN_MAP_0));</span><br><span class="line">    &#125;</span><br><span class="line">    return (TilePatternMap_p)(get_ram_ptr(TILE_PATTERN_MAP_1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TileIdMap_p get_tile_id_map(eu8 select) &#123;</span><br><span class="line">    if (select) &#123;</span><br><span class="line">        return (TileIdMap_p)(g_ram + TILE_MAP_1);</span><br><span class="line">    &#125;</span><br><span class="line">    return (TileIdMap_p)(g_ram + TILE_MAP_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TilePatternMap_p get_tile_data_table_bg_window() &#123;</span><br><span class="line">    return get_tile_data_table(LCD_CTRL.bg_and_window_tile_data_select);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TileIdMap_p get_screen_bg_tile_id_table() &#123;</span><br><span class="line">    return get_tile_id_map(LCD_CTRL.bg_tile_map_display_select);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面各做了一個 select funciton 再搭配特化 function 以減少參數輸入</p><hr><h2 id="GB-的色彩選擇-palette"><a href="#GB-的色彩選擇-palette" class="headerlink" title="GB 的色彩選擇 -- palette"></a>GB 的色彩選擇 -- palette</h2><p>接下來要新增取特定 pixel 所對應的顏色，我們知道顏色有四種，編號 0 ~ 3，get_pixel_data() 代表是怎樣從一個 tile 中的兩個byte 中，取出該對應到的 pixel 所代表的 color 編號，比較特別的是他是倒過來取的，而取出來的 color 編號也不是最終的顏色編號，他還要去 LCD.bgp 那邊查表一次，才會知道最後顯示的 color 編號</p><p>write_screen_frame_buffer() 會收集輸出到 144 * 160 的每個 pixel 的值，蠻直覺的 function </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void write_screen_frame_buffer(eu8 x, eu8 y, eu8 color) &#123; </span><br><span class="line">    if (x &gt;&#x3D; SCREEN_WIDTH) &#123; </span><br><span class="line">        ASSERT_CODE(0, &quot;screen_x ofb &#x3D;%X&quot;, x); </span><br><span class="line">    &#125; </span><br><span class="line">    if (y &gt;&#x3D; SCREEN_HEIGHT) &#123; </span><br><span class="line">        ASSERT_CODE(0, &quot;screen_y ofb &#x3D;%X&quot;, y); </span><br><span class="line">    &#125; </span><br><span class="line">    g_screenFrameBuffer[y][x] &#x3D; color; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 get_palette(Palette_sp p, eu8 num) &#123;</span><br><span class="line">    if (num &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return p-&gt;data_for_dot_data_00;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return p-&gt;data_for_dot_data_01;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num &#x3D;&#x3D; 2) &#123;</span><br><span class="line">        return p-&gt;data_for_dot_data_10;</span><br><span class="line">    &#125;</span><br><span class="line">    if (num &#x3D;&#x3D; 3) &#123;</span><br><span class="line">        return p-&gt;data_for_dot_data_11;</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT_CODE(0, &quot;wrong palette num&#x3D;%X&quot;, num);</span><br><span class="line">    return NULL_8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 get_bg_palette(eu8 num) &#123;</span><br><span class="line">    return get_palette(&amp;LCD.bgp, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 get_pixel_data(eu8 byte_0, eu8 byte_1, eu8 px_offset) &#123;</span><br><span class="line">    return (CHECK_BIT(byte_1, 7 - px_offset) &lt;&lt; 1) | (CHECK_BIT(byte_0, 7 - px_offset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此準備工作就告個段落了</p><hr><h1 id="組合所有的-function"><a href="#組合所有的-function" class="headerlink" title="組合所有的 function"></a>組合所有的 function</h1><h2 id="畫出-background"><a href="#畫出-background" class="headerlink" title="畫出 background "></a>畫出 background </h2><p>一切準備就緒後，就可以把一切的東西組合起來嚕，開始寫 get_bg_line_data()，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void draw_bg_window_line(eu8 screen_x, eu8 screen_y, ScrollPx scroll_x, ScrollPx scroll_y, </span><br><span class="line">                         TileIdMap_sp screenTileIdMap) </span><br><span class="line">&#123;</span><br><span class="line">    TilePatternMap_sp tileDataTable &#x3D; get_tile_data_table_bg_window();</span><br><span class="line">    eu8 tile_id &#x3D; screenTileIdMap-&gt;map_xy[scroll_y.tile_id][scroll_x.tile_id];</span><br><span class="line"></span><br><span class="line">    if (!LCD_CTRL.bg_and_window_tile_data_select) &#123;</span><br><span class="line">        tile_id -&#x3D; 0x80;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TileLine_sp tileLine &#x3D; &amp;tileDataTable-&gt;pattern_map[tile_id].line_map[scroll_y.tile_px];</span><br><span class="line">    write_screen_frame_buffer(screen_x, screen_y, get_bg_palette(get_pixel_data(tileLine-&gt;byte0, tileLine-&gt;byte1, scroll_x.tile_px)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void get_bg_line_data(eu8 screen_y) &#123;</span><br><span class="line">    eu8 scrolled_x &#x3D; LCD.scx;</span><br><span class="line">    eu8 scrolled_y &#x3D; screen_y + LCD.scy;</span><br><span class="line"></span><br><span class="line">    TileIdMap_usp screenTileIdMap &#x3D; get_bg_tile_id_map();</span><br><span class="line"></span><br><span class="line">    for (eu8 screen_x &#x3D; 0; screen_x &lt; SCREEN_WIDTH; screen_x++) &#123;</span><br><span class="line">        &#x2F;&#x2F; we need to roll back to 0 when scrolled_x &gt; 256</span><br><span class="line">        ScrollPx scroll_x &#x3D; &#123;.all &#x3D; (scrolled_x + screen_x) % BG_MAP_PIXEL_SIZE&#125;;</span><br><span class="line">        ScrollPx scroll_y &#x3D; &#123;.all &#x3D; (scrolled_y) % BG_MAP_PIXEL_SIZE&#125;;</span><br><span class="line"></span><br><span class="line">        draw_bg_window_line(screen_x, screen_y, scroll_x, scroll_y, screenTileIdMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算是蠻簡潔的 code，不過 tile 的概念就是這樣，沒有很複雜，讓我解釋一下裡面用到的變數，這邊為了避免混淆虛擬螢幕與顯示螢幕，這邊命名 scroll 的是代表虛體螢幕(也就是256 * 256 的拼圖)，而 screen 代表顯示的螢幕(也就是 144 * 160 白色方框)</p><ul><li>scrolled_x 與 scrolled_y : 代表 BG 要從 256 *256 的實體螢幕上的哪一點 x,y 開始畫，還記得我們之前拼圖，白色方框的比喻嗎? 這個就是決定白色方框的 x, y </li><li>scroll_x 與 scroll_y: 代表每一次要取的 scroll x, y ，這邊有做一個取餘數 % 的動作，可以讓你畫到超出界外的時候，roll back 到最前面</li></ul><p>接下來講解 draw_bg_window_line ()，而這邊的 code 有跟畫 window 共用的 code，所以這邊需要傳入一個參數進去，藉以區分 screenTileTidMap</p><p>取出目前對應的 tileDataTable  與 screenTileIdTable，screenTileIdTable-&gt;map 代表著整個虛擬螢幕所對應的 tile id ，不過我們這邊是使用他的 map_xy 來取值，因為我們有他的 x,y 座標</p><p>取到正確 id 後，就根據 tile id 去 tilePatternMap 去取出 tileline 的兩個 byte了，然後再利用我們剛剛提到的function 把他們通通組合起來就可以了，這邊所有定位與計算的動作都是使用之前定義的 type 巧妙地閃過</p><p>比較特別的是， 如果 bg_and_window_tile_data_select == 0 的話，tileId 要減去 128，這是因為 tileId 的編號是從 0x8000 開始，每16 byte 一組。所以編到 0x8800 的時候，此時的 TileId 依然是 0x80，到了 0x9000 的時候，由於 u8 只能存 256 個號碼，所以這邊又變成 0，也就是即便他的 base address 是從 0x8800 開始的，tileId 編號規則也是相同的從 0x8000 開始編</p><p>當使用 0x8000 當作 base address 的時候，編號 0 ~ 0xFF 的範圍就是 0x8000 ~ 0x8FFF，當使用 0x8800 當作 base address 的時候， 0x8800 的那組 TileId 的編號依然是 0x80，反而是 0x9000 那組的編號是 0</p><p>所以當我們一旦使用 0x8800 當作 base address 的時候，我們的 tileId 反而要減掉 0x80，這樣才是正確的 array index ，當然加上 0x80 也是可以，因為運算過意思經過溢位其值是一樣的</p><hr><h2 id="畫出-window"><a href="#畫出-window" class="headerlink" title="畫出 window "></a>畫出 window </h2><p>也是利用類似方法，先取出 patternMap 與 screenTileIdMap之後，再查表即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void draw_window_line(eu8 screen_y) &#123;</span><br><span class="line">    eu8 scrolled_x &#x3D; LCD.wx - 7;</span><br><span class="line">    eu8 scrolled_y &#x3D; screen_y - LCD.wy;</span><br><span class="line"></span><br><span class="line">    if (scrolled_y &gt;&#x3D; SCREEN_HEIGHT) &#123; return; &#125;</span><br><span class="line"></span><br><span class="line">    TileIdMap_usp screenTileIdMap &#x3D; get_window_tile_id_map();</span><br><span class="line"></span><br><span class="line">    for (eu8 screen_x &#x3D; 0; screen_x &lt; SCREEN_WIDTH; screen_x++) &#123;</span><br><span class="line">        ScrollPx scroll_x &#x3D; &#123; .all &#x3D; scrolled_x + screen_x &#125;;</span><br><span class="line">        ScrollPx scroll_y &#x3D; &#123; .all &#x3D; scrolled_y &#125;;</span><br><span class="line">        draw_bg_window_line(screen_x, screen_y, scroll_x, scroll_y, screenTileIdMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="畫出-sprite"><a href="#畫出-sprite" class="headerlink" title="畫出 sprite "></a>畫出 sprite </h2><p>sprite 的畫法就單純很多，去 oam 把 40 個 sprite 取出來後，再根據每個所指定 tile id 畫到指定的 x，y 即可，這邊有幾點說明</p><ul><li>sprite 也有開關讓fw 決定要不要顯示它</li><li>一共最多要畫 40 個 sprite</li><li>sprite 所對應的 tilePatternMap 必須為 0x8000</li><li>OAM 有時候會要求畫兩個 tile 上去，他是以垂直的方式來畫</li><li>當pixel color 取出來的值為0的時候，就不去畫他，這樣可以做出 sprite 透明的效果</li><li>sprite x 與 sprite 要分別減掉固定值 8 與 16，代蓋是他們紀錄的點是 sprite 右下角那個點</li></ul><p>PS: 你可以試試看加上 if (px_data == 0) { continue; } 還有移掉她，對於畫面的改變為何</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">void draw_sprite(eu8 spriteNum) &#123;</span><br><span class="line">    Sprite_p sprite &#x3D; GET_SPRITE_PTR(spriteNum);</span><br><span class="line">    if (sprite-&gt;x &#x3D;&#x3D; 0 || sprite-&gt;x &gt;&#x3D; 168) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sprite-&gt;y &#x3D;&#x3D; 0 || sprite-&gt;y &gt;&#x3D; 160) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TilePatternMap_p tilePatternMap &#x3D; get_tile_data_table(1);</span><br><span class="line"></span><br><span class="line">    for (eu8 oam &#x3D; 0; oam &lt; (LCD_CTRL.obj_size+1); oam++) &#123;</span><br><span class="line">        TilePattern_p tile &#x3D; &amp;tilePatternMap-&gt;pattern_map[sprite-&gt;pattern_num + oam];</span><br><span class="line"></span><br><span class="line">        eu32 start_x &#x3D; sprite-&gt;x - 8;</span><br><span class="line">        eu32 start_y &#x3D; sprite-&gt;y - 16 + (oam * TILE_Y_PX);</span><br><span class="line"></span><br><span class="line">        for (eu8 y &#x3D; 0; y &lt; TILE_Y_PX; y++) &#123;</span><br><span class="line">            TileLine_p tile_line &#x3D; &amp;tile-&gt;line_map[y];</span><br><span class="line">            for (eu8 x &#x3D; 0; x &lt; TILE_X_PX; x++) &#123;</span><br><span class="line">                if (!is_pixel_on_screen(start_x + x, start_y + y)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (sprite-&gt;flags.priority) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                eu8 target_px_x &#x3D; !sprite-&gt;flags.flap_x ? x : TILE_X_PX - x - 1;</span><br><span class="line">                eu8 target_px_y &#x3D; !sprite-&gt;flags.flap_y ? y : TILE_Y_PX - y - 1;</span><br><span class="line">                eu8 screen_x &#x3D; (eu8)(start_x + target_px_x);</span><br><span class="line">                eu8 screen_y &#x3D; (eu8)(start_y + target_px_y);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                eu8 px_data &#x3D; get_pixel_data(tile_line-&gt;byte0, tile_line-&gt;byte1, target_px_x);</span><br><span class="line">                &#x2F;&#x2F; 0 is transparent</span><br><span class="line">                if (px_data &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                eu8 color &#x3D; get_sprite_palette(sprite-&gt;flags.palette_number, px_data);</span><br><span class="line">                write_screen_frame_buffer(screen_x, screen_y, color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write_sprites() &#123; </span><br><span class="line">    if (!LCD_CTRL.obj_display) &#123; </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line">    for (eu8 sprite_n &#x3D; 0; sprite_n &lt; TOTAL_SPRITE_CNT; sprite_n++) &#123; </span><br><span class="line">        draw_sprite(sprite_n); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>畫出 Sprite 與 之前畫 BG 與 Window 不同的是，Sprite 所使用的 tile 是固定的，不像是 BG 要不段的查表</p><hr><h1 id="接上顯示系統"><a href="#接上顯示系統" class="headerlink" title="接上顯示系統"></a>接上顯示系統</h1><p>我們使用 sdl 2 來當作顯示系統，照著 以下的 code 輸入即可，這邊會在最後一刻把 gb 的四種顏色，轉成 sdl 所顯示的 RGB 顏色，如果順利的話，就會顯示出遊戲畫面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*SetPixelsFun)(eu32 x, eu32 y, eu8 color);</span><br><span class="line"></span><br><span class="line">eu32 get_real_color(eu8 pixelColor) &#123;</span><br><span class="line">    &#x2F;&#x2F; for compile error</span><br><span class="line">    eu8 r &#x3D; 0;</span><br><span class="line">    eu8 g &#x3D; 0;</span><br><span class="line">    eu8 b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    switch (pixelColor) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            r &#x3D; g &#x3D; b &#x3D; 255;</span><br><span class="line">            break;  &#x2F;&#x2F; white</span><br><span class="line">        case 1:</span><br><span class="line">            r &#x3D; g &#x3D; b &#x3D; 170;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            r &#x3D; g &#x3D; b &#x3D; 85;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            r &#x3D; g &#x3D; b &#x3D; 0;</span><br><span class="line">            break;  &#x2F;&#x2F; black</span><br><span class="line">        default:</span><br><span class="line">            ASSERT_CODE(0, &quot;Wrong pixel color &#x3D; %X&quot;, pixelColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (r &lt;&lt; 16) | (g &lt;&lt; 8) | (b &lt;&lt; 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set_pixel(eu32 x, eu32 y, eu8 color) &#123;</span><br><span class="line">    g_sdlPixels[SCREEN_WIDTH * SDL_PIXEL_SIZE * y + x] &#x3D; get_real_color(color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set_pixels(eu8 frameBuffer[SCREEN_HEIGHT][SCREEN_WIDTH], SetPixelsFun set_pixel_fun) &#123;</span><br><span class="line">    for (eu8 y &#x3D; 0; y &lt; SCREEN_HEIGHT; y++) &#123;</span><br><span class="line">        for (eu8 x &#x3D; 0; x &lt; SCREEN_WIDTH; x++) &#123;</span><br><span class="line">            set_pixel_fun(x, y, frameBuffer[y][x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void draw_sdl2(eu8 frameBuffer[SCREEN_HEIGHT][SCREEN_WIDTH]) &#123;</span><br><span class="line">    process_events();</span><br><span class="line"></span><br><span class="line">    SDL_RenderClear(g_renderer);</span><br><span class="line"></span><br><span class="line">    void* pixelsPtr;</span><br><span class="line">    int pitch;</span><br><span class="line"></span><br><span class="line">    SDL_LockTexture(g_texture, NULL_PTR, &amp;pixelsPtr, &amp;pitch);</span><br><span class="line"></span><br><span class="line">    g_sdlPixels &#x3D;(uint32_t*)(pixelsPtr);</span><br><span class="line"></span><br><span class="line">    set_pixels(frameBuffer, set_pixel);</span><br><span class="line"></span><br><span class="line">    SDL_UnlockTexture(g_texture);</span><br><span class="line">    SDL_RenderCopy(g_renderer, g_texture, NULL_PTR, NULL_PTR);</span><br><span class="line">    SDL_RenderPresent(g_renderer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時你會發現，螢幕太小，我們要想辦法放大，所以我們做了一個放大的程式 set_large_pixels()，其策略是一個 1 * 1 的點，讓他變成 2 * 2，把原本的 function 替換成放大版的即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void set_large_pixels(eu32 x, eu32 y, eu8 color) &#123;</span><br><span class="line">    for (eu8 w &#x3D; 0; w &lt; SDL_PIXEL_SIZE; w++) &#123;</span><br><span class="line">        for (eu8 h &#x3D; 0; h &lt; SDL_PIXEL_SIZE; h++) &#123;</span><br><span class="line">            eu32 fin_x &#x3D; x * SDL_PIXEL_SIZE + w;</span><br><span class="line">            eu32 fin_y &#x3D; y * SDL_PIXEL_SIZE + h;</span><br><span class="line">            set_pixel(fin_x, fin_y, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣一來就可以顯示出較大的螢幕了，記得一開始的 init_sdl() 的參數也要一起替換喔</p><h1 id="最後"><a href="#最後" class="headerlink" title="最後"></a>最後</h1><p>其實這個顯示的系統一開始沒接觸過的可能會不太好懂，這也是我這篇的目的，希望能寫得更清楚一點，可以讓想要做模擬器的人不用在花太多精神在研究這種特殊的東西嚕</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Gameboy-的-tile-系統與繪圖&quot;&gt;&lt;a href=&quot;#Gameboy-的-tile-系統與繪圖&quot; class=&quot;headerlink&quot; title=&quot;Gameboy 的 tile 系統與繪圖&quot;&gt;&lt;/a&gt;Gameboy 的 tile 系統與繪圖&lt;/h1&gt;&lt;p&gt;接著要來做有關繪圖的部分，這部分說簡單也不簡單，說難也不會難，難的部分是因為我們沒有碰過 tile 系統，所以要花點時間去理解，當理解後，實作部分其實很簡單一點也不難，如果你還沒去看最前面介紹的影片，我建議你趕快去看，因為看完之後會比較好理解&lt;/p&gt;
&lt;p&gt;首先我再幫大家整理一下概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一個 tile 由 8*8 個 pixel 所組成&lt;/li&gt;
&lt;li&gt;GB 整個顯示的部分是 256 * 256 個 pixel ，換算成 tile 就是 32 * 32 個 tile, 在code 裡面我們會以 scroll_px_x, scroll_px_y 來表示&lt;ul&gt;
&lt;li&gt;好像有人稱作虛擬螢幕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但是  GB 能顯示的螢幕(screen)卻只有 160 * 144 個 pixel ，也就是說他只會顯示上述畫面的一部分&lt;ul&gt;
&lt;li&gt;他的用意在於，他可以利用這種窗口，去實現類似鏡頭平移的的功能，這邊的 demo 你可以在影片中看到&lt;/li&gt;
&lt;li&gt;對於螢幕的 x, y ，在code 裡面會以 screen_px_x 與 screen_px_y 來表示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;總結就是，cpu 內設計的螢幕結構是 256&lt;em&gt;256 的，但是你只能看到這 256&lt;/em&gt;256  的 160*144 ，&lt;ul&gt;
&lt;li&gt;這樣設計的原因就是他可以做出一些視覺的效果&lt;/li&gt;
&lt;li&gt;例如網球比賽的鏡頭，馬力歐跳躍時的畫面移動，或是橫向捲軸遊戲的效果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;像我對於這東西就困擾很久，想說這什麼鬼東西，為什麼任天堂的螢幕不弄得跟他內部一樣都是  256*256 等等，
反正你不要想得太複雜，以下做個比喻&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地上有個由 32 *32 個巧拼所組成的正方形背景拚圖，每個巧拼為 8 * 8 cm，所以整個拼背景圖大小為 256 cm * 256 cm&lt;/li&gt;
&lt;li&gt;然後你手上有個 160 cm * 144 cm 的白色方框，這個代表你所能看到的區域&lt;/li&gt;
&lt;li&gt;然後你試著把方框在那個拼圖上任意移動，然後觀察方框內的畫面，這個就像是GB 的畫面移動方式&lt;/li&gt;
&lt;li&gt;然後你在方框內平放一個 8 * 8 cm 的巧拼，上面畫有一個馬力歐，讓他在方框內任意移動，
當紙娃娃向右移動快移出方框的時候，你也同步的把方框往右移&lt;/li&gt;
&lt;li&gt;GB 的顯示系統大概就是這個樣子，拼圖代表 256 * 256 pixel 的虛擬螢幕(scroll)，巧拼代表 8 * 8  pixel 的 tile，方框代表 144* 160 pixel 的顯示螢幕(screen)，而馬力歐代表一個 sprite ，他由1個 or 2 個 tile 組成&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="C" scheme="http://wwssllabcd.github.io/tags/C/"/>
    
    <category term="Emulator" scheme="http://wwssllabcd.github.io/tags/Emulator/"/>
    
  </entry>
  
  <entry>
    <title>從零開始的 Gameboy 模擬器開發 -- Step 3</title>
    <link href="http://wwssllabcd.github.io/2021/02/11/how-to-build-a-gameboy-emulator-3/"/>
    <id>http://wwssllabcd.github.io/2021/02/11/how-to-build-a-gameboy-emulator-3/</id>
    <published>2021-02-10T16:24:46.000Z</published>
    <updated>2021-02-14T16:06:57.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中斷"><a href="#中斷" class="headerlink" title="中斷"></a>中斷</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中斷&quot;&gt;&lt;a href=&quot;#中斷&quot; class=&quot;headerlink&quot; title=&quot;中斷&quot;&gt;&lt;/a&gt;中斷&lt;/h1&gt;</summary>
      
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="C" scheme="http://wwssllabcd.github.io/tags/C/"/>
    
    <category term="Emulator" scheme="http://wwssllabcd.github.io/tags/Emulator/"/>
    
  </entry>
  
  <entry>
    <title>從零開始的 Gameboy 模擬器開發 -- Step 2</title>
    <link href="http://wwssllabcd.github.io/2021/02/10/how-to-build-a-gameboy-emulator-2/"/>
    <id>http://wwssllabcd.github.io/2021/02/10/how-to-build-a-gameboy-emulator-2/</id>
    <published>2021-02-09T16:24:46.000Z</published>
    <updated>2021-02-14T17:00:17.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建立-opcode-map"><a href="#建立-opcode-map" class="headerlink" title="建立 opcode map "></a>建立 opcode map </h1><p>在開始之前讀取第一道指令之前，我們要做一件很不有趣的事情，就是建立所有 op code 的 map</p><p>首先我們建立 opcode_map.c，裡面的內容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void not_support_cb_code() &#123; ASSERT_CODE(0, &quot;not support CB code&quot;); &#125;</span><br><span class="line">void not_support_op_code() &#123; ASSERT_CODE(0, &quot;not support op code&quot;); &#125;</span><br><span class="line"></span><br><span class="line">void op_00() &#123; not_support_op_code(); &#125;</span><br><span class="line">.......</span><br><span class="line">void op_FF() &#123; not_support_op_code(); &#125;</span><br><span class="line"></span><br><span class="line">void op_cb_00() &#123; not_support_cb_code(); &#125;</span><br><span class="line">.......</span><br><span class="line">void op_cb_FF() &#123; not_support_cb_code(); &#125;</span><br><span class="line"></span><br><span class="line">opcode_fun g_opcode_fun_map[0x100] &#x3D; &#123;</span><br><span class="line">    GEN_FUN_MAP(, 0), GEN_FUN_MAP(, 1), GEN_FUN_MAP(, 2), GEN_FUN_MAP(, 3),</span><br><span class="line">    GEN_FUN_MAP(, 4), GEN_FUN_MAP(, 5), GEN_FUN_MAP(, 6), GEN_FUN_MAP(, 7),</span><br><span class="line">    GEN_FUN_MAP(, 8), GEN_FUN_MAP(, 9), GEN_FUN_MAP(, A), GEN_FUN_MAP(, B),</span><br><span class="line">    GEN_FUN_MAP(, C), GEN_FUN_MAP(, D), GEN_FUN_MAP(, E), GEN_FUN_MAP(, F)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">opcode_fun g_opcode_cb_fun_map[0x100] &#x3D; &#123;</span><br><span class="line">    GEN_FUN_MAP(cb_, 0), GEN_FUN_MAP(cb_, 1), GEN_FUN_MAP(cb_, 2), GEN_FUN_MAP(cb_, 3),</span><br><span class="line">    GEN_FUN_MAP(cb_, 4), GEN_FUN_MAP(cb_, 5), GEN_FUN_MAP(cb_, 6), GEN_FUN_MAP(cb_, 7),</span><br><span class="line">    GEN_FUN_MAP(cb_, 8), GEN_FUN_MAP(cb_, 9), GEN_FUN_MAP(cb_, A), GEN_FUN_MAP(cb_, B),</span><br><span class="line">    GEN_FUN_MAP(cb_, C), GEN_FUN_MAP(cb_, D), GEN_FUN_MAP(cb_, E), GEN_FUN_MAP(cb_, F)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 GEN_FUN_MAP() macro 是幫你產生 op_00(), op_01 ... op_FF 的格式，因為一個一個打實在太累了，當然你有毅力我也不反對</p><a id="more"></a><p>這邊的重點放在兩個 array, 分別是 <code>opcode_fun g_opcode_fun_map[0x100]</code> 與 <code>opcode_fun g_opcode_cb_fun_map[0x100]</code>，也就是說，我們使用一個 function pointer 的 array，然後使用該 array 的 index 當作 op code 呼叫號碼，這樣就不用寫落落長的 switch case 了，有了 opcode 了，我們就可以開始 fetch 指令了。新增以下的 code 到 cpu.c 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">eu8 fetch(void) &#123;</span><br><span class="line">    eu8 val &#x3D; get_ram(REG_PC);</span><br><span class="line">    INC_REG(pc);</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void execute_opcode() &#123;</span><br><span class="line">    eu8 opcode &#x3D; fetch();</span><br><span class="line">    opcode_fun_usp op_map &#x3D; g_opcode_fun_map;</span><br><span class="line">    bool is_cb_cmd &#x3D; false;</span><br><span class="line"></span><br><span class="line">    if (opcode &#x3D;&#x3D; PREFIX_CMD) &#123;</span><br><span class="line">        opcode &#x3D; fetch();</span><br><span class="line">        op_map &#x3D; g_opcode_cb_fun_map;</span><br><span class="line">        is_cb_cmd &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    op_map[opcode]();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 cpu_tick() &#123;</span><br><span class="line">    return execute_opcode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tick() &#123;</span><br><span class="line">    cpu_tick();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void run_cpu() &#123;</span><br><span class="line">    while (g_cpu.running) &#123;</span><br><span class="line">        tick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fetch() 其實就是以 pc 當作記憶體位置，然後把該記憶體位置的值取出來，取出來後 pc 就要步進1</li><li>Gameboy 的 op code 有兩種，一種是 normal 的，一種是老任新增的 -- 以 0xCB 做前綴的 external op code ，所以我們這邊一旦遇到 cb cmd 的時候，就使用 cb cmd 的 function array，反之則用正常的 function array，而遇到 0xCB cmd 則必須要在 fatch 一次，以便讀出真正的 cb cmd opcode</li></ul><hr><h1 id="boot-code-的選擇"><a href="#boot-code-的選擇" class="headerlink" title="boot code 的選擇"></a>boot code 的選擇</h1><p>好，在開始之前，還有一件事很重要就是，這顆 cpu 的 pc 是從 0 開始讀，然後我們又把 game rom 放到 0 ~ 32k 的地方，理論上 pc = 0 開始讀的位置是 game rom 的第 0 byte，但是呢，如果你有注意到的話，其實 address 0 ~ 255 這個位置會跟 boot rom 重疊，也就是說 boot rom 與 game com 在 address 0 ~ 255 byte 的地方產生了 overlay</p><p>那既然 overlay 了，那我去讀 address 0，到底是讀到的是 game rom 的第一個 byte，還是 boot rom 的第一個 byte 呢? 為了讓 fw 可以選擇使用哪個 code，所以有個 0xFF50 這個 boot_rom_disable 的 register  會做切換的功能，當我們要存取 0 ~ 255 的位置時，就要先去看一下這個 reg，當 boot_rom_disable 設為 0 時，我們的 mmu 就要送出 boot rom 的值，反之就會讀到 game rom 的位置，這個 reg 預設是讀 boot rom， 而一旦當要開始執行遊戲畫面時，fw 就會把這個 register 切到 1，這樣 mmu 就必須把這塊記憶體 mapping 到 game rom 去</p><p>那這個 isp 的功能要實作也很簡單，就是在額外宣告一個 eu8 boot_rom_dmg[0x100] ，並且在 get_ram_ptr 動手腳就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eu8_p get_ram_ptr(RamAddr address) &#123;</span><br><span class="line">    if (address &lt; BOOT_ROM_LENGTH) &#123;</span><br><span class="line">        if (g_zero_page-&gt;boot_rom_disable &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return (eu8_p)&amp;boot_rom_dmg[address];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (eu8_p)&amp;g_ram[address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 ok 之後，我們就可以正式的 fatch 第一個指令了，此時順利的話，你會 fetch 第一個 op code ，這個是從 boot rom 提出來的，號碼為 0x31，此時如果繼續執行的話會碰到 error ，因為我們在所有沒有實作的 cmd 裡面都加上了 not_support_op_code()，進而會引發 assert，所以我們的目標就是把所有的 cmd 給做出來</p><hr><h1 id="建立起-256-256-個-opcode"><a href="#建立起-256-256-個-opcode" class="headerlink" title="建立起 256 + 256 個 opcode"></a>建立起 256 + 256 個 opcode</h1><p>這邊雖然一共有 normal op + external op 最多 512 道指令，但你如果仔細觀察的話，其實很多指令都相同，只是來源 register 或是目標 register 不同，我的建議是按照手冊一個一個做下去，這樣在實作的時候也比較不會亂</p><p>回到教學這邊，雖然每個 cmd 都是短短的，即便如此，若講解每道指令的話會使用很多篇幅，所以這邊只會挑重點講</p><p>首先我們先做點前置作業，在 cpu.c 中加入等下會用到的 function，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void disable_halt() &#123;</span><br><span class="line">    g_cpu.halt &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void enable_halt() &#123;</span><br><span class="line">    g_cpu.halt &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stack_push(WordReg_p reg) &#123;</span><br><span class="line">    DEC_REG(sp);</span><br><span class="line">    set_ram(REG_SP, REG_VAL(REG_HIGH(reg)));</span><br><span class="line">    DEC_REG(sp);</span><br><span class="line">    set_ram(REG_SP, REG_VAL(REG_LOW(reg)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stack_pop(WordReg_p reg) &#123;</span><br><span class="line">    REG_VAL(REG_LOW(reg)) &#x3D; get_ram(REG_SP);</span><br><span class="line">    INC_REG(sp);</span><br><span class="line">    REG_VAL(REG_HIGH(reg)) &#x3D; get_ram(REG_SP);</span><br><span class="line">    INC_REG(sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu16 fetch_word() &#123;</span><br><span class="line">    eu16 val &#x3D; 0;</span><br><span class="line">    val |&#x3D; fetch();</span><br><span class="line">    val |&#x3D; fetch() &lt;&lt; 8;</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 cpu_tick() &#123;</span><br><span class="line">    if (g_cpu.halt) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return execute_opcode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到其實實作的方式都很簡單， fetch_word 就是使用 fetch 兩次，而 stack_push 就是先把 sp 減一後，在把 Word Reg 的 High byte 取值後填入 sp 所指的位置，stack 的操作大多是以 WordRegister 的方式而 stack_pop 就是反過來做，此外，我們也增加了 halt 的 function ，並在原本的 cpu_tick() 中，加入 check g_cpu.halt 來模擬 halt 的指令</p><hr><h2 id="LD-r1-r2-指令"><a href="#LD-r1-r2-指令" class="headerlink" title="LD r1, r2 指令"></a>LD r1, r2 指令</h2><p>這個指令是最多使用的，從 op code 0x40~0x7F 都是用它做出來的，所以一下子 64 個指令就完成了，他的實作方式也很簡單，就是把 r2 這個 byte ，設給 r1 這個 byte register</p><p>而有時候設值目標不是 register ，而是記憶體位置，所以這邊就又弄一個 opcode_ld_r1_r2_addr() ，C 不支援同名異式的 Polymorphism ，所以抽象表現力就比較差一點，不過對於這個小專案來說還是可以忍受的範圍內就是了，當然 reg 與記憶體位置你也可以看成都是這隻模擬器的記憶體位置，真的發狠起來要搞合併也不是不行，只是這樣 code 會變成更難理解，這樣就本末倒置了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void opcode_ld_r1_r2(ByteReg_p r1, eu8 r2) &#123;</span><br><span class="line">    REG_VAL(r1) &#x3D; r2;</span><br><span class="line">&#125;</span><br><span class="line">void opcode_ld_r1_r2_addr(RamAddr address, eu8 r2) &#123;</span><br><span class="line">    set_ram(address, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊也稍微貼一下他在 opcode_map.c 中的樣子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void op_40() &#123; opcode_ld_r1_r2(b, REG_B); &#125;</span><br><span class="line">void op_41() &#123; opcode_ld_r1_r2(b, REG_C); &#125;</span><br><span class="line">void op_42() &#123; opcode_ld_r1_r2(b, REG_D); &#125;</span><br><span class="line">void op_43() &#123; opcode_ld_r1_r2(b, REG_E); &#125;</span><br><span class="line">void op_44() &#123; opcode_ld_r1_r2(b, REG_H); &#125;</span><br><span class="line">void op_45() &#123; opcode_ld_r1_r2(b, REG_L); &#125;</span><br><span class="line">void op_46() &#123; opcode_ld_r1_r2(b, RAM_VAL_HL); &#125;</span><br><span class="line">....</span><br><span class="line">void op_48() &#123; opcode_ld_r1_r2(c, REG_B); &#125;</span><br><span class="line">void op_49() &#123; opcode_ld_r1_r2(c, REG_C); &#125;</span><br><span class="line">void op_4A() &#123; opcode_ld_r1_r2(c, REG_D); &#125;</span><br><span class="line">void op_4B() &#123; opcode_ld_r1_r2(c, REG_E); &#125;</span><br><span class="line">void op_4C() &#123; opcode_ld_r1_r2(c, REG_H); &#125;</span><br><span class="line">void op_4D() &#123; opcode_ld_r1_r2(c, REG_L); &#125;</span><br><span class="line">void op_4E() &#123; opcode_ld_r1_r2(c, RAM_VAL_HL); &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="bit-b-r，res-b-r-與-set-b-r-指令"><a href="#bit-b-r，res-b-r-與-set-b-r-指令" class="headerlink" title="bit b, r，res b, r 與 set b, r 指令"></a>bit b, r，res b, r 與 set b, r 指令</h2><p>在 cb cmd 中，也是有跟 opcode_ld_r1_r2 一樣廣泛使用的 cmd ，那就是 opcode_cb_bit_b_r() ， opcode_cb_res_b_r()與 opcode_cb_set_b_r()，他們也是各占 64 個 opcode，算是很補的 cmd， 作法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void opcode_cb_bit_b_r(eu8 val, eu8 bit) &#123;</span><br><span class="line">    set_z(CHECK_BIT(val, bit) &#x3D;&#x3D; 0);</span><br><span class="line">    set_n(false);</span><br><span class="line">    set_h(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_cb_res_b_r(ByteReg_p reg, eu8 bit) &#123;</span><br><span class="line">    CLEAR_BIT(REG_VAL(reg), bit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_cb_res_b_r_addr(RamAddr addr, eu8 bit) &#123;</span><br><span class="line">    eu8 res &#x3D; get_ram(addr);</span><br><span class="line">    CLEAR_BIT(res, bit);</span><br><span class="line">    set_ram(addr, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_cb_set_b_r(ByteReg_p reg, eu8 bit) &#123;</span><br><span class="line">    SET_BIT(REG_VAL(reg), bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這3個 function 只有  opcode_cb_bit_b_r 需要注意的就是，你必須要開始設定 flags，不過這3個 function 的 flag 比較沒那麼複雜，我挑一個比較複雜的運算來討論一下</p><hr><h2 id="add-a-n-與-adc-a-n-指令"><a href="#add-a-n-與-adc-a-n-指令" class="headerlink" title="add_a_n 與 adc_a_n 指令"></a>add_a_n 與 adc_a_n 指令</h2><p>以下是 opcode 0x80 ~ 0x87 的 add_a_n 與 opcode 0x88 ~ 0x8F 的 adc_a_n 的實作，順帶一提的是，這邊 function 的命名規則是，如果是對應到 op code 的話就會以 &quot;opcode_ &quot; 為開頭，如果沒這開頭的就都是 base function 了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bool check_hc_add(eu32 summand, eu32 addend, eu32 mask) &#123;</span><br><span class="line">    return ((summand &amp; mask) + (addend &amp; mask) &gt; mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu32 add_a_b(eu32 summand, eu32 addend, eu32 mask) &#123;</span><br><span class="line">    eu32 result &#x3D; summand + addend;</span><br><span class="line"></span><br><span class="line">    if (mask &#x3D;&#x3D; 0xFF) &#123;</span><br><span class="line">        set_z((result &amp; mask) &#x3D;&#x3D; 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    set_n(false);</span><br><span class="line">    set_h(check_hc_add(summand, addend, mask &gt;&gt; 4));</span><br><span class="line">    set_c(result &gt; mask);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_add_a_n(eu8 n) &#123;</span><br><span class="line">    REG_VAL(a) &#x3D; (eu8)add_a_b(REG_VAL(a), n, 0xFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_adc_a_n(eu8 n) &#123;</span><br><span class="line">    opcode_add_a_n(n + flags-&gt;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>opcode_adc_a_n 與 opcode_add_a_n 其實是由 add_a_b 組成，這邊可看到 add 指令對 flag 的變化，在大部分的狀況規則整理如下</p><ul><li>flag-&gt;z: 是用來判斷運算結果是不是為0</li><li>flag-&gt;n: 代表是不是減法</li><li>flag-&gt;h: 代表 bit 4 有沒有產生變化，也就是 halt carry 的意思</li><li>flag-&gt;c: 就是代表 carry，也就是運算結果本身有無溢位</li></ul><p>對於 flag-&gt;c 來說，要判斷兩個值相加是否 overflow，所以就直接設了一個 eu32 result 的變數來存放相加過的值，並且判斷相加後是否超過 0x100 即可，反正我們是 32 位元的 cpu，要觀察兩個 8 bit regsiter 相加後是否溢位其實是一塊小蛋糕</p><p>這邊要注意的是, add u8 與 add u16 對於 flag 的設定有一點點不同</p><hr><h2 id="rlc-指令"><a href="#rlc-指令" class="headerlink" title="rlc 指令"></a>rlc 指令</h2><p>除了加/減法會影響到 flag 外，它們也會拿去支援一些 cmd，可說是多才多藝，例如 cb cmd 的 opcde 0x00 ~ 0x07 的 rlc，他的內容是把輸入值左移一位，那這樣最高位就會消失，不過這個指令會把最高位的 bit，保存在 flag-&gt;c 中，不過這個指令有趣的地方就在於它其實也把消失的 bit，又加回到 bit 0 的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">eu8 rlx_n(eu8 value, eu8 plus) &#123;</span><br><span class="line">    eu8 result &#x3D; (value &lt;&lt; 1) | plus;</span><br><span class="line"></span><br><span class="line">    set_z(result &#x3D;&#x3D; 0);</span><br><span class="line">    set_n(false);</span><br><span class="line">    set_h(false);</span><br><span class="line">    set_c(CHECK_BIT(value, 7));</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_cb_rlc_n(ByteReg_p reg) &#123;</span><br><span class="line">    eu8 plus &#x3D; CHECK_BIT(REG_VAL(reg), 7);</span><br><span class="line">    REG_VAL(reg) &#x3D; rlx_n(REG_VAL(reg), plus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_cb_rlc_n_addr(RamAddr addr) &#123;</span><br><span class="line">    eu8 plus &#x3D; CHECK_BIT(get_ram(addr), 7);</span><br><span class="line">    set_ram(addr, rlx_n(get_ram(addr), plus));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="jr-cc-n-指令"><a href="#jr-cc-n-指令" class="headerlink" title="jr cc, n 指令"></a>jr cc, n 指令</h2><p>最後講一下 opcode_jr_cc_n()，他其實是用 jr_n 組合出來的，特別要提的是，如果判斷是不需要 jump 的話，PC 也必須要往前移動一個，所以這邊就使用 INC_REG(pc) 來達到這個目的</p><p>而跳轉命令的實作也很簡單，就是改變 pc 值就可以了，所以 jr_n 指令的作法就是把現在的 pc 加上一個 offset，而這個 offset 的是從 fetch 而來，不過 jr_n 這邊是有順序性的，你一定要先 fetch 才可以做 offset 的動作，因為 fetch 會改變 pc 的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void opcode_jr_n() &#123;</span><br><span class="line">    es8 offset &#x3D; fetch();</span><br><span class="line">    REG_PC +&#x3D; offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_jr_cc_n(bool condition) &#123;</span><br><span class="line">    if (condition) &#123;</span><br><span class="line">        opcode_jr_n();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        INC_REG(pc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="di-與-ei-指令"><a href="#di-與-ei-指令" class="headerlink" title="di 與 ei 指令"></a>di 與 ei 指令</h2><p>再來比較特別的就是 di 與 ei，這個是打開 interrupt，我的感覺有點像是 8051 中的 EA=1 的感覺</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void opcode_di() &#123;</span><br><span class="line">    g_cpu.enable_interrupt &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_ei() &#123;</span><br><span class="line">    g_cpu.enable_interrupt &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其實 op code 大概就是這樣，真正需要認真實作的部分約100行左右，除了一個叫 daa 指令之外, 剩下的大部分都很簡單，就是組合再組合就搞定了，接下來下一篇就是要寫 gb 的 video 與 tile 系統了</p><h1 id="其他的功能"><a href="#其他的功能" class="headerlink" title="其他的功能"></a>其他的功能</h1><p>有一個比較特別的東西要拉出來講，就是 Z80 在 0xFF46 有提供一個 DMA 的功能，當那個記憶體被寫入的時候，我們就要執行 dma 的功能，他的 code 也很簡單</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">void start_hw_dma(eu8 byte) &#123;</span><br><span class="line">    RamAddr base &#x3D; byte * 0x100;</span><br><span class="line">    for (eu8 i &#x3D; 0x0; i &lt; 0xA0; i++) &#123;</span><br><span class="line">        RamAddr src &#x3D; base + i;</span><br><span class="line">        RamAddr dst &#x3D; SPRITE_MAP_START_ADDR + i;</span><br><span class="line">        set_ram(dst, get_ram(src));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 get_ram(RamAddr addr) &#123;</span><br><span class="line">    if (addr &#x3D;&#x3D; IO_P1) &#123;</span><br><span class="line">        return input_read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fix 0xFF</span><br><span class="line">    if (addr &#x3D;&#x3D; IO_SERIAL) &#123;</span><br><span class="line">        return 0xFF;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; DMA, fix 0</span><br><span class="line">    if (addr &#x3D;&#x3D; IO_DMA) &#123;</span><br><span class="line">        return 0x0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((0xFEA0 &lt;&#x3D; addr) &amp;&amp; (addr &lt; 0xFF00)) &#123;</span><br><span class="line">        return 0xFF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (*get_ram_ptr(addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set_ram(RamAddr addr, eu8 value) &#123;</span><br><span class="line">    &#x2F;&#x2F;can not write when Non-MBC mode </span><br><span class="line">    if (addr &lt; 0x8000) &#123;</span><br><span class="line">        PRINTF_ALWAYS(&quot;inhibit write rom addr&#x3D;%X, val&#x3D;%X&quot;, addr, value);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; debug: workaround</span><br><span class="line">    if (addr &#x3D;&#x3D; IO_TIMER_MODULE) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (addr &#x3D;&#x3D; IO_TIMER_CTRL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; start DMA</span><br><span class="line">    if (addr &#x3D;&#x3D; IO_DMA) &#123;</span><br><span class="line">        start_hw_dma(value);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (*get_ram_ptr(addr)) &#x3D; value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fw 會寫入一個 byte，這個 byte 就代表 dma 的來源，而 DMA 的目的地就是 0xFE00，這是固定的，般的長度是 0xA0，也是固定的</p><h1 id="如何-Debug"><a href="#如何-Debug" class="headerlink" title="如何 Debug "></a>如何 Debug </h1><p>其實剩下的指令都很短，也不複雜，但就是多，東西一多起來就很難不出錯，把每個步驟執行後的每個 register 都印出來是一個好方法，不過即便如此，光是開機到開頭動畫，可能就會執行 30~40 萬筆指令，若把所有的東西都寫進 log 中，log 會很龐大，所以我們會需要一些有效率的 debug 方式，新增一個 debug.c 並加入以下的 code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#define START_CNT (0x0)</span><br><span class="line">#define END_CNT   (0x0)</span><br><span class="line"></span><br><span class="line">void print_ram(RamAddr ptr, eu32 len) &#123;</span><br><span class="line">   print_ram_base(ptr, len, get_ram);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set_debug_flag() &#123;</span><br><span class="line">    if ((START_CNT &lt;&#x3D; g_cmdCnt) &amp;&amp; (g_cmdCnt &lt; END_CNT)) &#123;</span><br><span class="line">        g_debug &#x3D; true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        g_debug &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    if (g_cmdCnt &lt; START_CNT) &#123;</span><br><span class="line">        if ((g_cmdCnt % 0x1000) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            g_debug &#x3D; true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">            g_debug &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show_reg_ram(bool is_cb_cmd, eu8 opcode, eu8 clock) &#123;</span><br><span class="line">    if (is_cb_cmd) &#123;</span><br><span class="line">        printf(&quot;\n\nccnt&#x3D;%X, cbc&#x3D;%02X, &quot;, g_cmdCnt, opcode);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;\n\nccnt&#x3D;%X, opc&#x3D;%02X, &quot;, g_cmdCnt, opcode);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;af&#x3D;%04X, bc&#x3D;%04X, de&#x3D;%04X, hl&#x3D;%04X, pc&#x3D;%04X, sp&#x3D;%04X, clk&#x3D;%X\n&quot;, af-&gt;all, bc-&gt;all, de-&gt;all, hl-&gt;all, pc-&gt;all, sp-&gt;all, clock);</span><br><span class="line"></span><br><span class="line">    print_ram(0x0, 0x10);</span><br><span class="line">    print_ram(0x100, 0x10);</span><br><span class="line">    print_ram(0x2000, 0x10);</span><br><span class="line">    print_ram(0x4000, 0x10);</span><br><span class="line">    print_ram(0x8000, 0x10);</span><br><span class="line">    print_ram(0x9800, 0x10);</span><br><span class="line">    print_ram(0xFE00, 0x10);</span><br><span class="line">    print_ram(0xFF00, 0x10);</span><br><span class="line">    print_ram(0xFF40, 0x11);</span><br><span class="line">    print_ram(0xFFA0, 0x10);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void debug_show_reg_ram(bool is_cb_cmd, eu8 opcode, eu8 clock) &#123;</span><br><span class="line">    set_debug_flag();</span><br><span class="line">    if (g_debug) &#123;</span><br><span class="line">        show_reg_ram(is_cb_cmd, opcode, clock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們把 debug code 集中在 debug.c 一起管理，盡量不要去汙染到原本的 code</p><p>這邊會使用兩種印指令的方式，一種是每隔 0x1000 就印一次，一種是指定區域印，這有個好處就是，你每次比較的時候，都可以知道錯誤大概在哪個區間，然後知道區間之後，再用詳細印的方式，就可以知道是哪一筆出錯了， log 也部會太大</p><p>把印 register 的指令插入到 execute_opcode 內，這樣你就可以得到每次執行指令後，register 的變化了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">eu8 execute_opcode() &#123;</span><br><span class="line">    eu8 opcode &#x3D; fetch();</span><br><span class="line">    </span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">    opcodeFunMap[opcode]();</span><br><span class="line">    debug_show_reg_ram(is_cb_cmd, opcode, clock);</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    return clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然後你應該可以找一個 GB Emu project，讓他也印出相同的東西，跟你的 log 一比，很快就會知道你錯在哪裡</p><p><a href="https://wwssllabcd.github.io/2021/02/12/how-to-build-a-gameboy-emulator-3/">從零開始的 Gameboy 模擬器開發 -- Step 3 </a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;建立-opcode-map&quot;&gt;&lt;a href=&quot;#建立-opcode-map&quot; class=&quot;headerlink&quot; title=&quot;建立 opcode map &quot;&gt;&lt;/a&gt;建立 opcode map &lt;/h1&gt;&lt;p&gt;在開始之前讀取第一道指令之前，我們要做一件很不有趣的事情，就是建立所有 op code 的 map&lt;/p&gt;
&lt;p&gt;首先我們建立 opcode_map.c，裡面的內容如下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void not_support_cb_code() &amp;#123; ASSERT_CODE(0, &amp;quot;not support CB code&amp;quot;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void not_support_op_code() &amp;#123; ASSERT_CODE(0, &amp;quot;not support op code&amp;quot;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void op_00() &amp;#123; not_support_op_code(); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void op_FF() &amp;#123; not_support_op_code(); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void op_cb_00() &amp;#123; not_support_cb_code(); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void op_cb_FF() &amp;#123; not_support_cb_code(); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;opcode_fun g_opcode_fun_map[0x100] &amp;#x3D; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(, 0), GEN_FUN_MAP(, 1), GEN_FUN_MAP(, 2), GEN_FUN_MAP(, 3),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(, 4), GEN_FUN_MAP(, 5), GEN_FUN_MAP(, 6), GEN_FUN_MAP(, 7),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(, 8), GEN_FUN_MAP(, 9), GEN_FUN_MAP(, A), GEN_FUN_MAP(, B),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(, C), GEN_FUN_MAP(, D), GEN_FUN_MAP(, E), GEN_FUN_MAP(, F)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;opcode_fun g_opcode_cb_fun_map[0x100] &amp;#x3D; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(cb_, 0), GEN_FUN_MAP(cb_, 1), GEN_FUN_MAP(cb_, 2), GEN_FUN_MAP(cb_, 3),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(cb_, 4), GEN_FUN_MAP(cb_, 5), GEN_FUN_MAP(cb_, 6), GEN_FUN_MAP(cb_, 7),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(cb_, 8), GEN_FUN_MAP(cb_, 9), GEN_FUN_MAP(cb_, A), GEN_FUN_MAP(cb_, B),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(cb_, C), GEN_FUN_MAP(cb_, D), GEN_FUN_MAP(cb_, E), GEN_FUN_MAP(cb_, F)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中 GEN_FUN_MAP() macro 是幫你產生 op_00(), op_01 ... op_FF 的格式，因為一個一個打實在太累了，當然你有毅力我也不反對&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="C" scheme="http://wwssllabcd.github.io/tags/C/"/>
    
    <category term="Emulator" scheme="http://wwssllabcd.github.io/tags/Emulator/"/>
    
  </entry>
  
  <entry>
    <title>從零開始的 Gameboy 模擬器開發 -- Step 1</title>
    <link href="http://wwssllabcd.github.io/2021/02/08/how-to-build-a-gameboy-emulator-1/"/>
    <id>http://wwssllabcd.github.io/2021/02/08/how-to-build-a-gameboy-emulator-1/</id>
    <published>2021-02-07T16:24:46.000Z</published>
    <updated>2021-02-13T14:01:27.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建立硬體描述"><a href="#建立硬體描述" class="headerlink" title="建立硬體描述"></a>建立硬體描述</h1><p>我們首先對 cpu 做描述， 先介紹 LR35902 這顆 cpu 其中的 4 個 word Register(Register，以後均簡稱 Reg) 分別為 <code>AF，BC，DE，HL</code>，這 4 個 word reg，比較特別的是，它們個別又可以拆成 byte reg ，例如 AF 就可以拆成兩個 byte reg <code>A(accumulator)</code>與 <code>F(Flags)</code> 來使用的，或者是合併讀取，例如 HL 常常當作 ram address 使用</p><p>到這邊如果你覺得陌生的話，建議你可以去惡補一下 cpu 暫存器的知識</p><p>考量 reg 可以分開讀取，或是合併讀取的特性，所以我們需要建立某種的描述，是可以分開，也可以合併的讀寫，翻翻 C 的手冊，發現使用 union 就可以達到這種目的了，所以我們使用 typedef 建立起對 byte reg 與 wordd reg 的描述</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">typedef eu16 RamAddr;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    eu8 all;</span><br><span class="line">&#125;ByteReg;</span><br><span class="line">ERIC_GEN_POINTER_TYPE(ByteReg);</span><br><span class="line"></span><br><span class="line">typedef union &#123;</span><br><span class="line">    eu16 all;</span><br><span class="line">    struct &#123;</span><br><span class="line">        ByteReg low;</span><br><span class="line">        ByteReg high;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;WordReg;</span><br><span class="line">ERIC_GEN_POINTER_TYPE(WordReg);</span><br><span class="line"></span><br><span class="line">typedef union &#123;</span><br><span class="line">    eu8 all;</span><br><span class="line">    struct &#123;</span><br><span class="line">        eu8 : 4;</span><br><span class="line">        eu8 c : 1;</span><br><span class="line">        eu8 h : 1;</span><br><span class="line">        eu8 n : 1;</span><br><span class="line">        eu8 z : 1;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;FlagReg;</span><br><span class="line">ERIC_GEN_POINTER_TYPE(FlagReg);</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        WordReg af;</span><br><span class="line">        struct &#123;</span><br><span class="line">            FlagReg f;</span><br><span class="line">            ByteReg a;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    union &#123;</span><br><span class="line">        WordReg bc;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ByteReg c;</span><br><span class="line">            ByteReg b;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    union &#123;</span><br><span class="line">        WordReg de;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ByteReg e;</span><br><span class="line">            ByteReg d;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    union &#123;</span><br><span class="line">        WordReg hl;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ByteReg l;</span><br><span class="line">            ByteReg h;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    WordReg sp;</span><br><span class="line">    WordReg pc;</span><br><span class="line"></span><br><span class="line">    bool halt;</span><br><span class="line">    bool running;</span><br><span class="line">    bool enableInterrupt;</span><br><span class="line"></span><br><span class="line">    eu32 clockCnt;</span><br><span class="line">&#125;Cpu;</span><br><span class="line">ERIC_GEN_POINTER_TYPE(Cpu);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到 word reg 是由兩個 byte reg 來組成的，而她又有一個 all 的屬性，是可以存取本身的 word 的值，剛好符合我們的需求，而我們把 word reg 與 byte reg 的取值變數全部都命名為 all，因為這樣會比較有一致性，當你需要存取不管是 ByteReg 或者是 WordReg，一律都使用 all 就可以存取了，這樣一來我們就能得到一個通用的取值的方法</p><p>其中的 ERIC_GEN_POINTER_TYPE 的 Macro 他會幫你產生 xxx_p, xxx_sp, xxx_usp 的 type，例如 <code>Cpu_usp cpu</code> 就會等同於 <code>Cpu* cpu</code> 的意思，另外，cpu struct 方面，我們也建立了 SP, PC, 的 Word register ，此外也建立一些變數，例如 </p><ul><li>halt 是給 halt 指令使用,</li><li>running 是開/關模擬器使用</li><li>enable_interrupt 是用來支援 ei 與 di 命令，它給我的感覺很像是 8051 中的 EA</li><li>clock_cnt 是用來模擬 cpu 內部的 clock，這個 clock 會跟產生畫面有關係</li></ul><p>這邊有個比較特別的 FlagReg_p，他其實就 AF 裡面的 F，又稱為 flags，他只有 4 個 bit 是有用的，所以我們使用分號的方式把那幾個 flag 都限定為 1 bit，並且把 low nibble bit 都遮掉</p><hr><p>有了一個 Cpu type 後，我們就可以建立一個全域變數 g_cpu 了，這邊我們全域變數一律使用 <code>g_</code> 開頭，我們只有針對全域變數使用匈牙利命名法外，其他情況則不使用，方便我們對全域變數的管制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Cpu g_cpu &#x3D; &#123;</span><br><span class="line">    .af &#x3D; 0,</span><br><span class="line">    .bc &#x3D; 0,</span><br><span class="line">    .de &#x3D; 0,</span><br><span class="line">    .hl &#x3D; 0,</span><br><span class="line">    .sp &#x3D; 0,</span><br><span class="line">    .pc &#x3D; 0,</span><br><span class="line"></span><br><span class="line">    .halt &#x3D; false,</span><br><span class="line">    .running &#x3D; true,</span><br><span class="line">    .enableInterrupt &#x3D; false,</span><br><span class="line"></span><br><span class="line">    .clockCnt &#x3D; 0,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>為了方便起見，我們也對比較常用的 register 建立對應的全域變數，可以讓我們之後在寫 opcode 的時候比較直覺一點，也可以少打幾個字，這邊的全域變數又都沒有加 <code>g_</code> ，直接光速打臉上面的原則，原因是加上去真的很醜，所以這邊會有個 trade off，反正我們都知道 af 是全域的 Register 就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WordReg_p af &#x3D; &amp;g_cpu.af;</span><br><span class="line">WordReg_p bc &#x3D; &amp;g_cpu.bc;</span><br><span class="line">WordReg_p de &#x3D; &amp;g_cpu.de;</span><br><span class="line">WordReg_p hl &#x3D; &amp;g_cpu.hl;</span><br><span class="line">WordReg_p sp &#x3D; &amp;g_cpu.sp;</span><br><span class="line">WordReg_p pc &#x3D; &amp;g_cpu.pc;</span><br><span class="line"></span><br><span class="line">ByteReg_p a &#x3D; &amp;g_cpu.a;</span><br><span class="line">FlagReg_p flags &#x3D; &amp;g_cpu.f;</span><br><span class="line">ByteReg_p b &#x3D; &amp;g_cpu.b;</span><br><span class="line">ByteReg_p c &#x3D; &amp;g_cpu.c;</span><br><span class="line">ByteReg_p d &#x3D; &amp;g_cpu.d;</span><br><span class="line">ByteReg_p e &#x3D; &amp;g_cpu.e;</span><br><span class="line">ByteReg_p h &#x3D; &amp;g_cpu.h;</span><br><span class="line">ByteReg_p l &#x3D; &amp;g_cpu.l;</span><br></pre></td></tr></table></figure><p>我們故意地把所有的 register 都變成了 pointer 型態，原因是要統一存取的格式，例如我今天要取一個 byre reg 與 word reg 的方式都是使用 reg-&gt;all，而不需要去想說到底要使用 .all 還是 -&gt;all</p><hr><p>所以我們也建立一些對 flags 設定的方式，如下所示，而其中的 SET_FLAG 只是幫你把 bool 轉成 1 or 0 而已，如果是 true，他就會回傳1，反之則0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void set_z(bool val) &#123;</span><br><span class="line">    flags-&gt;z &#x3D; SET_FLAG(val);</span><br><span class="line">&#125;</span><br><span class="line">void set_h(bool val) &#123;</span><br><span class="line">    flags-&gt;h &#x3D; SET_FLAG(val);</span><br><span class="line">&#125;</span><br><span class="line">void set_n(bool val) &#123;</span><br><span class="line">    flags-&gt;n &#x3D; SET_FLAG(val);</span><br><span class="line">&#125;</span><br><span class="line">void set_c(bool val) &#123;</span><br><span class="line">    flags-&gt;c &#x3D; SET_FLAG(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下來建立一些 macro 也是讓我們可以使用比較直覺的方式去存取 Register 的值，而不是依賴 -&gt;all 或是 -&gt;high 這種特定的方式讀取，我們可以利用 macro 去隱藏底層的實作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#define REG_VAL(REG)       ((REG)-&gt;all)</span><br><span class="line"></span><br><span class="line">#define INC_REG(REG)       (REG_VAL(REG)++)</span><br><span class="line">#define DEC_REG(REG)       (REG_VAL(REG)--)</span><br><span class="line"></span><br><span class="line">#define REG_HIGH(REG)      (&amp;(REG)-&gt;high)</span><br><span class="line">#define REG_LOW(REG)       (&amp;(REG)-&gt;low)</span><br><span class="line"></span><br><span class="line">#define REG_A              REG_VAL(a)</span><br><span class="line">#define REG_B              REG_VAL(b)</span><br><span class="line">#define REG_C              REG_VAL(c)</span><br><span class="line">#define REG_D              REG_VAL(d)</span><br><span class="line">#define REG_E              REG_VAL(e)</span><br><span class="line">#define REG_H              REG_VAL(h)</span><br><span class="line">#define REG_L              REG_VAL(l)</span><br><span class="line"></span><br><span class="line">#define REG_AF             REG_VAL(af)</span><br><span class="line">#define REG_BC             REG_VAL(bc)</span><br><span class="line">#define REG_DE             REG_VAL(de)</span><br><span class="line">#define REG_HL             REG_VAL(hl)</span><br><span class="line">#define REG_SP             REG_VAL(sp)</span><br><span class="line">#define REG_PC             REG_VAL(pc)</span><br><span class="line"></span><br><span class="line">#define FLAG_Z             (flags-&gt;z)</span><br><span class="line">#define FLAG_NZ            (!flags-&gt;z)</span><br><span class="line"></span><br><span class="line">#define FLAG_C             (flags-&gt;c)</span><br><span class="line">#define FLAG_NC            (!flags-&gt;c)</span><br></pre></td></tr></table></figure><p>這邊的規則大概是</p><ul><li>如果你想要讀取變數 Register 的值，你就使用 REG_VAL()，例如 ByteReg reg 的讀值方式就是 REG_VAL(reg)</li><li>如果你想要讀取特定 Register 的值，你就是使用 REG_A，REG_B ... 等方式</li></ul><hr><h1 id="建立記憶體管理"><a href="#建立記憶體管理" class="headerlink" title="建立記憶體管理"></a>建立記憶體管理</h1><p>接著建立 mmu(memory management unit) ，這個是負責管理記憶體的地方，所有的記憶體的存取都會經過這隻程式 -- 沒有例外，也就是我們會建立一個 64k 的 byte array，而這個 array 會假裝自己是 cpu 的 ram，其實這種說法並不正確，我們的目的應該是 mmu 會把自己假裝成是一種可以存取的裝置，但是本身實作的內容是什麼並不重要，就像是上面的 reg 的 macro，我們一直推遲 reg 取值的方式，直到最後一刻的 REG_VAL 才暴露出來原來是一個叫 all 的變數，在這之前我們都一直在玩文字遊戲，換句話說，只是 mmu 在實作的方式剛好是使用 byte array，有天你不高興，把 array 換成一個檔案，或是雲端某個可以存放資料的地方也是可以的</p><p>回到記憶體的話題，當然真實世界的 cpu 根據 sram 的位置，會有 internal sram 與 external sram 之分，像是 LR35902 這顆 cpu 的 0xFF00 的位置就是所謂的 Zero page，我猜它跟 8051 一樣 -- 藉由鎖定一個 register (也許是 P2)，達到快速讀取記憶體的方式，不過對我們來說是不太重要的，就通通看成 ram 就可以了</p><hr><p>開始實作 mmu 吧，新增檔案 mmu.c 並加入以下的 code </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">eu8 g_ram[GB_RAM_SIZE] &#x3D; &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">eu8_p get_ram_ptr(RamAddr address) &#123;</span><br><span class="line">    return (eu8_p)&amp;g_ram[address];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 get_ram(RamAddr address) &#123;</span><br><span class="line">    return (*get_ram_ptr(address));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set_ram(RamAddr address, eu8 val) &#123;</span><br><span class="line">&#x2F;&#x2F;can not write when Non-MBC mode </span><br><span class="line">    if (addr &lt; 0x8000) &#123;</span><br><span class="line">        PRINTF_ALWAYS(&quot;inhibit write rom addr&#x3D;%X, val&#x3D;%X&quot;, addr, value);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (*get_ram_ptr(address)) &#x3D; val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_mmu(eu8_p rom) &#123;</span><br><span class="line">    mem_cpy(g_ram + GAME_ROM_START_ADDR, rom, GAME_ROM_LENGTH);</span><br><span class="line">    set_ram(0xFF00, 0x3F);</span><br><span class="line">    set_ram(0xFF02, 0xFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>對應到 cpu 的 rom 就是 g_ram[_64K] 了，然後提供 gettter / setter，還有 init_mmu()</p><p>g_ram 利用 <code>eu8 g_ram[GB_RAM_SIZE] = &#123;0&#125;</code> 的方式來達到 init buffer 的功能，不過我們還需要一個 init_mmu() 的 function，它會把 game-rom copy 到 rom 0 ~ 32k 的位置，addres 0的位置有點特別，蠻重要的，晚一點會在說明，這邊還有一點比較特別的是 <code>0xFF00</code> 與 <code>0xFF02</code> 的初始值是 0x3F 與 0xFF，這邊就先照填吧</p><p>cpu.c 這邊也增加 run code ，其中 tick 就是執行 opcode 的地方，基本上 cpu 進到 run_cpu() 會在這邊無限循環直到關機為止，不過這邊我們先讓他強制停止，等晚一點再來處理 opcode </p><p>這邊有一個特別的地方就是，我們禁止了0x8000 以內的寫入行為，因為 Rom-only 的遊戲的這個區域是不會寫入的，反過來說，萬一能寫入的話，就會出問題，像是 Dr. Mario 這款遊戲就有指令寫入到這塊，但他本身是 rom-only 的遊戲，假設你照他們指令做下去的話，反而遊戲會產生錯誤，所以就是無視即可，所以說呢，bug 到處都有，即便是這種賣很久的遊戲也是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void tick() &#123;</span><br><span class="line">    g_cpu.running &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void run_cpu() &#123;</span><br><span class="line">    while (g_cpu.running) &#123;</span><br><span class="line">        tick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void power_on_cpu(eu8_p rom) &#123;</span><br><span class="line">    init_mmu(rom);</span><br><span class="line">    run_cpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們也順便把 game rom 讀進來，game rom 的檔案請自己想辦法嚕，我們在 main 中把 rom 讀進來，並且傳入 power_on_cpu，這段 code 你可以想像成把遊戲 rom 插入主機後，然後 power on 的樣子</p><p><code>注意: 目前我們只支援 32k 的 rom，像是 MBC 格式的我們目前是不支援的</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;SDL.h&gt;</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line">#include &quot;adapter_sdl.h&quot;</span><br><span class="line">#include &quot;cpu.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    printf(&quot;start\n&quot;);</span><br><span class="line">    if (argc &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_sdl(&quot;My Gameboy Emulator&quot;, SCREEN_WIDTH * SDL_PIXEL_SIZE, SCREEN_HEIGHT * SDL_PIXEL_SIZE);</span><br><span class="line"></span><br><span class="line">    echar_p romFileName &#x3D; argv[1];</span><br><span class="line">    eu8 rom[GAME_ROM_LENGTH];</span><br><span class="line">    file_read(romFileName, rom, _32K);</span><br><span class="line"></span><br><span class="line">    power_on_cpu(rom);</span><br><span class="line"></span><br><span class="line">    SDL_Quit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前為止，我們基本上已經完成了初步的架構，一個 cpu，一個記憶體，然後我們也把 rom 讀進來了，接下來就可以開始化身成 cpu ，去執行一道道 op code 了</p><p><a href="https://wwssllabcd.github.io/2021/02/10/how-to-build-a-gameboy-emulator-2/">從零開始的 Gameboy 模擬器開發 -- Step 2 </a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;建立硬體描述&quot;&gt;&lt;a href=&quot;#建立硬體描述&quot; class=&quot;headerlink&quot; title=&quot;建立硬體描述&quot;&gt;&lt;/a&gt;建立硬體描述&lt;/h1&gt;&lt;p&gt;我們首先對 cpu 做描述， 先介紹 LR35902 這顆 cpu 其中的 4 個 word Register(Register，以後均簡稱 Reg) 分別為 &lt;code&gt;AF，BC，DE，HL&lt;/code&gt;，這 4 個 word reg，比較特別的是，它們個別又可以拆成 byte reg ，例如 AF 就可以拆成兩個 byte reg &lt;code&gt;A(accumulator)&lt;/code&gt;與 &lt;code&gt;F(Flags)&lt;/code&gt; 來使用的，或者是合併讀取，例如 HL 常常當作 ram address 使用&lt;/p&gt;
&lt;p&gt;到這邊如果你覺得陌生的話，建議你可以去惡補一下 cpu 暫存器的知識&lt;/p&gt;
&lt;p&gt;考量 reg 可以分開讀取，或是合併讀取的特性，所以我們需要建立某種的描述，是可以分開，也可以合併的讀寫，翻翻 C 的手冊，發現使用 union 就可以達到這種目的了，所以我們使用 typedef 建立起對 byte reg 與 wordd reg 的描述&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="C" scheme="http://wwssllabcd.github.io/tags/C/"/>
    
    <category term="Emulator" scheme="http://wwssllabcd.github.io/tags/Emulator/"/>
    
  </entry>
  
  <entry>
    <title>從零開始的 Gameboy 模擬器開發 -- Step 0</title>
    <link href="http://wwssllabcd.github.io/2021/02/07/how-to-build-a-gameboy-emulator-0/"/>
    <id>http://wwssllabcd.github.io/2021/02/07/how-to-build-a-gameboy-emulator-0/</id>
    <published>2021-02-06T16:24:46.000Z</published>
    <updated>2021-02-13T13:34:20.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="緣由"><a href="#緣由" class="headerlink" title="緣由"></a>緣由</h1><p>工作上使用 8051 蠻多年了，以前就有想要寫一個 cpu 模擬器的念頭，某一陣子還收到一間美商寫 arm 模擬器的工作邀約，不過以不熟為理由推掉了，後來看到 Jserv 與 <a href="https://yodalee.me/2020/12/2020_rust_gameboy/">yodalee 的文章</a>，想說我應該也可以做到這件事，就像是 <a href="https://zh.wikipedia.org/wiki/%E4%B9%94%E6%B2%BB%C2%B7%E9%A9%AC%E6%B4%9B%E9%87%8C">George Mallory</a> 說的，&quot;因為山就在那，所以我登山(Because it&#39;s there)&quot;，做這件事的起因也沒什麼特別的，差不多也就是因為我覺得我可以，所以我去做看看的感覺</p><hr><h2 id="語言的選擇"><a href="#語言的選擇" class="headerlink" title="語言的選擇"></a>語言的選擇</h2><p>使用 C 語言，原因很單純就是，我只有找到一個 project 的 code 是比較乾淨的，然後他剛好是 C code 這樣，我之前有找到幾個 gbe 的 project ，但 source code 實在是太亂了，對於一個模擬器的新手要看他們的code 進而理出整個邏輯是很困難的，所以這次先選擇使用 C 開發，可能之後做完後會找機會 porting 到其他語言像是 rust、python 這兩個抽象性較高的語言，或是使用 Java Script，這樣也許會有機會可以在 web 上玩，或是 Haskell 感覺也蠻有趣的</p><a id="more"></a><hr><h2 id="Platform-的選擇"><a href="#Platform-的選擇" class="headerlink" title="Platform 的選擇"></a>Platform 的選擇</h2><p>使用 window + VC community 當作開發環境，當然使用 ubuntu(or wsl) + vs code + gcc + gdb 也是可以，這是個人喜好問題，可能之後我也會 porting 到 linux 上面去，反正就不要用一些奇怪的東西的話，盡量使用標準 C 的話，porting 就不會太困難</p><hr><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>其實有幾個目的，第一個就是看到很多 project 對於硬體上面的描述感覺很亂，我覺得如果巧妙的使用 struct 或是二維陣列的話，會可以把 code 寫得更漂亮，另外的一個目的就是試看看能不能使用 C 語言進行高階語言的設計，看能做到怎樣的程度</p><hr><h2 id="參考文件"><a href="#參考文件" class="headerlink" title="參考文件"></a>參考文件</h2><p>基本上你一定會反覆參考這些文件 ，所以就先在這邊列出，建議開始前可以先去看，有個概念</p><ul><li><a href="https://media.ccc.de/v/33c3-8029-the_ultimate_game_boy_talk#t=1445">The Ultimate Game Boy Talk</a> 這篇演講講的非常好，講者應該是非常用心的在準備這篇的演講</li><li><a href="https://fdocuments.in/document/gameboy-cpu-manual.html">Game Boy CPU Manual </a> 這手冊對於整個 GB 的 cpu 寫得很詳細 </li></ul><p>剩下的參考資料就比較沒那麼完整了，但是還是會對剛開始建立起觀念有幫助</p><ul><li><a href="https://yodalee.me/2020/12/2020_rust_gameboy/">Rust Gameboy Emulator -- by yodalee</a>: yodalee 使用 rust 的特性來，用簡單的 code 就可以大量建立 CPU 的 instruction，我就是看了這篇才決定也要動手做的</li><li><a href="http://accu.cc/content/gameboy/preface/">GameBoy 仿真器教程</a>: 這篇蠻完整的介紹了 Gameboy 各項，對於 video 的說明的方面的寫的不錯</li><li><a href="https://hackmd.io/@RinHizakura/BJ6HoW29v">Game Boy 的硬體設計與運作原理</a>: 這篇是成大資工系的專題，這邊不得不提到 <a href="http://wiki.csie.ncku.edu.tw/User/jserv">Jserv大大</a>對於台灣資訊教育的貢獻，沒有他這個專題，也不會有 yodalee 那篇文章，也更不會有我這篇文章了，當然專題的其他同學也有整理有關 GB 的資料也很棒，不過這篇是可以搭配 &quot;The Ultimate Game Boy Talk&quot; 一起閱讀的，而雖然這對同學只是一個專題，但是所產出的資料會永遠地被人參考</li></ul><p>最後的參考文件就是我的 source code ，你可以在<a href="https://github.com/wwssllabcd/EricGbEmu">這邊</a>找到目前專案的 source code</p><hr><h1 id="從零開始的-Gameboy-模擬器開發-Step-0-建立開發環境"><a href="#從零開始的-Gameboy-模擬器開發-Step-0-建立開發環境" class="headerlink" title="從零開始的 Gameboy 模擬器開發 -- Step 0: 建立開發環境"></a>從零開始的 Gameboy 模擬器開發 -- Step 0: 建立開發環境</h1><p>首先我們先建立一個 win32 console 的空專案，並取一個自己喜歡的名字，我這邊就先取了 EricGbEmu(名字不會影響後續的開發)，先行編譯與安全性檢查的都拿掉建立完的時候會出現一個 EricGbEmu.cpp 的專案，把 EricGbe.cpp 改成 main.c ，並且把其他的東西都砍掉，整個專案只剩 main.c 後，試著編譯 &amp; run 看看是否可以 pass如果可以順利 compile pass 的話，就把這些檔案放入 git  中，當作 first init</p><p>若不行，這邊也有教<a href="https://michaelchen.tech/windows-programming/use-vs2019-for-c-projects/">如何使用 VC 建立一個 C 的 project </a></p><hr><h2 id="加入常用到的-code"><a href="#加入常用到的-code" class="headerlink" title="加入常用到的 code "></a>加入常用到的 code </h2><ul><li>建立一個 folder 叫 common，把我以前累積常用的 define 與 utility 等小東西加入，以便加速開發</li><li>建立 folder 叫 type 與 define，之後若是新增 type 與 define 就丟到這裡來，這樣比較不會亂亂的</li></ul><hr><h2 id="加入-sdl-2"><a href="#加入-sdl-2" class="headerlink" title="加入 sdl 2 "></a>加入 sdl 2 </h2><p>從 <a href="https://www.libsdl.org/download-2.0.php">SDL 2 網站</a>下載 SDL2-devel-2.0.14-VC.zip ，解壓縮後就可以使用了再把 include 目錄，再去連結/輸入/其他相依性那邊輸入 <code>SDL2.lib; SDL2main.lib; SDL2test.lib</code> 就可以了記得不要在其他相依性那邊 include sdl2.dll，否則會發生 <code>檔案無效或毀損: 無法在 0x308 讀取</code> 的錯誤</p><p>若不行的話，這邊有<a href="https://lazyfoo.net/tutorials/SDL/01_hello_SDL/windows/msvc2019/index.php">Setting up SDL 2 on Visual Studio 2019 Community</a> 可以參考</p><p>接著建立一個叫 <code>adapter_sdl.c</code> 當作我們的 code 與 sdl2 介接的橋樑，code 如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;adapter_sdl.h&quot;</span><br><span class="line">#include &lt;SDL.h&gt;</span><br><span class="line">#define NULL_PTR (0)</span><br><span class="line"></span><br><span class="line">SDL_Window* g_window;</span><br><span class="line">SDL_Renderer* g_renderer;</span><br><span class="line">SDL_Texture* g_texture;</span><br><span class="line">uint32_t* g_sdl_pixels;</span><br><span class="line"></span><br><span class="line">void init_sdl(char* title, eu32 width, eu32 height) &#123;</span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);</span><br><span class="line">    g_window &#x3D; SDL_CreateWindow(title, SDL_WINDOWPOS_UNDEFINED,  SDL_WINDOWPOS_UNDEFINED, width, height, SDL_WINDOW_OPENGL);</span><br><span class="line">    if (g_window &#x3D;&#x3D; NULL_PTR) &#123;</span><br><span class="line">        ASSERT_CODE(0, &quot;Failed to initialise SD&#x3D;%X&quot;, g_window);</span><br><span class="line">    &#125;</span><br><span class="line">    g_renderer &#x3D; SDL_CreateRenderer(g_window, -1, SDL_RENDERER_ACCELERATED |  SDL_RENDERER_PRESENTVSYNC);</span><br><span class="line">    g_texture &#x3D; SDL_CreateTexture(g_renderer, SDL_PIXELFORMAT_ARGB8888,  SDL_TEXTUREACCESS_STREAMING, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這邊有個叫 ASSERT_CODE 的，是我使用 assert 的方式，你也可以改成你自己喜歡的方式去處理 error handling </p><hr><h2 id="顯示遊戲視窗"><a href="#顯示遊戲視窗" class="headerlink" title="顯示遊戲視窗"></a>顯示遊戲視窗</h2><p>修改 main.c 中的 main() 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;SDL.h&gt;</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line">#include &quot;adapter_sdl.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;start\n&quot;);</span><br><span class="line">   </span><br><span class="line">    init_sdl(&quot;My Gameboy Emulator&quot;, SCREEN_WIDTH, SCREEN_WIDTH);</span><br><span class="line">    system(&quot;PAUSE&quot;);</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中比較特別的是，這個 <code>main.c</code> 中，即便你沒用到 sdl 相關程式，你也一定要 <code>include &lt;SDL.h&gt;</code>， 因為 sdl 需要對你的 main funciton 動手腳，所以這邊只能照做</p><p>接下來就可以執行我們的 code 了， 若你執行時出現 <code>因為找不到 SDL2.dll</code> ，就代表你還沒把 <code>SDL2.dll, SDL2.lib, SDL2main.lib, SDL2test.lib</code> 這幾個檔案 copy 到執行目錄上，這個要手動做</p><p>若一切順利，理論上你應該會看到一個小的白色框框，那個就是模擬器的螢幕，但又因為我們設定的螢幕太小，所以連你打的 title 都看不到，這個問題我們之後會去解，現在就先不要管他</p><p>到此我們 Step 0 就告一個段落了，接下來就是真正要開發 code 了</p><p><a href="https://wwssllabcd.github.io/2021/02/08/how-to-build-a-gameboy-emulator-1/">從零開始的 Gameboy 模擬器開發 -- Step 1 </a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;緣由&quot;&gt;&lt;a href=&quot;#緣由&quot; class=&quot;headerlink&quot; title=&quot;緣由&quot;&gt;&lt;/a&gt;緣由&lt;/h1&gt;&lt;p&gt;工作上使用 8051 蠻多年了，以前就有想要寫一個 cpu 模擬器的念頭，某一陣子還收到一間美商寫 arm 模擬器的工作邀約，不過以不熟為理由推掉了，後來看到 Jserv 與 &lt;a href=&quot;https://yodalee.me/2020/12/2020_rust_gameboy/&quot;&gt;yodalee 的文章&lt;/a&gt;，想說我應該也可以做到這件事，就像是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B9%94%E6%B2%BB%C2%B7%E9%A9%AC%E6%B4%9B%E9%87%8C&quot;&gt;George Mallory&lt;/a&gt; 說的，&amp;quot;因為山就在那，所以我登山(Because it&amp;#39;s there)&amp;quot;，做這件事的起因也沒什麼特別的，差不多也就是因為我覺得我可以，所以我去做看看的感覺&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;語言的選擇&quot;&gt;&lt;a href=&quot;#語言的選擇&quot; class=&quot;headerlink&quot; title=&quot;語言的選擇&quot;&gt;&lt;/a&gt;語言的選擇&lt;/h2&gt;&lt;p&gt;使用 C 語言，原因很單純就是，我只有找到一個 project 的 code 是比較乾淨的，然後他剛好是 C code 這樣，我之前有找到幾個 gbe 的 project ，但 source code 實在是太亂了，對於一個模擬器的新手要看他們的code 進而理出整個邏輯是很困難的，所以這次先選擇使用 C 開發，可能之後做完後會找機會 porting 到其他語言像是 rust、python 這兩個抽象性較高的語言，或是使用 Java Script，這樣也許會有機會可以在 web 上玩，或是 Haskell 感覺也蠻有趣的&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="C" scheme="http://wwssllabcd.github.io/tags/C/"/>
    
    <category term="Emulator" scheme="http://wwssllabcd.github.io/tags/Emulator/"/>
    
  </entry>
  
  <entry>
    <title>RPI-4 安裝 android tv</title>
    <link href="http://wwssllabcd.github.io/2020/11/08/how-to-intall-android-tv-in-raspberry-pi-4/"/>
    <id>http://wwssllabcd.github.io/2020/11/08/how-to-intall-android-tv-in-raspberry-pi-4/</id>
    <published>2020-11-07T17:07:44.000Z</published>
    <updated>2020-11-08T13:21:53.352Z</updated>
    
    <content type="html"><![CDATA[<p>首先你需要下載 android tv for raspberry pi 4 的 image file ，使用的是 LineageOS 17.1 Android TV (Android 10)</p><ul><li><a href="https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/">https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/</a></li></ul><p>在安裝之前有幾點要注意的</p><ul><li>只能支援 HDMI</li><li>最初解析度為 1920*1080</li></ul><p>所以說，如果你的螢幕是 DVI 的話，你可以離開了，因為不會有畫面，先提醒你以免白忙一場</p><p>下載後使用 Win32 Disk Imager 燒錄即可，這邊跟之前的 Rpi 做法並沒有不一樣，如果還是不行，那你可以參考以前的<a href="https://wwssllabcd.github.io/blog/2013/01/31/2013-01-31-how-to-setup-raspberry-pi/#%E5%AE%89%E8%A3%9D-OS">教學</a>，燒完後，插上卡片，直接開機就可以進入到 android tv 了</p><p>這邊有燒錄相關教學</p><ul><li><a href="https://ifunoffice.com/raspberry-pi-install-android9/">https://ifunoffice.com/raspberry-pi-install-android9/</a></li></ul><p>這邊也有一點很重要的要先講，就是如果你等下遇到任何問題找不到答案的，你應該要回去<a href="https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/">官網</a>找，那邊通常都已經有答案了</p><a id="more"></a><h2 id="下載需要的檔案"><a href="#下載需要的檔案" class="headerlink" title="下載需要的檔案"></a>下載需要的檔案</h2><p>在開始之前，我建議你先下載兩個，分別是<br>    * <a href="https://opengapps.org/">gapp</a><br>    * <a href="https://androidfilehost.com/?fid=8889791610682901035">recover2boot</a>: 要刷這個, 才能從 twrp 回到 android os</p><p>去<a href="https://opengapps.org/">opengapp</a> 下載 gapp，我們要選 </p><ul><li>arm</li><li>android 10</li><li>tv stock</li></ul><p>選好之後就可以下載了</p><p>接下來要準備<code>recover2boot</code>，你可以在以下連結找到</p><ul><li><a href="https://androidfilehost.com/?fid=8889791610682901035">https://androidfilehost.com/?fid=8889791610682901035</a></li></ul><h2 id="關機-android-tv"><a href="#關機-android-tv" class="headerlink" title="關機 android tv "></a>關機 android tv </h2><p>這邊先提一下，關機選項在</p><pre><code>setting/device prrferance/about/shutdown</code></pre><h2 id="安裝-Google-app"><a href="#安裝-Google-app" class="headerlink" title="安裝 Google app"></a>安裝 Google app</h2><p>步驟有點多，主要流程為先打開 Developer option 後，開啟 root 與 terminal 後，你才可以切到 recover mode 做 twrp 並寫入 google app 到 rom 中，其實就是跟刷手機版本的 lineage 的 gapp 大同小異，以下是步驟</p><ul><li>打開 Developer option<ul><li>setting/about 後，按10下&quot;關於&quot;標籤就可以了，跟一般的 android 是一樣的作法，</li></ul></li><li>打開 root 權限<ul><li>一樣在 Developer options</li></ul></li><li>打開本機終端機<ul><li>在 Developer options</li></ul></li></ul><p>如果你在 Developer options 可以順利地打開<code>本機終端機</code>，你就可以去<code>應用程式</code>那邊就會看到，</p><p>進入本機終端機後，先打 </p><pre><code>su rpi4-recovery.sh </code></pre><p>接下來你就可以重開機了，如果順利的話你會進到 TRWP </p><h2 id="使用-TRWP-刷入-GAPP"><a href="#使用-TRWP-刷入-GAPP" class="headerlink" title="使用 TRWP 刷入 GAPP"></a>使用 TRWP 刷入 GAPP</h2><p>接下來你可以把剛剛下載的 gapp 與 recover2boot 放到 usb 上，並且插入 rpi4，此時你在 trwp 應該要可以認的到那隻 usb，接下來就要刷 gapp，刷法跟一般的手機刷法是一樣的，唯一不同的是刷 rpi 不會變磚，所以就大膽地刷吧</p><p>這邊列出步驟</p><ol><li>Download open_gapps-arm-10.0-tvstock-xxxxxxxx.zip and save it to your device’s internal storage or use an external USB drive</li><li>Boot to TWRP recovery (你應該已經進入了)</li><li>Install open_gapps-arm-10.0-tvstock-xxxxxxxx.zip from your selected storage</li><li>Wipe-&gt;Factory reset!</li><li>Boot out of recovery (see FAQ)</li></ol><p>這邊要注意的是，如果你刷好，並且重開機後，還是回到 TRWP，此時你就必須刷<code>recover2boot</code>，他可以切換 partition 到 boot，刷完之後重開機應該就能進入到 android tv 了，重開機之後，你應該就可以使用 googe store 了，之後應該就不用教了，裝自己喜歡的 app 吧，若還是卡關，這邊有其他刷 gapp 的相關教學，你可以參考看看</p><ul><li><a href="https://www.makeuseof.com/tag/build-android-tv-box-raspberry-pi/">https://www.makeuseof.com/tag/build-android-tv-box-raspberry-pi/</a></li><li><a href="https://itigic.com/install-android-tv-on-raspberry-pi-with-lineageos/">https://itigic.com/install-android-tv-on-raspberry-pi-with-lineageos/</a></li></ul><h2 id="android-tv-操作"><a href="#android-tv-操作" class="headerlink" title="android tv 操作"></a>android tv 操作</h2><p>這邊列出一些 android tv 的操作 </p><ul><li>F1 = Home, </li><li>F2 = Back, </li><li>F3 = Multi-tasking, </li><li>F4 = Menu, </li><li>F5 = Power, </li><li>F11 = Volume down,</li><li>F12 = Volume up. </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先你需要下載 android tv for raspberry pi 4 的 image file ，使用的是 LineageOS 17.1 Android TV (Android 10)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/&quot;&gt;https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在安裝之前有幾點要注意的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能支援 HDMI&lt;/li&gt;
&lt;li&gt;最初解析度為 1920*1080&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以說，如果你的螢幕是 DVI 的話，你可以離開了，因為不會有畫面，先提醒你以免白忙一場&lt;/p&gt;
&lt;p&gt;下載後使用 Win32 Disk Imager 燒錄即可，這邊跟之前的 Rpi 做法並沒有不一樣，如果還是不行，那你可以參考以前的&lt;a href=&quot;https://wwssllabcd.github.io/blog/2013/01/31/2013-01-31-how-to-setup-raspberry-pi/#%E5%AE%89%E8%A3%9D-OS&quot;&gt;教學&lt;/a&gt;，燒完後，插上卡片，直接開機就可以進入到 android tv 了&lt;/p&gt;
&lt;p&gt;這邊有燒錄相關教學&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ifunoffice.com/raspberry-pi-install-android9/&quot;&gt;https://ifunoffice.com/raspberry-pi-install-android9/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這邊也有一點很重要的要先講，就是如果你等下遇到任何問題找不到答案的，你應該要回去&lt;a href=&quot;https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/&quot;&gt;官網&lt;/a&gt;找，那邊通常都已經有答案了&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>kodi 教學，心得</title>
    <link href="http://wwssllabcd.github.io/2020/11/08/how-to-use-kodi/"/>
    <id>http://wwssllabcd.github.io/2020/11/08/how-to-use-kodi/</id>
    <published>2020-11-07T16:24:46.000Z</published>
    <updated>2020-11-08T13:19:54.983Z</updated>
    
    <content type="html"><![CDATA[<p>Kodi 是一套 media center 軟體，其前身為 xbmc，這邊列出一些相關的資源</p><h2 id="遠程控制-使用手機-APP-Yatse"><a href="#遠程控制-使用手機-APP-Yatse" class="headerlink" title="遠程控制 -- 使用手機 APP: Yatse"></a>遠程控制 -- 使用手機 APP: Yatse</h2><p>Yastse 是一款 Kodi 的遙控及投放工具，你可以在 google store 找到</p><p>不過你必須要先在 kodi 打開遠程控制，打開的地方在</p><pre><code>控制-&gt;允許通過 HTTP 遠程控制，允許異地程序遠程控制</code></pre><p>你也可以打開Web界面，這樣就可以直接使用瀏覽器控制 kodi</p><h2 id="遠程控制-使用-firefox"><a href="#遠程控制-使用-firefox" class="headerlink" title="遠程控制 -- 使用 firefox "></a>遠程控制 -- 使用 firefox </h2><p>Firefox 有很多 kodi 的套件可供遠端控制，這裡不再詳述</p><h2 id="使用-kodi-檔案總管，並從-usb-copy-檔案到-kodi"><a href="#使用-kodi-檔案總管，並從-usb-copy-檔案到-kodi" class="headerlink" title="使用 kodi 檔案總管，並從 usb copy 檔案到 kodi"></a>使用 kodi 檔案總管，並從 usb copy 檔案到 kodi</h2><p>選擇    系統-&gt;檔案總管</p><p>你就可以啟動 kodi 的檔案總管，左邊的框是操作的地方，按 C 可以叫出選單，按空白可以複選檔案例如你可以按 C 選複製，就會複製到右邊，若右邊的你找不到你要的路徑，就必須要新增瀏覽路徑</p><a id="more"></a><h2 id="調整音量音量"><a href="#調整音量音量" class="headerlink" title="調整音量音量"></a>調整音量音量</h2><ul><li>使用鍵盤上的 + - 鈕就可以</li><li>Yastse 也可以</li></ul><h2 id="設定-kodi-時間"><a href="#設定-kodi-時間" class="headerlink" title="設定 kodi 時間"></a>設定 kodi 時間</h2><ol><li>選擇 Settings &gt; Interface &gt; Regional.</li><li>注意你的 settings level 是在 Expert</li><li>如果是的話，你就可以看到 time zone 這個選項</li></ol><h2 id="安裝附加元件，遇到-kodi-script-module-urlresolver-error-dependency"><a href="#安裝附加元件，遇到-kodi-script-module-urlresolver-error-dependency" class="headerlink" title="安裝附加元件，遇到 kodi script module urlresolver error dependency"></a>安裝附加元件，遇到 kodi script module urlresolver error dependency</h2><p>請根據 error log, 下載相對應的 add-on，例如 </p><pre><code>urlsolver https://github.com/kodil/kodil/tree/master/repo/script.module.urlresolver</code></pre><p>這個代表你需要安裝 urlsolver</p><h2 id="收看直播電視"><a href="#收看直播電視" class="headerlink" title="收看直播電視"></a>收看直播電視</h2><p>必須要先安裝 add-on : <code>IPTV Simple PVR</code>，這個是 Kodi 的 IPTV 直播電視和廣播 PVR 客戶端插件，安裝完後，我們必須要指定 IPTV 要讀取哪一個直播節目的列表，IPTV 是使用 m3u8 的格式，所以我們必須要找到 m3u8 格式的直播來源</p><p>有很多 m3u8 的連結是可以 google 的到的，甚至你去 github 使用搜尋也可以找到很多，不過這個項目很大很複雜，所以之後會另開專頁說明</p><h2 id="安裝-youtube"><a href="#安裝-youtube" class="headerlink" title="安裝 youtube "></a>安裝 youtube </h2><p>你需要先安裝附加套件 Youtube，在 repository 可以找到，以下是該套件的原作者連結<a href="https://github.com/anxdpanic/plugin.video.youtube">https://github.com/anxdpanic/plugin.video.youtube</a></p><p>這邊是官方連結<a href="https://forum.kodi.tv/showthread.php?tid=356934">https://forum.kodi.tv/showthread.php?tid=356934</a></p><p>安裝完套件後，你還必須要建立 Youtube API key，可見以下連結的教學<a href="https://seo-michael.co.uk/how-to-create-your-own-youtube-api-key-id-and-secret/">https://seo-michael.co.uk/how-to-create-your-own-youtube-api-key-id-and-secret/</a></p><p>好像可以改外觀輸入密碼並允許許可後，您就可以開始了。 但是，它可能看起來不像包含所有視頻縮略圖的普通YouTube主頁。 要獲得該外觀，請從左側面板中將 Vi ewtype 更改為 Wall，如下所示</p><h2 id="安裝-Netflix"><a href="#安裝-Netflix" class="headerlink" title="安裝 Netflix "></a>安裝 Netflix </h2><p>也很麻煩，主要是登入的問題，我後來是使用 auth-key 才能登入</p><p>該套件的原始網站</p><ul><li><a href="https://github.com/CastagnaIT/plugin.video.netflix">https://github.com/CastagnaIT/plugin.video.netflix</a></li></ul><p>login with auth key  </p><ul><li><a href="https://github.com/CastagnaIT/plugin.video.netflix/wiki/Login-with-Authentication-key">https://github.com/CastagnaIT/plugin.video.netflix/wiki/Login-with-Authentication-key</a></li></ul><h2 id="kodi-套件介紹"><a href="#kodi-套件介紹" class="headerlink" title="kodi 套件介紹"></a>kodi 套件介紹</h2><ul><li>kodi 中文套件庫:  <ul><li>他是套件庫，所以只要裝這個的話，你就可以在裡面找到很多中文相關的套件，維護的不錯，很多開發者也會幫忙撰寫一些例如 bilibili, youku 的套件</li><li>該套件庫的官網<ul><li><a href="https://github.com/taxigps/xbmc-addons-chinese">https://github.com/taxigps/xbmc-addons-chinese</a></li></ul></li><li>介紹與安裝教學: <ul><li><a href="https://blog.gtwang.org/iot/openelec-xbmc-kodi-chinese-addons/">https://blog.gtwang.org/iot/openelec-xbmc-kodi-chinese-addons/</a></li><li><a href="https://github.com/imDazui/Tvlist-awesome-m3u-m3u8/blob/master/Kodi-addons.md">https://github.com/imDazui/Tvlist-awesome-m3u-m3u8/blob/master/Kodi-addons.md</a></li></ul></li></ul></li><li>kodi exodus: <ul><li>這是提供國外影片的套件</li><li><a href="https://ppkkkp.blogspot.com/2017/10/exodus-kodi-new.html">https://ppkkkp.blogspot.com/2017/10/exodus-kodi-new.html</a></li></ul></li><li>動畫瘋<ul><li><a href="https://github.com/YWJamesLin/bahamut_anime_player_kodi">https://github.com/YWJamesLin/bahamut_anime_player_kodi</a></li></ul></li><li>kodi 套件介紹<ul><li><a href="https://zh.vpnmentor.com/blog/%E9%9B%BB%E5%BD%B1%E5%8F%8A%E9%9B%BB%E8%A6%96%E5%B0%88%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3kodi%E9%99%84%E5%8A%A0%E5%85%83%E4%BB%B6/">https://zh.vpnmentor.com/blog/%E9%9B%BB%E5%BD%B1%E5%8F%8A%E9%9B%BB%E8%A6%96%E5%B0%88%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3kodi%E9%99%84%E5%8A%A0%E5%85%83%E4%BB%B6/</a></li><li><a href="https://zh.wizcase.com/blog/%E7%94%B5%E8%A7%86%E7%94%A8%E5%A4%A7kodi%E9%99%84%E5%8A%A0%E7%BB%84%E4%BB%B6%EF%BC%88%E5%90%AB%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97%EF%BC%89-%E5%B9%B4%E6%9B%B4%E6%96%B0/">https://zh.wizcase.com/blog/%E7%94%B5%E8%A7%86%E7%94%A8%E5%A4%A7kodi%E9%99%84%E5%8A%A0%E7%BB%84%E4%BB%B6%EF%BC%88%E5%90%AB%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97%EF%BC%89-%E5%B9%B4%E6%9B%B4%E6%96%B0/</a></li></ul></li></ul><h2 id="kodi-播放光碟機-CD-ROM"><a href="#kodi-播放光碟機-CD-ROM" class="headerlink" title="kodi 播放光碟機 (CD-ROM)"></a>kodi 播放光碟機 (CD-ROM)</h2><p>2 wayt to play</p><ul><li>使用主畫面左邊的選項上面會有播放光碟片的圖案，memu 應該會自動出現&quot;光碟&quot;選項才對</li><li>使用 cdrom 的路徑 <code>cdda://local/</code></li></ul><h2 id="自行撰寫-kodi-套件"><a href="#自行撰寫-kodi-套件" class="headerlink" title="自行撰寫 kodi 套件"></a>自行撰寫 kodi 套件</h2><p>這邊提供幾個 resource </p><p>kodi doc</p><ul><li><a href="https://codedocs.xyz/AlwinEsch/kodi/group__python.html">https://codedocs.xyz/AlwinEsch/kodi/group__python.html</a></li></ul><p>其他教學</p><ul><li><a href="https://kodi.wiki/view/HOW-TO:HelloWorld_addon">https://kodi.wiki/view/HOW-TO:HelloWorld_addon</a></li><li><a href="http://kfbiji.com/article/b15db97eceb78756">http://kfbiji.com/article/b15db97eceb78756</a></li><li><a href="https://pypi.org/project/kodi-addon-checker/">https://pypi.org/project/kodi-addon-checker/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kodi 是一套 media center 軟體，其前身為 xbmc，這邊列出一些相關的資源&lt;/p&gt;
&lt;h2 id=&quot;遠程控制-使用手機-APP-Yatse&quot;&gt;&lt;a href=&quot;#遠程控制-使用手機-APP-Yatse&quot; class=&quot;headerlink&quot; title=&quot;遠程控制 -- 使用手機 APP: Yatse&quot;&gt;&lt;/a&gt;遠程控制 -- 使用手機 APP: Yatse&lt;/h2&gt;&lt;p&gt;Yastse 是一款 Kodi 的遙控及投放工具，你可以在 google store 找到&lt;/p&gt;
&lt;p&gt;不過你必須要先在 kodi 打開遠程控制，打開的地方在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;控制-&amp;gt;允許通過 HTTP 遠程控制，允許異地程序遠程控制&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你也可以打開Web界面，這樣就可以直接使用瀏覽器控制 kodi&lt;/p&gt;
&lt;h2 id=&quot;遠程控制-使用-firefox&quot;&gt;&lt;a href=&quot;#遠程控制-使用-firefox&quot; class=&quot;headerlink&quot; title=&quot;遠程控制 -- 使用 firefox &quot;&gt;&lt;/a&gt;遠程控制 -- 使用 firefox &lt;/h2&gt;&lt;p&gt;Firefox 有很多 kodi 的套件可供遠端控制，這裡不再詳述&lt;/p&gt;
&lt;h2 id=&quot;使用-kodi-檔案總管，並從-usb-copy-檔案到-kodi&quot;&gt;&lt;a href=&quot;#使用-kodi-檔案總管，並從-usb-copy-檔案到-kodi&quot; class=&quot;headerlink&quot; title=&quot;使用 kodi 檔案總管，並從 usb copy 檔案到 kodi&quot;&gt;&lt;/a&gt;使用 kodi 檔案總管，並從 usb copy 檔案到 kodi&lt;/h2&gt;&lt;p&gt;選擇
    系統-&amp;gt;檔案總管&lt;/p&gt;
&lt;p&gt;你就可以啟動 kodi 的檔案總管，左邊的框是操作的地方，按 C 可以叫出選單，按空白可以複選檔案例如你可以按 C 選複製，就會複製到右邊，若右邊的你找不到你要的路徑，就必須要新增瀏覽路徑&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
    <category term="Kodi" scheme="http://wwssllabcd.github.io/tags/Kodi/"/>
    
  </entry>
  
  <entry>
    <title>how-to-install-kodi-in-raspberry-pi-4</title>
    <link href="http://wwssllabcd.github.io/2020/11/08/how-to-install-kodi-in-raspberry-pi-4/"/>
    <id>http://wwssllabcd.github.io/2020/11/08/how-to-install-kodi-in-raspberry-pi-4/</id>
    <published>2020-11-07T16:06:48.000Z</published>
    <updated>2020-11-07T16:58:00.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RPI-4-安裝-kodi-的心得"><a href="#RPI-4-安裝-kodi-的心得" class="headerlink" title="RPI 4 安裝 kodi 的心得"></a>RPI 4 安裝 kodi 的心得</h2><p>因為之前的rpi 效能都不太好，所以, 許久沒碰 rpi, 這次出了8GB 號稱可以接近桌機的效能，所以就買一台試看看</p><p>PS: 寫在前頭，如果你打算使用 DVI 螢幕當作 RPI 的螢幕的話，你可能要注意，rpi 有機會不能輸出畫面</p><h2 id="購買"><a href="#購買" class="headerlink" title="購買"></a>購買</h2><p>我這次是去台灣樹梅派購買的，我購買的是 8GB + 散熱殼，那個散熱殼我蠻滿意的，風扇也是靜音風扇，只是風扇安裝需要一點技巧，好像裝錯邊風扇就會很吵，記得風扇正反不要裝錯，有貼貼紙的地方是反面，否則你的風扇不會轉</p><h2 id="安裝-kodi，使用-LibreElec"><a href="#安裝-kodi，使用-LibreElec" class="headerlink" title="安裝 kodi，使用 LibreElec"></a>安裝 kodi，使用 LibreElec</h2><p>在 rpi 4 上面安裝 kodi 已經很簡單了，LibreElec 這個專案已經把 os + kodi 整合起來，所以我們就直接安裝 libreelec 就可以了，請到以下網站抓取 image file </p><p><a href="https://libreelec.tv/raspberry-pi-4/">https://libreelec.tv/raspberry-pi-4/</a></p><p>該網站提供的下載的檔案叫做 &quot;LibreELEC-RPi4.arm-9.2.6.img.gz&quot;，下載完後使用 7z，解開她得到 img file 後，就可以使用  Win32 Disk Imager 燒錄即可，這邊跟之前的 Rpi 做法並沒有不一樣</p><p>如果還是不行，那你可以參考以前的<a href="https://wwssllabcd.github.io/blog/2013/01/31/2013-01-31-how-to-setup-raspberry-pi/#%E5%AE%89%E8%A3%9D-OS">教學</a></p><p>燒完之後，插入至RPI後，接上電源就可以使用了</p><a id="more"></a><h2 id="常見問題"><a href="#常見問題" class="headerlink" title="常見問題"></a>常見問題</h2><h2 id="沒有畫面，沒有螢幕"><a href="#沒有畫面，沒有螢幕" class="headerlink" title="沒有畫面，沒有螢幕"></a>沒有畫面，沒有螢幕</h2><p>Raspberry Pi 僅支持具有 DVI-D 插槽的設備如果你的螢幕只能使用 DVI 的話就會很麻煩，特別是那種很古老的 DVI 介面，你必須要取得你螢幕能支援的解析度</p><p>所以你必須要能在 console 執行以下指令</p><pre><code>/opt/vc/bin/tvservice -d edid.dat/opt/vc/bin/edidparser edid.dat</code></pre><p>以便得到你螢幕的參數，但是你又沒螢幕，也看不到，自然也沒法輸入指令，這邊提供兩個做法</p><ol><li>你可以使用 ssh / telnet 的方式登入到 rpi ，自然就可以下指令</li><li>找一台可以順利顯示的螢幕，輸入上述 edid 指令後，先不要執行，然後再把你的螢幕接到不能顯示的螢幕上後，再去執行該指令後，再把螢幕接回來，這樣一來你就可以得到那台無法顯示畫面的螢幕的 edid 檔案了</li></ol><p>拿到參數後，關機後修改 config.txt ，你就可以根據螢幕回報的解析度組合，來設定能支援的參數，以下連結有 video option 可以參考</p><ul><li><a href="https://www.raspberrypi.org/documentation/configuration/config-txt/video.md">https://www.raspberrypi.org/documentation/configuration/config-txt/video.md</a></li><li><a href="https://elinux.org/RPiconfig#Video_mode_options">https://elinux.org/RPiconfig#Video_mode_options</a></li><li><a href="https://pimylifeup.com/raspberry-pi-screen-resolution/">https://pimylifeup.com/raspberry-pi-screen-resolution/</a></li></ul><p>主要就是要修改 <code>hdmi_group</code> 與  <code>hdmi_mode</code> 這兩個參數</p><h2 id="沒有畫面，沒有螢幕-continue"><a href="#沒有畫面，沒有螢幕-continue" class="headerlink" title="沒有畫面，沒有螢幕(continue)"></a>沒有畫面，沒有螢幕(continue)</h2><p>如果還是不行，可以試看看在 <code>config.txt</code> 中，設定 hdmi 的輸出的選項，如以下選項都可以試試</p><pre><code>hdmi_drive chooses between HDMI and DVI modeshdmi_drive=1 Normal DVI mode (No sound)hdmi_drive=2 Normal HDMI mode (Sound will be sent if supported and enabled)</code></pre><p>讓 config.txt 強制設定螢幕介面為你裝置的介面</p><h2 id="kodi-有畫面沒有聲音"><a href="#kodi-有畫面沒有聲音" class="headerlink" title="kodi 有畫面沒有聲音"></a>kodi 有畫面沒有聲音</h2><ul><li>把 hdmi 線改接到比較靠近電源的那個插孔(注意，RPI4 會有兩個 hdmi 輸出的接孔，靠近電源的那一個才是主要的輸出)</li><li>檢查 config.txt 是否為 <code>hdmi_drive=2</code></li><li>檢查 kodi 的設定，是否沒有設定成 hdmi 輸出音效</li><li>在系統設定那邊, 選[設定]-&gt;[音效設定], 檢查輸出設定是否為[hdmi or alalog]</li></ul><h2 id="SSH-打不開"><a href="#SSH-打不開" class="headerlink" title="SSH 打不開"></a>SSH 打不開</h2><p>可能是沒有安裝 ssh ，請使用指令安裝</p><pre><code>sudo service ssh start</code></pre><p>或者是根本沒安裝</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;RPI-4-安裝-kodi-的心得&quot;&gt;&lt;a href=&quot;#RPI-4-安裝-kodi-的心得&quot; class=&quot;headerlink&quot; title=&quot;RPI 4 安裝 kodi 的心得&quot;&gt;&lt;/a&gt;RPI 4 安裝 kodi 的心得&lt;/h2&gt;&lt;p&gt;因為之前的rpi 效能都不太好，所以, 許久沒碰 rpi, 這次出了8GB 號稱可以接近桌機的效能，所以就買一台試看看&lt;/p&gt;
&lt;p&gt;PS: 寫在前頭，如果你打算使用 DVI 螢幕當作 RPI 的螢幕的話，你可能要注意，rpi 有機會不能輸出畫面&lt;/p&gt;
&lt;h2 id=&quot;購買&quot;&gt;&lt;a href=&quot;#購買&quot; class=&quot;headerlink&quot; title=&quot;購買&quot;&gt;&lt;/a&gt;購買&lt;/h2&gt;&lt;p&gt;我這次是去台灣樹梅派購買的，我購買的是 8GB + 散熱殼，那個散熱殼我蠻滿意的，風扇也是靜音風扇，只是風扇安裝需要一點技巧，好像裝錯邊風扇就會很吵，記得風扇正反不要裝錯，有貼貼紙的地方是反面，否則你的風扇不會轉&lt;/p&gt;
&lt;h2 id=&quot;安裝-kodi，使用-LibreElec&quot;&gt;&lt;a href=&quot;#安裝-kodi，使用-LibreElec&quot; class=&quot;headerlink&quot; title=&quot;安裝 kodi，使用 LibreElec&quot;&gt;&lt;/a&gt;安裝 kodi，使用 LibreElec&lt;/h2&gt;&lt;p&gt;在 rpi 4 上面安裝 kodi 已經很簡單了，LibreElec 這個專案已經把 os + kodi 整合起來，所以我們就直接安裝 libreelec 就可以了，請到以下網站抓取 image file &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://libreelec.tv/raspberry-pi-4/&quot;&gt;https://libreelec.tv/raspberry-pi-4/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;該網站提供的下載的檔案叫做 &amp;quot;LibreELEC-RPi4.arm-9.2.6.img.gz&amp;quot;，下載完後使用 7z，解開她得到 img file 後，就可以使用  Win32 Disk Imager 燒錄即可，這邊跟之前的 Rpi 做法並沒有不一樣&lt;/p&gt;
&lt;p&gt;如果還是不行，那你可以參考以前的&lt;a href=&quot;https://wwssllabcd.github.io/blog/2013/01/31/2013-01-31-how-to-setup-raspberry-pi/#%E5%AE%89%E8%A3%9D-OS&quot;&gt;教學&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;燒完之後，插入至RPI後，接上電源就可以使用了&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>指數型投資(Investment of indexing)</title>
    <link href="http://wwssllabcd.github.io/2020/02/16/Investment-of-indexing/"/>
    <id>http://wwssllabcd.github.io/2020/02/16/Investment-of-indexing/</id>
    <published>2020-02-15T20:29:30.000Z</published>
    <updated>2020-11-07T16:58:07.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>這篇是給目前不能自己挑到好股票, 但又想做投資的人看的</li><li>這邊主要的核心概念是&quot;分散&quot;, 若是能挑到好股票的人看了這篇, 不但沒幫助, 反而會有害</li></ul><h2 id="核心概念-分散投資標的以降低風險"><a href="#核心概念-分散投資標的以降低風險" class="headerlink" title="核心概念 -- 分散投資標的以降低風險"></a>核心概念 -- 分散投資標的以降低風險</h2><ul><li>分散股票種類: 購買 ETF 分散投資目標的風險</li><li>分散購入時機: 定期定額</li><li>分散股票區域性: 購入全球 ETF</li><li>分散股票類型: 股票 + 債的資產配置</li></ul><p>我先講結論, 然後再慢慢解釋我為何這樣推薦, 而作法就是   </p><h3 id="quot-定期定額購買-指數型-ETF-quot"><a href="#quot-定期定額購買-指數型-ETF-quot" class="headerlink" title="&quot;定期定額購買 指數型 ETF &quot;"></a>&quot;定期定額購買 指數型 ETF &quot;</h3><p>方法很多種, 從簡單到複雜:   </p><ol><li>利用富邦證劵, 定期定額購買富邦采吉50(006208) ETF<ul><li>投資低消為 1000元, 適合小資上班族</li><li><a href="https://www.fubon.com/securities/hot_new/open-now/etf.html">富邦定期定額 ETF</a> 1萬元以內, 手續費只要1元</li></ul></li><li>利用複委託, 例如<a href="https://www.dcn.com.tw/re-consigned/charge.htm">大昌證券複委託</a> , 定期定額購買 VT + BNDW, 或是 AOA 系列的 ETF</li><li>開網路劵商, 如 <a href="https://www.firstrade.com/content/zh-tw/welcome">Firstrade</a> or <a href="https://www.tdameritrade.com/">TD Ameritrade</a> 帳戶, 定期定額購買 VT + BNDW + VNQ ... etc</li></ol><a id="more"></a><h2 id="本文開始"><a href="#本文開始" class="headerlink" title="本文開始"></a>本文開始</h2><p>通常我們想要購買股票投資時, 會遇到兩個問題就是</p><ul><li>買哪支股票?</li><li>什麼時候買?</li></ul><p>股票那麼多種, 在規畫退休金時, 從早期的中鋼開始, 經過中華電信, 到現在的金融股, 其實變動很大, 10年前的手機很紅, 如果買了 HTC 當作退休金, 放到現在無法退休吧, 也就是說其實做長期投資, 光是 10 年其實變化就很大, 不論是公司或是產業, 因為時間一拉長的關係, 原本看好的市場或是公司不免產生一些變化, 而把退休金放在這些標的上面, 一旦發生變化那不是很可怕? </p><p>所以主動選擇產業跟公司, 其實是不太好的策略, 要避免這個問題就是要分散產業與公司, 其實有一種簡單的方法就是買市場指數型 ETF(大盤) </p><p>這邊再把這兩個問題整理一下  </p><ul><li>買哪支股票?<ul><li>我不會選股, 也看不出股票真正價值, 所以不買個股</li><li>採用 ETF 指數投資, 例如投資市值前50大的公司的 0050<ul><li>被動投資不見得會輸主動投資, 0050 其實打敗很多人</li><li>不用研究股票, 就有更多的時間拿來運用</li><li>不用怕下市, 台灣市值前50大的公司若都倒了, 那台灣應該也毀了吧, 而且買其他個股的會比你先死</li><li>連股神巴菲特都開始買 SP 500 的ETF了</li><li>買大盤指數也減少了人為操弄, 避免股市巨鯨進出而被影響</li></ul></li></ul></li><li>什麼時候買?<ul><li>世上沒人可以預估進場時機</li><li>所以使用定期購買法分散風險<ul><li>利用平均法, 長時間下來你不會買在低點, 也不會買到高點, 而是買在平均點</li></ul></li></ul></li></ul><p>也就是說, 利用定期定額購買大盤, 你就會獲得到大盤的利潤, 你不會比大盤賺, 你也不會比大盤差, 你就是拿到大盤成長的利潤</p><h2 id="戰勝市場-大盤-很難嗎"><a href="#戰勝市場-大盤-很難嗎" class="headerlink" title="戰勝市場(大盤), 很難嗎?"></a>戰勝市場(大盤), 很難嗎?</h2><p>我參考到的資料是打敗大盤不是不能, 但是很難, 你可能要花上相當大的資源才能打敗大盤, 投報率很低, 這個問題的答案理論基礎在於市場是否為效率市場有關, 大概是說假設去掉手續費, 這其實是一場零和遊戲, 那假設每個人都很厲害, 就代表市場裡的每個人都很有效率的購買股票, 最後這些人也只能拿到跟大盤一樣的利潤, 那今天有一個人比較遜, 跑來市場, 最後那些很有效率的人賺到的錢的總和就是那個比較遜的人虧的總和</p><p>不過我舉另一個例子, 巴菲特在 2008 年跟公開賭50萬美金, 賭沒有任何的對沖基金可以贏的了 Vanguard S&amp;P500 ETF(美國標普500指數型基金, 代號 VOO, 簡單的來說你可以把它想像成美國50), 2018 年巴菲特賭贏了, 這個結論也代表經理人是多餘的 :D, 他在2017 年也說過沒有人可以打敗大盤指數型基金</p><p>這個故事你可以在這邊找到: <a href="https://wealth.businessweekly.com.tw/GArticle.aspx?id=ARTL000124494">從與經理人的10年賭約，看巴菲特價值投資法</a></p><h2 id="市場一定會成長嗎"><a href="#市場一定會成長嗎" class="headerlink" title="市場一定會成長嗎?"></a>市場一定會成長嗎?</h2><p>理論上會的, 人類不斷的產生經濟活動就會創造更多的價值, 所以說你如果長期買空頭的話, 會蠻慘的</p><h2 id="台灣追蹤指數的-ETF-元大台灣-50-0050-VS-富邦台灣采吉-50-006208"><a href="#台灣追蹤指數的-ETF-元大台灣-50-0050-VS-富邦台灣采吉-50-006208" class="headerlink" title="台灣追蹤指數的 ETF -- 元大台灣 50(0050) VS 富邦台灣采吉 50(006208)"></a>台灣追蹤指數的 ETF -- 元大台灣 50(0050) VS 富邦台灣采吉 50(006208)</h2><p>在台灣有兩隻 EFT分別都是追蹤大盤指數, 分別是元大台灣 50(代號: 0050) 與富邦台灣采吉 50(代號: 006208), 基本上這兩隻性質很像, 那我們要選哪一隻呢? </p><p>在評斷 ETF 時, 有幾點要注意的</p><ul><li>追蹤誤差是多少?<ul><li>例如 元大台灣 50(0050) 與 富邦台灣采吉 50(006208) 都是追蹤大盤, 但是大盤今年漲 10%, ETF 不見得會跟著漲 10%, 可能會漲 9.5%, 如果爛一點的話可能會更低, 9%, 8% 之類的, 這種與標的物差太多的就是不好的 ETF, 相反的, 如果該 ETF 比大盤來得高, 例如是賺 10%, 11%, 也不是好的 ETF</li></ul></li><li>內扣費用高低?<ul><li>因為指數型 ETF 不需要靠經理人殺進殺出, 是根據指數做操作的, 所以管理費應該會隨著基金規模變大而下降</li><li>有良心的業者隨著規模變大應該要調降管理費用</li></ul></li></ul><p>綜合以上兩點, 我會建議你買<a href="https://websys.fsit.com.tw/FubonETF/Funds/Profile.aspx?stock=006208">富邦50</a>, 是因為 <em>&quot;富貴要人幫, 買股買這張&quot;</em> 嗎? 並不是, 而是因為他有比較低的手續費與內扣費用, 追蹤大盤的能力也很好的緣故</p><p><a href="https://www.twse.com.tw/zh/ETF/fund/0050">台灣50的費用為 0.355%</a><a href="https://www.twse.com.tw/zh/ETF/fund/00692">富邦50的費用為 0.185%</a></p><p>網路有不少分析文章, 想知道更細部的原因可以看以下幾篇</p><ul><li><a href="https://greenhornfinancefootnote.blogspot.com/2019/10/50etf0062082019.html">台50 vs 富邦 50 -- 綠角</a></li><li><a href="https://rich01.com/0050etf-vs-006208etf/">富邦台50ETF(006208)vs台灣50(0050)報酬與費用比較》小資族挑哪個好</a></li><li><a href="https://wealth.businessweekly.com.tw/GArticle.aspx?id=ARTL000120248">同樣追蹤台股大盤...月投5千買「便宜版0050」，管理費更低、賺更多！</a></li></ul><h2 id="指數型-ETF-VS-存股"><a href="#指數型-ETF-VS-存股" class="headerlink" title="指數型 ETF VS 存股"></a>指數型 ETF VS 存股</h2><p>現在也蠻流行固定購買某些特定的股票, 例如定期定額買入中華電信, 兆豐金等股票, 這些人稱存股族, 那這種投資方式好嗎?</p><p>首先, 投資的方式應該沒什麼好不好, 只有適不適合自己, 只要你能買下去, 晚上能睡好覺的就是好方式, 而&quot;定期定額購買定存股&quot;與&quot;定期定額購買大盤指數型 ETF (如台灣50)&quot; 其實差別只有在買入標, 但我覺得買入 ETF 更好, 以下是推論</p><ul><li>存股不能買了不管<ul><li>退休應該是很久的事情, 至少超過10年</li><li>10年前表現好的定存股, 10年後不見得會好</li><li>指數型 ETF 每年會自動調整, 定存股需要手動調整</li><li>不要買固定股票當存股, 除非你常常盯著他</li></ul></li></ul><p>當然, 也許你會想說定存股也可以自行調整, 這當然可以, 這邊只是提出存股不能放著不管的想法, 所以才建議購買大盤指數型 ETF, 畢竟我們不想花大時間去研究哪個股票適合當定存股, 你如果能時時刻刻照顧你的股票, 那也是 ok 的</p><h2 id="EFT-哪種比較好-元大台灣50-0050-VS-元大高股息-0056-VS-富邦公司治理-006208"><a href="#EFT-哪種比較好-元大台灣50-0050-VS-元大高股息-0056-VS-富邦公司治理-006208" class="headerlink" title="EFT 哪種比較好 -- 元大台灣50(0050) VS 元大高股息(0056) VS 富邦公司治理(006208)"></a>EFT 哪種比較好 -- 元大台灣50(0050) VS 元大高股息(0056) VS 富邦公司治理(006208)</h2><p>這幾隻都是很熱門的 ETF, 哪種比較好呢? 這邊先列出基本資料</p><ul><li>元大台灣50: 是追蹤大盤指數 ETF, 由市值最大的50大公司, 依照市值比例組成</li><li>元大高股息: 是由配股配息高的股票</li><li>富邦公司治理: 追蹤金管會發布的公司治理名單所組成</li></ul><p>直接講結論:<br>挑選 &quot;非人為能介入&quot; 的, 所以就是選大盤指數 ETF (台灣50), 理由是人可以介入的話, 就可能會出問題, 如果你認為它們兩個績效一樣的話, 那你就買指數型就好了, 問題會比較少, 更何況 0056 雖然名稱叫高股息, 但不見得會配贏 0050, 且管理費比 0050 還高, 雖然富邦公司治理(006208)其實跟大盤趨勢很像, 但基本上完全是不同的概念, 一個是主動型選股, 一個是被動選股, 績效相同只是剛巧而已</p><p>現在也看到很多不是以市場當作指數的 ETF , 例如元大高股息(0056) 就是, 雖然也叫做指數型 ETF 但其實跟原本針對市場做的指數型投資概念差很多, 千萬別搞錯了, 同理富邦公司治理(006208)也是</p><h2 id="存退休金的方式"><a href="#存退休金的方式" class="headerlink" title="存退休金的方式"></a>存退休金的方式</h2><p>定期定額其實很適合上班族, 當你每個月定期定額存入5000元到指數型基金, 等到 20 年假設你 60歲, 你可以每個月提 5000 元, 至少可以提 20 年, 至少提領到 80 歲, 當然股票是比較有波動的投資, 所以我們必須不斷地分散風險, 同時又拿到市場成長的果實</p><p>當然光是購買台灣 50 ETF 是遠遠不夠的, 你還需要資產配置, 例如搭配一點點的債劵或是 REIT 等, 這個可能等之後再來討論</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>假設我們決定要買&quot;台灣 50&quot;, 仔細想想, <strong>定期定額購買台灣50</strong> 這決策中, 背後代表什麼?    </p><ul><li>定期定額購買 + 台灣 50 ETF<ul><li>定期定額購買: 代表放棄選擇進入市場的時間, 被動進場</li><li>台灣 50 ETF: 代表放棄選股, 因為是他幫你選好了, 被動選股</li></ul></li></ul><p>最後你會發現, 我的策略其實是叫你 </p><h4 id="quot-放棄選股-也放棄選入場時機來買股票-quot"><a href="#quot-放棄選股-也放棄選入場時機來買股票-quot" class="headerlink" title="&quot;放棄選股, 也放棄選入場時機來買股票&quot;"></a>&quot;放棄選股, 也放棄選入場時機來買股票&quot;</h4><p> 這結論聽起來非常違反人性 😄</p><p>不過我非財經研究專家, 所以上面有些東西推論起來其實是有點卡卡的, 不過工程師就是要做實驗, 這個違反人性的事, 你可以每個月花1000塊, 定期定額購買 ETF, 一年後你可以再來看看這種奇怪的方式到底是好, 還是不好, 結果搞不好會讓你大吃一驚喔</p><p>最後我在文中一直提到個概念就是 <strong>分散標的</strong>, 以降低風險 , 舉一反三的你一定會發現, 我們談到的分散的範圍也只是在台灣這塊市場而已, 若是把每個國家市場都看成一間公司, 其實你會發現我們最終還是在投資一間公司而已, 而這個問題就留在下次討論嚕</p><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><p>這邊提供更多市場價值的解釋, 可以看看</p><ul><li><a href="https://www.ptt.cc/bbs/Stock/M.1523074420.A.B23.html">被動型ETF投資方式及心得</a></li></ul><p>若你還想看更多有關指數化與被動投資的文章, 可以看看下面的連結</p><ul><li>被動投資是什麼<ul><li><a href="https://rich01.com/what-passive-invest/">https://rich01.com/what-passive-invest/</a></li><li><a href="https://pgfinnote.com/understanding-passive-investing/">https://pgfinnote.com/understanding-passive-investing/</a></li><li><a href="https://www.etf168.com.tw/Article/Article?articleID=211">https://www.etf168.com.tw/Article/Article?articleID=211</a></li><li><a href="http://justin0904.pixnet.net/blog/post/222388512">http://justin0904.pixnet.net/blog/post/222388512</a></li><li><a href="https://as223400.pixnet.net/blog/post/227830082-%E8%A2%AB%E5%8B%95%E6%8A%95%E8%B3%87-%E4%BD%8E%E9%A2%A8%E9%9A%AA%E7%9A%84%E6%87%B6%E4%BA%BA%E6%8A%95%E8%B3%87%E6%96%B9%E6%B3%95">https://as223400.pixnet.net/blog/post/227830082-%E8%A2%AB%E5%8B%95%E6%8A%95%E8%B3%87-%E4%BD%8E%E9%A2%A8%E9%9A%AA%E7%9A%84%E6%87%B6%E4%BA%BA%E6%8A%95%E8%B3%87%E6%96%B9%E6%B3%95</a></li><li><a href="https://www.etf168.com.tw/Article/Article?articleID=211">https://www.etf168.com.tw/Article/Article?articleID=211</a></li></ul></li><li>指數化投資是什麼<ul><li><a href="https://greenhornfinancefootnote.blogspot.com/2013/08/1greenhorns-investment-principles.html">https://greenhornfinancefootnote.blogspot.com/2013/08/1greenhorns-investment-principles.html</a></li><li><a href="https://greenhornfinancefootnote.blogspot.com/2016/02/indexing-best-choice-for-professionals.html">https://greenhornfinancefootnote.blogspot.com/2016/02/indexing-best-choice-for-professionals.html</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;這篇是給目前不能自己挑到好股票, 但又想做投資的人看的&lt;/li&gt;
&lt;li&gt;這邊主要的核心概念是&amp;quot;分散&amp;quot;, 若是能挑到好股票的人看了這篇, 不但沒幫助, 反而會有害&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;核心概念-分散投資標的以降低風險&quot;&gt;&lt;a href=&quot;#核心概念-分散投資標的以降低風險&quot; class=&quot;headerlink&quot; title=&quot;核心概念 -- 分散投資標的以降低風險&quot;&gt;&lt;/a&gt;核心概念 -- 分散投資標的以降低風險&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分散股票種類: 購買 ETF 分散投資目標的風險&lt;/li&gt;
&lt;li&gt;分散購入時機: 定期定額&lt;/li&gt;
&lt;li&gt;分散股票區域性: 購入全球 ETF&lt;/li&gt;
&lt;li&gt;分散股票類型: 股票 + 債的資產配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我先講結論, 然後再慢慢解釋我為何這樣推薦, 而作法就是   &lt;/p&gt;
&lt;h3 id=&quot;quot-定期定額購買-指數型-ETF-quot&quot;&gt;&lt;a href=&quot;#quot-定期定額購買-指數型-ETF-quot&quot; class=&quot;headerlink&quot; title=&quot;&amp;quot;定期定額購買 指數型 ETF &amp;quot;&quot;&gt;&lt;/a&gt;&amp;quot;定期定額購買 指數型 ETF &amp;quot;&lt;/h3&gt;&lt;p&gt;方法很多種, 從簡單到複雜:   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用富邦證劵, 定期定額購買富邦采吉50(006208) ETF&lt;ul&gt;
&lt;li&gt;投資低消為 1000元, 適合小資上班族&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.fubon.com/securities/hot_new/open-now/etf.html&quot;&gt;富邦定期定額 ETF&lt;/a&gt; 1萬元以內, 手續費只要1元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用複委託, 例如&lt;a href=&quot;https://www.dcn.com.tw/re-consigned/charge.htm&quot;&gt;大昌證券複委託&lt;/a&gt; , 定期定額購買 VT + BNDW, 或是 AOA 系列的 ETF&lt;/li&gt;
&lt;li&gt;開網路劵商, 如 &lt;a href=&quot;https://www.firstrade.com/content/zh-tw/welcome&quot;&gt;Firstrade&lt;/a&gt; or &lt;a href=&quot;https://www.tdameritrade.com/&quot;&gt;TD Ameritrade&lt;/a&gt; 帳戶, 定期定額購買 VT + BNDW + VNQ ... etc&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Investment" scheme="http://wwssllabcd.github.io/tags/Investment/"/>
    
  </entry>
  
  <entry>
    <title>Python windows 安裝, 心得, 教學</title>
    <link href="http://wwssllabcd.github.io/2018/05/21/how-to-install-python-on-windows/"/>
    <id>http://wwssllabcd.github.io/2018/05/21/how-to-install-python-on-windows/</id>
    <published>2018-05-20T17:13:59.000Z</published>
    <updated>2018-06-19T15:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下載並安裝-Python"><a href="#下載並安裝-Python" class="headerlink" title="下載並安裝 Python"></a>下載並安裝 Python</h2><p>請至 <a href="https://www.python.org/downloads/windows/">Python windows 下載頁面</a>, 不是每個版本都有 window 的安裝版</p><ol><li>最好選擇 Python 3.x, 因為選 2.7 會有檔名多國語言問題, dos 下讀檔會亂碼, py 3 就沒有這問題  </li><li>最好選 32bit 的, 因為如果要打包成單一執行檔(exe file), 打包完在 32 bit 的環境跑不起來, 且有 include dll 批配的問題  </li><li>要選 32bit 還是 64 bit, 基本上要看你用到的 DLL 決定, 例如你有些額外的 dll 是使用 w32 的, 那基本上你使用 64bit 的 ptyhon 就不行, 使用而且 64 bit dll 還有 ctype call address 的問題, 建議如果不想搞死自己, 那就最好是選 32bit 的比較保險</li></ol><p>這邊是選 <a href="https://www.python.org/ftp/python/3.6.5/python-3.6.5.exe">Python 3.6.5</a> 下載</p><p>安裝時請注意以下幾點</p><ul><li>請注意安裝路徑, 他預設是在&quot;使用者&quot;目錄下面, 最好換到非中文目錄底下</li><li>要移除時, 必須執行安裝程式後, 裡面有個uninstall, 在 window 那邊好像找不到移除方式</li><li>安裝時選 customize install, 這樣才可以自選安裝路徑</li><li>也順便選 Add python 3.6 to path</li></ul><a id="more"></a><h2 id="安裝-pip"><a href="#安裝-pip" class="headerlink" title="安裝 pip"></a>安裝 pip</h2><p>如果是安裝 python 3.5 以上的, 都會預設安裝 pip, 所以只要更新 pip 即可, 這邊舉出了舉多種 python 取得 pip 所對應的方法, 分述如下:</p><ul><li><p>Python 3.4 以前的版本: 取得 get-pip.py 後, 放到 Python 安裝目錄下後, 執行</p><pre><code>  python get-pip.py   </code></pre></li></ul><p>pip 會建立在例如 <code>D:\Python27\Scripts</code> 之下, 請把 <code>get-pip.py</code> 這個 script 加入到 path 中</p><ul><li><p>Python 3.6: 是內建pip的, 所以要使用的時候, 直接打開 dos cmd 輸入 pip 指令即可更新 pip (前面的 python 不能省略)    </p><pre><code>  python -m pip install --upgrade pip</code></pre></li></ul><p>更新某個套件也可以用 pip, 若要更新 pyqt5 時, 指令如下</p><pre><code>pip install -U pyqt5</code></pre><p>其他指令可藉由 <code>pip -h</code> 查到</p><h2 id="關於-pip-與-pip3-的差異"><a href="#關於-pip-與-pip3-的差異" class="headerlink" title="關於 pip 與 pip3 的差異"></a>關於 pip 與 pip3 的差異</h2><p>pip 和 pip3 都在 Python36\Scripts\ 目錄下, 如果同時裝有python2 和 python3, pip 默認給 python2 用, pip3 指定給 python3 用, 如果只裝有 python3，則pip和pip3是等價的, 安裝了python3之後，就會有pip3</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;下載並安裝-Python&quot;&gt;&lt;a href=&quot;#下載並安裝-Python&quot; class=&quot;headerlink&quot; title=&quot;下載並安裝 Python&quot;&gt;&lt;/a&gt;下載並安裝 Python&lt;/h2&gt;&lt;p&gt;請至 &lt;a href=&quot;https://www.python.org/downloads/windows/&quot;&gt;Python windows 下載頁面&lt;/a&gt;, 不是每個版本都有 window 的安裝版&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最好選擇 Python 3.x, 因為選 2.7 會有檔名多國語言問題, dos 下讀檔會亂碼, py 3 就沒有這問題  &lt;/li&gt;
&lt;li&gt;最好選 32bit 的, 因為如果要打包成單一執行檔(exe file), 打包完在 32 bit 的環境跑不起來, 且有 include dll 批配的問題  &lt;/li&gt;
&lt;li&gt;要選 32bit 還是 64 bit, 基本上要看你用到的 DLL 決定, 例如你有些額外的 dll 是使用 w32 的, 那基本上你使用 64bit 的 ptyhon 就不行, 使用而且 64 bit dll 還有 ctype call address 的問題, 建議如果不想搞死自己, 那就最好是選 32bit 的比較保險&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這邊是選 &lt;a href=&quot;https://www.python.org/ftp/python/3.6.5/python-3.6.5.exe&quot;&gt;Python 3.6.5&lt;/a&gt; 下載&lt;/p&gt;
&lt;p&gt;安裝時請注意以下幾點&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;請注意安裝路徑, 他預設是在&amp;quot;使用者&amp;quot;目錄下面, 最好換到非中文目錄底下&lt;/li&gt;
&lt;li&gt;要移除時, 必須執行安裝程式後, 裡面有個uninstall, 在 window 那邊好像找不到移除方式&lt;/li&gt;
&lt;li&gt;安裝時選 customize install, 這樣才可以自選安裝路徑&lt;/li&gt;
&lt;li&gt;也順便選 Add python 3.6 to path&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://wwssllabcd.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>安裝 PyQt</title>
    <link href="http://wwssllabcd.github.io/2018/05/21/how-to-install-pyqt/"/>
    <id>http://wwssllabcd.github.io/2018/05/21/how-to-install-pyqt/</id>
    <published>2018-05-20T17:13:59.000Z</published>
    <updated>2018-06-19T15:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安裝-PyQt"><a href="#安裝-PyQt" class="headerlink" title="安裝 PyQt "></a>安裝 PyQt </h2><p>PyQT 為 python 的一款 GUI 程式, 是採用 GPL licence, 但也是不是每一版都有 windows 安裝版<br>注意: 這邊可能會更推薦使用 pip 安裝, 指令為</p><pre><code> pip install pyqt5</code></pre><p>pip 會自動根據 python 的版本自動匹配, 我這邊使用 <code>python 3.6.5</code> 批配到的是 <code>pyqt 5.10.1</code></p><pre><code>雖然 PyQt 可以自行從官網下載並安裝, 但請務必使用 pip 安裝, 後面使用的時候問題會比較少</code></pre><h2 id="安裝-Pyqt5-tools"><a href="#安裝-Pyqt5-tools" class="headerlink" title="安裝 Pyqt5-tools"></a>安裝 Pyqt5-tools</h2><p>使用 pip 安裝 PyQt 時, 並不會把 Pyqt designr 給安裝起來, 所以使用 pip 安裝 Pyqt5-tools, 以便取得 QT designer</p><pre><code>pip install pyqt5-tools</code></pre><p>而 designer 會在 </p><pre><code>D:\Python\Python36-32\Lib\site-packages\pyqt5-tools</code></pre><p>中找到</p><a id="more"></a><h2 id="PyQt-的-ui-檔轉換"><a href="#PyQt-的-ui-檔轉換" class="headerlink" title="PyQt 的 ui 檔轉換"></a>PyQt 的 ui 檔轉換</h2><p>安裝好 pyqt5 後, 可以使用 qt design 來設計 UI, 把 UI 設計好了之後存檔, 會產生 .ui檔 接下來要使用此ui 檔, 我們必須把此 ui 檔案轉換成 .py檔，方便我們直接在 Python 中使用, 使用 CMD 切換到設計好的 ui 所在目錄下，執行此指令(ui檔我們取名為 myui.ui) </p><pre><code>pyuic5 myui.ui -o myui.py</code></pre><p>而 pyuic5 路徑如下( python 安裝路徑為 D:\Python36-32 為例)</p><pre><code>D:\Python36-32\Scripts\pyuic5.exe</code></pre><p>接下來把以下文字存成&#39;PyGui.py&#39;  </p><pre><code>import sysfrom PyQt5.QtWidgets import QApplication, QDialog, QMessageBoxfrom myui import Ui_Dialogclass MyDlg(QDialog):    def __init__(self):        super(MyDlg, self).__init__()        # Set up the user interface from Designer.        self.ui = Ui_Dialog()        self.ui.setupUi(self)def main_start():    app = QApplication(sys.argv)    window = MyDlg()    window.show()    sys.exit(app.exec_())if __name__ == &#39;__main__&#39;:    main_start()</code></pre><p>再執行以下指令即可</p><pre><code>python PyGui.py </code></pre><p>ref:</p><p><a href="http://pyqt.sourceforge.net/Docs/PyQt5/designer.html">http://pyqt.sourceforge.net/Docs/PyQt5/designer.html</a></p><h2 id="在-QT-design-中觀看-ui-預覽"><a href="#在-QT-design-中觀看-ui-預覽" class="headerlink" title="在 QT design 中觀看 ui 預覽"></a>在 QT design 中觀看 ui 預覽</h2><ul><li>表單/預覽, </li><li>或是 Ctrl+R</li></ul><h2 id="LineEdit-與-TextEdit-的差異"><a href="#LineEdit-與-TextEdit-的差異" class="headerlink" title="LineEdit 與 TextEdit 的差異"></a>LineEdit 與 TextEdit 的差異</h2><p>lineEdit: 單行的 editTextEdit: 多行</p><h2 id="什麼是-Spacer"><a href="#什麼是-Spacer" class="headerlink" title="什麼是 Spacer "></a>什麼是 Spacer </h2><p>是當使用 vertical layout 時, 若中間不想放東西的時候用來填空的Horizontal Spacer 水平空白条和 Vertical Spacer 垂直空白条，空白条的作用就是填充无用的空隙，如果不希望看到控件拉伸后变丑，就可以塞一个空白条到布局器里面<a href="https://qtguide.ustclug.org/">https://qtguide.ustclug.org/</a></p><h2 id="建立一個事件"><a href="#建立一個事件" class="headerlink" title="建立一個事件"></a>建立一個事件</h2><pre><code>class MyDlg(QtGui.QDialog):    def __init__(self, parent=None):        QtGui.QWidget.__init__(self, parent)        self.ui = Ui_Dialog()        self.ui.setupUi(self)        self.ui.btnRefresh.clicked.connect(self.chk_fun)    def chk_fun(self):        print(&quot;Good.&quot;)</code></pre><p>直接在 MyDlg 中的 <code>__init__</code> 中加入事件, 並綁定到某個 function 就可以了, 例如這邊看到的是一個叫<code>btnRefresh</code> 的button, 我們把這個 button 的 clicked 的事件, 綁訂到 chk_fun 這個 function , 而這個 function 印出 good</p><p>再舉一個例子, 如 combobox 的 index change 綁定事件如下</p><pre><code>myCombobox.currentIndexChanged.connect(self.cmd_idx_change)</code></pre><h2 id="使用-keypass-event"><a href="#使用-keypass-event" class="headerlink" title="使用 keypass event"></a>使用 keypass event</h2><p>只要在該 Qdlog 中, 複寫 def keyPressEvent(self, event): 即可, 如下所示</p><pre><code>def keyPressEvent(self, event):    key = event.key()    print(key)    super(MyDlg, self).keyPressEvent(event)</code></pre><p>要注意的是, 如果現在 focus 的控鍵上有 keypassevent 的話, 會優先呼叫該控鍵的 event, 例如 txtedit 有自己的 page down , 所以 dialog 的不會對他造成影響</p><h2 id="關掉-QTextEdit-的-Scoll"><a href="#關掉-QTextEdit-的-Scoll" class="headerlink" title="關掉 QTextEdit 的 Scoll"></a>關掉 QTextEdit 的 Scoll</h2><p>找到 verticalScrollBarPolicy , 並且把她設成 off 即可</p><h2 id="設定-dialog-title"><a href="#設定-dialog-title" class="headerlink" title="設定 dialog title"></a>設定 dialog title</h2><p>self.setWindowTitle</p><h2 id="Combobox-中的下拉式-item-加長"><a href="#Combobox-中的下拉式-item-加長" class="headerlink" title="Combobox 中的下拉式 item 加長"></a>Combobox 中的下拉式 item 加長</h2><p>有個屬性叫<code>visiable item cnt</code>的數字選大一點</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;安裝-PyQt&quot;&gt;&lt;a href=&quot;#安裝-PyQt&quot; class=&quot;headerlink&quot; title=&quot;安裝 PyQt &quot;&gt;&lt;/a&gt;安裝 PyQt &lt;/h2&gt;&lt;p&gt;PyQT 為 python 的一款 GUI 程式, 是採用 GPL licence, 但也是不是每一版都有 windows 安裝版&lt;br&gt;注意: 這邊可能會更推薦使用 pip 安裝, 指令為&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; pip install pyqt5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pip 會自動根據 python 的版本自動匹配, 我這邊使用 &lt;code&gt;python 3.6.5&lt;/code&gt; 批配到的是 &lt;code&gt;pyqt 5.10.1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;雖然 PyQt 可以自行從官網下載並安裝, 但請務必使用 pip 安裝, 後面使用的時候問題會比較少&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;安裝-Pyqt5-tools&quot;&gt;&lt;a href=&quot;#安裝-Pyqt5-tools&quot; class=&quot;headerlink&quot; title=&quot;安裝 Pyqt5-tools&quot;&gt;&lt;/a&gt;安裝 Pyqt5-tools&lt;/h2&gt;&lt;p&gt;使用 pip 安裝 PyQt 時, 並不會把 Pyqt designr 給安裝起來, 所以使用 pip 安裝 Pyqt5-tools, 以便取得 QT designer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install pyqt5-tools&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而 designer 會在 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;D:\Python\Python36-32\Lib\site-packages\pyqt5-tools&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中找到&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://wwssllabcd.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>執行 amb expression</title>
    <link href="http://wwssllabcd.github.io/2017/11/12/how-to-execute-amb-expression/"/>
    <id>http://wwssllabcd.github.io/2017/11/12/how-to-execute-amb-expression/</id>
    <published>2017-11-11T17:13:59.000Z</published>
    <updated>2017-11-30T19:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立-amb-環境"><a href="#建立-amb-環境" class="headerlink" title="建立 amb 環境"></a>建立 amb 環境</h2><p>先去這邊下載</p><pre><code>https://mitpress.mit.edu/sicp/code/</code></pre><p>amb 是 chapter 4 的, 所以選以下這個下載</p><pre><code>ch4-ambeval.scm     Amb Evaluator (section 4.3)</code></pre><p>然後再scheme 中執行, 會發現 load 不進去另一個檔, 其實把兩個檔案合起來就可以了, 存成一個檔案後, 就可以使用指令 load 出來, 如下</p><pre><code>( load &quot;e:\\a.scm&quot;) </code></pre><p><code>PS：按CTRL-Y 可以貼上文字</code></p><a id="more"></a><p>然後按<code>Ctrl + x</code>, 再按<code>ctrl + e</code>就可以執行 LISP</p><p>如果出現了 </p><pre><code>;Loading &quot;e:\\a.scm&quot;... done;Value: amb-evaluator-loaded</code></pre><p>就代表載入 成功, 執行amb的部分可以參考以下</p><pre><code>http://uents.hatenablog.com/entry/sicp/059-amb-operator-with-call-cc.md</code></pre><p>接下來建立 env, 使用以下指令</p><pre><code>(define the-global-environment (setup-environment))</code></pre><h2 id="執行-amb"><a href="#執行-amb" class="headerlink" title="執行 amb "></a>執行 amb </h2><p>接下來就可以輸入 </p><pre><code>(driver-loop)</code></pre><p>如果出現</p><pre><code>;;; Amb-Eval input:</code></pre><p>此時就是代表進入到 amb 執行器, 輸入</p><pre><code>(amb 1 3 5 )</code></pre><p>會出現1 , 輸入 </p><pre><code>try-again</code></pre><p>會出現3</p><h2 id="觀察裡面的值"><a href="#觀察裡面的值" class="headerlink" title="觀察裡面的值"></a>觀察裡面的值</h2><p>例如, 我想觀察變數<code>exp</code>, 就可以在 code 中插入</p><pre><code>(newline)(display &quot;=== my print ==&quot;)(newline)(display exp)</code></pre><p>即可 trace code</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol><li>先把輸入參數, 利用 map +analyze 分析完成後, 放到 cprocs 中</li><li>再利用 (try-next cprocs), 把每個東西都拿出來</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;建立-amb-環境&quot;&gt;&lt;a href=&quot;#建立-amb-環境&quot; class=&quot;headerlink&quot; title=&quot;建立 amb 環境&quot;&gt;&lt;/a&gt;建立 amb 環境&lt;/h2&gt;&lt;p&gt;先去這邊下載&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://mitpress.mit.edu/sicp/code/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;amb 是 chapter 4 的, 所以選以下這個下載&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch4-ambeval.scm     Amb Evaluator (section 4.3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後再scheme 中執行, 會發現 load 不進去另一個檔, 其實把兩個檔案合起來就可以了, 存成一個檔案後, 就可以使用指令 load 出來, 如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;( load &amp;quot;e:\\a.scm&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PS：按CTRL-Y 可以貼上文字&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="sicp" scheme="http://wwssllabcd.github.io/tags/sicp/"/>
    
  </entry>
  
  <entry>
    <title>makefile 心得、教學</title>
    <link href="http://wwssllabcd.github.io/2016/10/03/how-to-write-make-file/"/>
    <id>http://wwssllabcd.github.io/2016/10/03/how-to-write-make-file/</id>
    <published>2016-10-02T17:13:59.000Z</published>
    <updated>2021-02-13T13:41:19.313Z</updated>
    
    <content type="html"><![CDATA[<p>要寫 makefile 之前，首先我們必須要先從最基本的 GCC 編譯指令開始學起，才可以一步一步地建立起 makefile，幸好這不會花我們太多時間</p><h1 id="使用-GCC-編譯命令，並且印出-hello-world"><a href="#使用-GCC-編譯命令，並且印出-hello-world" class="headerlink" title="使用 GCC 編譯命令，並且印出 hello world "></a>使用 GCC 編譯命令，並且印出 hello world </h1><p>建立一個檔案叫做 main.c 後，輸入以下指令</p><pre><code>#include&lt;stdio.h&gt;int main()&#123;    printf(&quot;\r\nHello World&quot;);&#125;</code></pre><p>接著在命令列(windows 系統可以使用 cygwin)中，輸入 compile 指令</p><pre><code> gcc -c main.c</code></pre><p>執行完後會產生 obj file，如 main.o<br>而上述所使用的編譯參數如下所示</p><pre><code>-c : 只編譯不連結 </code></pre><p>執行連結，使用 gcc -o 指令</p><pre><code> gcc -o test main.o</code></pre><p>-o 代表作 link，-o filename 為指定輸出檔名<br>此時應該會出現一個叫 test 的檔案<br>執行 test </p><pre><code>./testHello World</code></pre><p>編譯時，如果有 header file 的時候，可以使用 -I 參數，如下所示<br>這邊是指定 header file 是在哪個目錄可以找的到</p><pre><code> gcc -c -I ./inc main.c</code></pre><a id="more"></a><h1 id="使用-makefile-簡化"><a href="#使用-makefile-簡化" class="headerlink" title="使用 makefile 簡化"></a>使用 makefile 簡化</h1><p>建立一個文字檔，取名為 makefile，內容填入如下所示</p><pre><code>test: main.o    gcc -o main.o testmain.o: main.c    gcc -c main.cclean:    rm -f *.o *.exe</code></pre><p>先解說以下這行</p><pre><code>main.o: main.c</code></pre><p>main.o: 分號前面代表目標，而後面的 main.c 就是告訴 make，要完成前面那個目標的話，必須要有<code>main.c</code>這個前置條件，所以如果輸入<code>make main.o</code> 的話，是會自動執行 <code>gcc -c main.c</code> 這段指令的，因為前置條件已經滿足，所以可以執行執行完就是產生 main.o 了</p><p>再看看第一行</p><pre><code>test: main.o</code></pre><p>test: 代表目標，而後面的 main.o 是前置條件，執行 make test 的時候，make 會找看看有沒有 main.o 這個檔，如果有的話就會執行，如果沒有的話，他會去找看看tag有沒有產生 main.o 的方法，並且嘗試產生出main.o</p><h1 id="執行-makefile"><a href="#執行-makefile" class="headerlink" title="執行 makefile"></a>執行 makefile</h1><p>在 console 輸入 make test 之後，make 會去找有無 test 這個 tag，這邊有 test 的 tag，而執行 test 的前置條件是必須要有 main.o ，則 make 會檢查有無 main.o 這個檔案，如果沒有的話，會自動搜尋 makefile 中，有無 main.o 這個檔案的產生方法，</p><p>這邊是有的，不過產生 main.o 的先決條件是要有 main.c ，則 make 會檢查有無 main.c 這個檔案，目前是有的，</p><p>所以 make 會先去執行 main.o 那個 tag，也就是 gcc -c main.c，執行這行指令後，會產生 main.o 這個檔案出來，所以執行 test 這個 tag 的條件也已經滿足了，所以可以執行 test 這個 tag ，也就是執行 gcc -o main.o test，所以產生出 test 這個檔案出來了</p><h1 id="多個檔案的-makefile"><a href="#多個檔案的-makefile" class="headerlink" title="多個檔案的 makefile"></a>多個檔案的 makefile</h1><p>加入第二個 .c file </p><pre><code>main.o: main.c    gcc -c  main.cDataIn.o: DataIn.cpp    gcc -c DataIn.cpp</code></pre><p>可以觀察到 main.o 與 dataIn.o 其實差不多格式，所以應該要有個萬用的格式例如 <em>.</em> 這種東西來簡化，而 make 的確是有這種簡化指令的，他是使用 % 來簡化，但 % 是屬於一對一的，也就是 foo.o 對應到 foo.c，這跟 * 不太一樣，而目標與前置條件都有萬用符號後，其實 gcc -c 要接的那個檔案名稱，也必須要是一種變數才行</p><pre><code>%.o: %.c    gcc -c $&lt;</code></pre><p>$&lt; : 屬於第一條件，也就是 foo.c<br>$@ : 屬於目標條件，也就是 foo.o  </p><h1 id="撰寫-makefile-的一些心得"><a href="#撰寫-makefile-的一些心得" class="headerlink" title="撰寫 makefile 的一些心得"></a>撰寫 makefile 的一些心得</h1><p>先把ld 需要的 object 建立起來，如建立起 obj_files </p><pre><code> OBJ_FILES = \    $(OBJDIR)/head.o  \    $(OBJ_LIB) \    $(OBJ_KERNEL) \</code></pre><p>然後利用 make 的前置規則讓他去找自動產生編譯需求</p><pre><code> system.bin:  $(OBJ_FILES )</code></pre><p>再利用萬用符號，讓每個檔案被編譯出來，如下所示</p><pre><code># == rule for kernel/ ==$(DIR_KERENL)/%.o: $(DIR_KERENL) /%.asm    $(AS) $&lt; -o $@$(DIR_KERENL)/%.o: $(DIR_KERENL) /%.c    $(CC) $(CFLAGS) $&lt; -o $@ </code></pre><h1 id="編譯前的-pre-task"><a href="#編譯前的-pre-task" class="headerlink" title="編譯前的 pre-task "></a>編譯前的 pre-task </h1><p>make 的前置條件，不見得是一個檔案，也可以是某個 tag</p><pre><code>all: clean mkdir boot.img </code></pre><p>這邊代表需要先執行 clean 這個規則，再需要 執行 mkdir 這個規則，然後執行boot.img</p><h1 id="make-時不顯示指令"><a href="#make-時不顯示指令" class="headerlink" title="make 時不顯示指令"></a>make 時不顯示指令</h1><p>在命令前面加上 @ ，代表不顯示該命令，如下所示@mkdir -p $@</p><h1 id="PHONY-符號的用法"><a href="#PHONY-符號的用法" class="headerlink" title=".PHONY 符號的用法"></a>.PHONY 符號的用法</h1><p>例如有時候都會見到</p><pre><code>.PHONY: clean</code></pre><p>.PHONY。這個符號的目的是告訴 make，&quot;clean&quot; 不是一個真正的檔案目標，只是一個標記，不要把他當成檔案來處理，避免有檔案真的叫 clean 時，make 會在依賴性判斷時判斷錯誤，那就糗了。</p><h1 id="在-make-file-中使用-awk"><a href="#在-make-file-中使用-awk" class="headerlink" title="在 make file 中使用 awk"></a>在 make file 中使用 awk</h1><pre><code>awk &#39;&#123; print $$1&quot; &quot;$$3 &#125;&#39; system.nm &gt; system.bsb</code></pre><p>只有使用一個$的話，會被make吃掉，使用兩個$，就不會消失</p><h1 id="makefile-中，定義變數"><a href="#makefile-中，定義變數" class="headerlink" title="makefile 中，定義變數"></a>makefile 中，定義變數</h1><p>可利用 $(MACRO) 或 ${MACRO} 來存取已定義的變數</p><p>M=$(PWD) 表明然後返回到當前目錄繼續讀入、執行當前的 Makefile。</p><h1 id="quot-語法-quot"><a href="#quot-語法-quot" class="headerlink" title="&quot;?= 語法&quot; "></a>&quot;?= 語法&quot; </h1><p>?= 語法：?= 是一個簡化的語法：若變數未定義，則替它指定新的值。否則，採用原有的值。例：FOO ?= bar若 FOO 未定義，則 FOO = bar；若 FOO 已定義，則 FOO 的值維持不變。</p><h1 id="語法"><a href="#語法" class="headerlink" title=":= 語法"></a>:= 語法</h1><p>:= 語法注意到，make 會將整個 Makefile 展開後，再決定變數的值。也就是說，變數的值將會是整個 Mackfile 中最後被指定的值。例：</p><pre><code>x = fooy = $(x) barx = xyz    # 此時 y 的值為 xyz bar</code></pre><p>在上例中，y 的值將會是 xyz bar，而不是 foo bar。您可以利用 := 來避開這個問題。:= 表示變數的值決定於它在 Makefile 中的位置，而不是整個 Makefile 展開後最終的值。</p><h1 id="巢狀-make"><a href="#巢狀-make" class="headerlink" title="巢狀 make"></a>巢狀 make</h1><p>也就是說 make 可以執行其他的 make ，如每個目錄都有自己的 make ，根目錄的 make 是可以進入到 其他目錄中，跳去執行其他的 make 後再回來使用 -C 參數。後面帶目錄名稱如下所示</p><pre><code>make -C boot</code></pre><p>你就會看到 make 會 Entering directory 後，再做 make </p><h1 id="makefile-建立目錄"><a href="#makefile-建立目錄" class="headerlink" title="makefile 建立目錄"></a>makefile 建立目錄</h1><p>必須要一個 target來幫助，如 directories，如下所示</p><pre><code>OBJDIR = ./obj$(OBJDIR):    mkdir -p $@makeDir: $&#123;OBJDIR&#125;</code></pre><p>接下來就是在 make all 那邊，加入dependence</p><pre><code>all: makeDir </code></pre><h1 id="make-內部變數"><a href="#make-內部變數" class="headerlink" title="make 內部變數"></a>make 內部變數</h1><p>$?：代表已被更新的 dependencies 的值，也就是 dependencies 中，比 targets 還新的值。<br>$@：代表 targets 的值。$&lt;：代表第一個 dependencies 的值<br>$* :代表 targets 所指定的檔案，但不包含副檔名    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;要寫 makefile 之前，首先我們必須要先從最基本的 GCC 編譯指令開始學起，才可以一步一步地建立起 makefile，幸好這不會花我們太多時間&lt;/p&gt;
&lt;h1 id=&quot;使用-GCC-編譯命令，並且印出-hello-world&quot;&gt;&lt;a href=&quot;#使用-GCC-編譯命令，並且印出-hello-world&quot; class=&quot;headerlink&quot; title=&quot;使用 GCC 編譯命令，並且印出 hello world &quot;&gt;&lt;/a&gt;使用 GCC 編譯命令，並且印出 hello world &lt;/h1&gt;&lt;p&gt;建立一個檔案叫做 main.c 後，輸入以下指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
int main()&amp;#123;
    printf(&amp;quot;\r\nHello World&amp;quot;);
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接著在命令列(windows 系統可以使用 cygwin)中，輸入 compile 指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gcc -c main.c&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行完後會產生 obj file，如 main.o&lt;br&gt;而上述所使用的編譯參數如下所示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-c : 只編譯不連結 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行連結，使用 gcc -o 指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gcc -o test main.o&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-o 代表作 link，-o filename 為指定輸出檔名&lt;br&gt;此時應該會出現一個叫 test 的檔案&lt;br&gt;執行 test &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./test

Hello World&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;編譯時，如果有 header file 的時候，可以使用 -I 參數，如下所示&lt;br&gt;這邊是指定 header file 是在哪個目錄可以找的到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gcc -c -I ./inc main.c&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://wwssllabcd.github.io/tags/C/"/>
    
    <category term="Makefile" scheme="http://wwssllabcd.github.io/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>bochs 使用教學，心得</title>
    <link href="http://wwssllabcd.github.io/2016/04/20/how-to-use-bochs/"/>
    <id>http://wwssllabcd.github.io/2016/04/20/how-to-use-bochs/</id>
    <published>2016-04-20T09:23:25.000Z</published>
    <updated>2016-06-05T16:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h1><p>使用 apt 安裝的是沒有debug 功能的，bochs 通常一出現視窗運行會沒辦法輸入指令，如果你只是要單純的執行環境的話，就使用 apt安裝吧，如果要 debug 功能的話，就要自行 compile</p><p>下載 <a href="https://sourceforge.net/projects/bochs/files/bochs/2.6.8/">bochs 2.6.8 source code</a></p><p>安裝(可參考 orange&#39;s P10)輸入下列指令 </p><pre><code>tar vxzf bochs-2.6.8.tar.gz</code></pre><p>進入目錄後，開始設定</p><pre><code>./configure --enable-disasm  --enable-debugger</code></pre><p>如果要使用 gdb 的話，就不能用 <code>--enable-debugger</code> ，要換成  <code>--enable-gdbstub</code>接下來就是</p><pre><code>makesudo make install</code></pre><a id="more"></a><h1 id="Bochs-ini-配置"><a href="#Bochs-ini-配置" class="headerlink" title="Bochs ini 配置"></a>Bochs ini 配置</h1><p>配置文件詳解可看 <a href="http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html">The configuration file bochsrc</a>也可見 linux 內核完全註釋 CH17，這邊列出我自己的 src 檔</p><pre><code>romimage: file=/usr/share/bochs/BIOS-bochs-latestmegs: 16vgaromimage: file=/usr/share/vgabios/vgabios.binfloppya: 1_44=system.img, status=insertedata0-master: type=disk, path=&quot;80.img&quot;, mode=flatboot: alog: bochsout.txtmouse: enabled=0display_library: x#debug_symbols: file=system.bsb#gdbstub: enabled=1, port=1234</code></pre><p>把以上的ini存成 <code>bochsrc.txt</code> 就可以了，另外如果有多個 ini 檔要切換時可以使用 <code>-f</code> 參數，如下所示</p><pre><code>bochs -f anotherBochIni.txt</code></pre><h1 id="bochs-載入-debug-symbols"><a href="#bochs-載入-debug-symbols" class="headerlink" title="bochs 載入 debug symbols "></a>bochs 載入 debug symbols </h1><p>載入symbol 的方是有兩種，一種是手動，一種是ini載入，以下兩者都會介紹到</p><h2 id="修改-symbol-格式"><a href="#修改-symbol-格式" class="headerlink" title="修改 symbol 格式"></a>修改 symbol 格式</h2><p>官方說，bochs的 symbol 的格式為</p><pre><code>The symbol file consists of zero or more lines of the format&quot;%x %s&quot;</code></pre><p>也就是說，只有文字檔格式 &quot;%x %s&quot;  才可以載入，不像GDB可以載入bin，而這邊可以先觀察一下 nm 輸出的格式如下</p><pre><code> 00000000 T startup_32</code></pre><p>中間有一個 type，不符合 bochs 規定的格式，所以要把那個 type 行去掉如果要改變格式，可以利用 awk 來幫助，例如要改變 nm 檔為兩行時，可用下列 awk 指令</p><pre><code> awk &#39;&#123; print $1&quot; &quot;$3 &#125;&#39; system.nm  &gt; system.bsb</code></pre><p>$1與$3 分別代表直排一與直排三，若要搭配在 make 中使用的時候，要加兩個$，如下所示 </p><pre><code>nm:   nm system.elf |sort &gt; system.nm   awk &#39;&#123; print $ $1&quot; &quot;$ $3 &#125;&#39; system.nm &gt; system.bsb</code></pre><p>nm 檔要經過修改後，才可以正確的載入到 bochs</p><h2 id="使用-ini-載入-debug-file"><a href="#使用-ini-載入-debug-file" class="headerlink" title="使用 ini 載入 debug file "></a>使用 ini 載入 debug file </h2><p>在ini中輸入</p><pre><code>debug_symbols: file=&quot;system.bsb&quot;</code></pre><p>system.bsb 為你修改過的 symbol file </p><h2 id="Bochs-手動載入-symbol"><a href="#Bochs-手動載入-symbol" class="headerlink" title="Bochs 手動載入 symbol"></a>Bochs 手動載入 symbol</h2><p>而使用 ldsym 的時候，要加雙引號，如下所示</p><pre><code> ldsym &quot;system.bsb&quot;</code></pre><h2 id="使用-gdb-當作測試-client"><a href="#使用-gdb-當作測試-client" class="headerlink" title="使用 gdb 當作測試 client"></a>使用 gdb 當作測試 client</h2><p>安裝 bochs 時，必須要打開 <code>--enable-gdbstub</code> 後，在 ini 中，加入參數即可</p><pre><code> gdbstub: enabled=1, port=1234</code></pre><h1 id="bochs-debug-指令"><a href="#bochs-debug-指令" class="headerlink" title="bochs debug 指令 "></a>bochs debug 指令 </h1><p>可以在執行時，輸入 h ，會有簡單的指令列表，而在 bochs 中，下中斷要加雙引號，如下所示</p><pre><code> b &quot;TestA&quot; </code></pre><p>也可以列出變數的值，如</p><pre><code>x/10 &quot;idt&quot;</code></pre><p>其實 bochs 應該就是根據 symbol file ，來找出對應的記憶體位置而已，</p><p>Bochs 操作蠻像 GDB 的，以下列出常用的 bochs 的debug 指令</p><table><thead><tr><th>指令</th><th>說明</th></tr></thead><tbody><tr><td>c</td><td>continue，執行 OS</td></tr><tr><td>s</td><td>單步(會進入function)</td></tr><tr><td>n</td><td>單步(不進入function)</td></tr><tr><td>b &quot;main&quot;</td><td>下中斷在 function main 的起始位置，使用時，記得要載入符號表</td></tr><tr><td>d</td><td>刪除中斷</td></tr><tr><td>blist</td><td>列出所有中斷點</td></tr><tr><td>x/10 addr</td><td>列出 addr 的位置的值</td></tr><tr><td>q</td><td>離開 bochs</td></tr></tbody></table><p>其他的指令可見 <a href="http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html">Using Bochs internal debugger</a> 說明</p><h1 id="troubleshooting"><a href="#troubleshooting" class="headerlink" title="troubleshooting "></a>troubleshooting </h1><h2 id="fatal-error-X11-extensions-Xrandr-h-No-such-file-or-directory"><a href="#fatal-error-X11-extensions-Xrandr-h-No-such-file-or-directory" class="headerlink" title="fatal error: X11/extensions/Xrandr.h: No such file or directory"></a>fatal error: X11/extensions/Xrandr.h: No such file or directory</h2><p>ANS:  missing libxrandr-dev</p><h2 id="display-library-39-sdl-39-not-available"><a href="#display-library-39-sdl-39-not-available" class="headerlink" title="display library &#39;sdl&#39; not available"></a>display library &#39;sdl&#39; not available</h2><p>手動安裝的時候，預設的display選項為 x (此例為sdl)所以<code>bochssrc.txt</code>設定要設為</p><pre><code>display_library: x</code></pre><h2 id="BIOS-No-bootable-device"><a href="#BIOS-No-bootable-device" class="headerlink" title="[BIOS ] No bootable device"></a>[BIOS ] No bootable device</h2><p>有很多問題會造成這個錯誤，這邊只是列舉一個</p><pre><code>ans:  floppya image size doesn&#39;t match one of the supported types</code></pre><p>OS 若是使用 floppy 模擬的話，磁碟最好寫滿到count 2888。最後加上</p><pre><code>count=2883 seek=5 conv=notrunc</code></pre><p>以seek5個sector為例，這邊就是寫2883個sector</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><p><a href="http://www.groad.net/bbs/thread-678-1-1.html">http://www.groad.net/bbs/thread-678-1-1.html</a><br><a href="http://www.cnblogs.com/long123king/p/3568575.html">http://www.cnblogs.com/long123king/p/3568575.html</a>     </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;安裝&quot;&gt;&lt;a href=&quot;#安裝&quot; class=&quot;headerlink&quot; title=&quot;安裝&quot;&gt;&lt;/a&gt;安裝&lt;/h1&gt;&lt;p&gt;使用 apt 安裝的是沒有debug 功能的，bochs 通常一出現視窗運行會沒辦法輸入指令，
如果你只是要單純的執行環境的話，就使用 apt安裝吧，如果要 debug 功能的話，就要自行 compile&lt;/p&gt;
&lt;p&gt;下載 &lt;a href=&quot;https://sourceforge.net/projects/bochs/files/bochs/2.6.8/&quot;&gt;bochs 2.6.8 source code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安裝(可參考 orange&amp;#39;s P10)
輸入下列指令 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar vxzf bochs-2.6.8.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;進入目錄後，開始設定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --enable-disasm  --enable-debugger&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要使用 gdb 的話，就不能用 &lt;code&gt;--enable-debugger&lt;/code&gt; ，要換成  &lt;code&gt;--enable-gdbstub&lt;/code&gt;
接下來就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make
sudo make install&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="bochs" scheme="http://wwssllabcd.github.io/tags/bochs/"/>
    
  </entry>
  
  <entry>
    <title>Bitcoin 簡介</title>
    <link href="http://wwssllabcd.github.io/2015/08/21/what-is-bitcoin/"/>
    <id>http://wwssllabcd.github.io/2015/08/21/what-is-bitcoin/</id>
    <published>2015-08-21T15:32:31.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>發明者: 中本聰(<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%9C%AC%E8%81%AA">1</a>)，但這只是化名，真實身份不明，應該是一群想撈錢的集團幹的</p><p>經過: It&#39;s a very long story，請見資料(<a href="https://yowureport.com/%E5%85%A9%E5%B9%B42%E8%90%AC%E5%80%8D%E7%9A%84%E5%8D%87%E5%80%BC%EF%BC%8C%E6%9C%80%E5%88%92%E7%AE%97%E7%9A%84%E6%8A%95%E8%B3%87-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-bitcoin/">2</a>)</p><h2 id="使用過程"><a href="#使用過程" class="headerlink" title="使用過程"></a>使用過程</h2><p>其實就是妳的電子錢包，把交易的訊息(如我要把 100 個 bitcoin 轉給 A)這條訊息用數位簽章簽過，經過P2P網路送給所有的錢包使用者手上，利用P2P網路把交易的訊息傳遞出去，利用RSA保證身份，是一種去中心化的貨幣</p><h2 id="產生比特的方式"><a href="#產生比特的方式" class="headerlink" title="產生比特的方式"></a>產生比特的方式</h2><p>就是所謂的 mining(挖礦)，透過這個公式 </p><pre><code>SHA256( Block data + Random nonce ) &lt; 難度值</code></pre><p>來算出來(<a href="https://www.ptt.cc/bbs/Soft_Job/M.1385557793.A.5E6.html">3</a>)，而 Block data 就是上一筆交易的資料，也就是說，Block data 再加上某個值 N ，如果丟到 SHA 中運算小於這次難度值的結果的話就代表挖到礦，挖到的東西就是新的 block，這個Block會把數字 N 還有這段期間收到的交易資料還有新的難度值，包成一包變成新的BlockNo後，接在舊的後面後，再藉由P2P傳出去，別人在根據新 BlockNo 繼續玩上面那套公式，而所謂的&quot;難度值&quot;會根據 BlockNo 根據當初設計的公式調整(這個數值會每隔2016個block，網絡大約每小時創建6個塊，創建2016塊大約2週)調整一次)，所以後面會越來越難挖，變成總數(發行量)會趨近於某個數值，又因為交易的資料是伴隨著新的 Block 用P2P的方式散布出去，所以有時候交易的資料並不會馬上顯示出來，約要等 6 個 block 左右的時間才可能散布到所有使用者手上</p><p>而<a href="https://zh.wikipedia.org/zh-hant/SHA%E5%AE%B6%E6%97%8F">SHA-256</a>是一種<a href="https://zh.wikipedia.org/zh-hant/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">雜湊演算法</a> (Hash algorithm)，他的公式會讓輸入的值變成長度固定的數字，例如輸入 Fox，可能會產生 DFCD3454(<a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8#/media/File:Hash_function.svg">4</a>)，他的原理有點類似拿一個質數來取餘數，如以質數 13 來做雜湊的 Base Key 的話，數字131的雜湊值就是1( 131 mod 13 = 1，就是他的餘數)，而 1 的雜湊值也是 1，而 261 的雜湊也是 1，發生了有好幾個數值Hash都相同，這個就叫做碰撞，產生碰撞的雜湊代表 Base Key 選的很爛，通常要大一點的質數才行，而SHA演算法就是以數學的角度上去確定這個碰撞的機會很小(所以才叫 &quot;Secure&quot; Hash Algorithm )</p><p>至於怎樣確定 SHA 是安全的，本人密碼學上課都在神遊，so ... 就到此為止</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;發明者: 中本聰(&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%9C%AC%E8%81%AA&quot;&gt;1&lt;/a&gt;)，但這只是化名，真實身份不明，應該是一群想撈錢的集團幹的&lt;/p&gt;
&lt;p&gt;經過: It&amp;#39;s a ver</summary>
      
    
    
    
    
    <category term="Bitcoin" scheme="http://wwssllabcd.github.io/tags/Bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>Lamobo M1( banana pi ) 安裝心得</title>
    <link href="http://wwssllabcd.github.io/2015/01/12/how-to-setup-Lamobo-m1/"/>
    <id>http://wwssllabcd.github.io/2015/01/12/how-to-setup-Lamobo-m1/</id>
    <published>2015-01-12T15:32:31.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lamobo M1 (之前比較常見的名稱為 Banana Pi, 又稱香蕉派) 跟 Raspberry pi(以下簡稱 RPI ) 一樣是屬於單版電腦，Lamobo-M1(以下簡稱 M1)而 Lamobo M1 與 Banana Pi 是同一片板子，根據該公司的說法，這是透過雙品牌的方式來運營，Banana Pi 專注於開源社群的運營</p><h1 id="評比"><a href="#評比" class="headerlink" title="評比"></a>評比</h1><p>以下為雙方比較大的差異點，見下表</p><table><thead><tr><th></th><th><a href="http://zh.wikipedia.org/wiki/%E6%A0%91%E8%8E%93%E6%B4%BE#.E7.A1.AC.E9.AB.94.E8.A7.84.E6.A0.BC.EF.BC.88Spec..EF.BC.89">Raspberry Pi Mode B</a></th><th><a href="http://lamobo.com/lamobom.html">Lamobo-M1</a></th><th>簡評</th></tr></thead><tbody><tr><td>CPU</td><td>Broadcom BCM2835 ARM11系列）700MHz</td><td><a href="http://linux-sunxi.org/A20">Allwinner A20</a> 1 GHz ARM Cortex-A7 Dual-Core</td><td>M1勝</td></tr><tr><td>GPU</td><td>Broadcom VideoCore IV @ 250 MHz</td><td>ARM Mali400MP2</td><td></td></tr><tr><td>RAM</td><td>512 M</td><td>1GB DDR3</td><td>M1勝</td></tr><tr><td>OS</td><td>支援 XBMC</td><td>支援 RPI 的 OS，也有 andorid, 但有些不能使用</td><td>各有勝負</td></tr><tr><td>sata</td><td>無</td><td>SATA*1</td><td>M1勝</td></tr><tr><td>Lan</td><td>10/100 Ethernet RJ45 x1</td><td>10/100/1000 Ethernet RJ45 x1</td><td>M1勝</td></tr></tbody></table><a id="more"></a><p>對我而言，M1 硬體的確是大勝 RPI，但我不喜歡對岸的東西，總覺得有可能會偷傳什麼資料的，除了大陸製，還有外殼難看以上這幾點外， M1的確沒什麼好挑剔的，NT 1900 就可以買到這種配備，算是佛心來著的  </p><h1 id="安裝-Raspbian"><a href="#安裝-Raspbian" class="headerlink" title="安裝 Raspbian"></a>安裝 Raspbian</h1><p>到 <a href="http://www.lemaker.org/resources/9-38/image_files.html">Lemaker OS 下載網頁</a>下載，要注意不要下載到 Pro 版本，()通常你買到的是 Banana Pi，如果你版子上有電源按鈕的話，那就是 Pro 版)，選 Raspbian 下載後解開得到 img 檔後，使用 <a href="http://sourceforge.net/projects/win32diskimager/">Win32Diskimager</a> 寫入至 SD 卡，過程與 RPI 相同，預設密碼為 <code>root/bananapi</code>，，預設電腦名稱為`lemaker&#39;，進入 OS 後，一樣可執行 Rasp-config 來修改細部設定，詳細情形與RPI相同</p><h1 id="安裝-Bananian"><a href="#安裝-Bananian" class="headerlink" title="安裝 Bananian"></a>安裝 Bananian</h1><p>到 <a href="http://www.lemaker.org/resources/9-38/image_files.html">Lemaker OS 下載網頁</a>下載，選 Raspbian 下載後解開得到 img 檔後，使用 <a href="http://sourceforge.net/projects/win32diskimager/">Win32Diskimager</a> 寫入至 SD 卡，過程與 RPI 相同，預設密碼為 <code>root/pi</code>，預設電腦名稱為<code>bananapi&#39;，進入 OS 後，可執行 </code>bananian-config` 來修改細部設定</p><h1 id="安裝-XBMC"><a href="#安裝-XBMC" class="headerlink" title="安裝 XBMC"></a>安裝 XBMC</h1><p>到 <a href="http://www.lemaker.org/resources/9-38/image_files.html">Lemaker OS 下載網頁</a>下載，選 LeMedia 後下載解壓縮完得到 img 檔後，使用 <a href="http://sourceforge.net/projects/win32diskimager/">Win32Diskimager</a> 刷入即可，不過要注意的是 LeMedia 還在開發階段，很多東西都不太能用，播放起來也很 lag，也沒聲音，簡單的來說就是 <em>XBMC for linux on Allwinner devices is NOT READY FOR USE!</em></p><h1 id="安裝-Android"><a href="#安裝-Android" class="headerlink" title="安裝 Android"></a>安裝 Android</h1><p>到 <a href="http://www.lemaker.org/resources/9-38/image_files.html">Lemaker OS 下載網頁</a>下載，選 Android，解開後得到 img 檔，但這次不能用 <a href="http://sourceforge.net/projects/win32diskimager/">Win32Diskimager</a> 來刷，要使用全志自己的卡刷工具 PhoenixCard，但是這個工具放在大陸的百度雲，下載很麻煩，打開後我卡刷也失敗，所以放棄，這邊提供<a href="http://forum.lemaker.org/cn/thread-64-1-1-Android+4.2+%E9%95%9C%E5%83%8F%E7%83%A7%E5%BD%95SD%E5%8D%A1%E6%95%99%E7%A8%8B.html">Android 詳細刷機方法</a>，有興趣可以自己參考</p><h1 id="效能"><a href="#效能" class="headerlink" title="效能"></a>效能</h1><p>因為農場是我買該機的原因，所以測試也以農場軟體相關，見下表</p><table><thead><tr><th></th><th>Raspberry pi</th><th>Lamobo-M1</th><th>簡評</th></tr></thead><tbody><tr><td>transmission-daemon</td><td>約 3MB，CPU 負載率超過 95%</td><td>輕鬆上 6MB，CPU 約 20%</td><td>M1勝</td></tr><tr><td>Samba</td><td>約 2.x MB，CUP 與 RAM 負載高</td><td>可上 9MB</td><td>M1勝</td></tr></tbody></table><p>這邊測試的是 Raspbian for Banana Pro 的 OS，而 Raspbian for Banana pi 數據只比 Raspberry Pi 好一點，我不知道為何，這個數據也許不太準，參考看看就好了，我後來改安裝 Raspbian for Banana pi ，其 transmission-daemon 的 CPU 老是給我 100%，不知哪裡有問題，不過換回去 Raspbian for Banana Pro 的就正常許多，可是我的版子又是 Banana Pi，反而要裝 For Pro 的 OS 才會比較好，真是一整個怪</p><h1 id="相關資源"><a href="#相關資源" class="headerlink" title="相關資源"></a>相關資源</h1><p>Banana pi 有其<a href="http://forum.lemaker.org/cn/forum.php">中文BPI官方論壇</a>，有中文的，但討論不熱烈，最好還是去<a href="http://forum.lemaker.org/forum.php">英文BPI官方論壇</a>比較好</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>我測兩次都有不一樣的數據，所以無從推薦，Lamobo 差就差在支援太少，雖然有很多 OS 可玩，但都只是能開機而已，就像是 XBMC 一樣，只是能開機而已，根本就是 NOT READY FOR USE  </p><p>Lamobo 目前只有看到在開農場的時候，同時使用 samba 會比較快之外，目前看不到什麼利基，若你喜歡折腾又有閒錢的話，可以試試，若要買還是<a href="http://www.raspberrypi.org/raspberry-pi-2-on-sale/">Raspberry Pi 2</a>會比較理想</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Lamobo M1 (之前比較常見的名稱為 Banana Pi, 又稱香蕉派) 跟 Raspberry pi(以下簡稱 RPI ) 一樣是屬於單版電腦，Lamobo-M1(以下簡稱 M1)
而 Lamobo M1 與 Banana Pi 是同一片板子，根據該公司的說法，這是透過雙品牌的方式來運營，Banana Pi 專注於開源社群的運營&lt;/p&gt;
&lt;h1 id=&quot;評比&quot;&gt;&lt;a href=&quot;#評比&quot; class=&quot;headerlink&quot; title=&quot;評比&quot;&gt;&lt;/a&gt;評比&lt;/h1&gt;&lt;p&gt;以下為雙方比較大的差異點，見下表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%A0%91%E8%8E%93%E6%B4%BE#.E7.A1.AC.E9.AB.94.E8.A7.84.E6.A0.BC.EF.BC.88Spec..EF.BC.89&quot;&gt;Raspberry Pi Mode B&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;http://lamobo.com/lamobom.html&quot;&gt;Lamobo-M1&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;簡評&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;Broadcom BCM2835 ARM11系列）700MHz&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://linux-sunxi.org/A20&quot;&gt;Allwinner A20&lt;/a&gt; 1 GHz ARM Cortex-A7 Dual-Core&lt;/td&gt;
&lt;td&gt;M1勝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GPU&lt;/td&gt;
&lt;td&gt;Broadcom VideoCore IV @ 250 MHz&lt;/td&gt;
&lt;td&gt;ARM Mali400MP2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAM&lt;/td&gt;
&lt;td&gt;512 M&lt;/td&gt;
&lt;td&gt;1GB DDR3&lt;/td&gt;
&lt;td&gt;M1勝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OS&lt;/td&gt;
&lt;td&gt;支援 XBMC&lt;/td&gt;
&lt;td&gt;支援 RPI 的 OS，也有 andorid, 但有些不能使用&lt;/td&gt;
&lt;td&gt;各有勝負&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sata&lt;/td&gt;
&lt;td&gt;無&lt;/td&gt;
&lt;td&gt;SATA*1&lt;/td&gt;
&lt;td&gt;M1勝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lan&lt;/td&gt;
&lt;td&gt;10/100 Ethernet RJ45 x1&lt;/td&gt;
&lt;td&gt;10/100/1000 Ethernet RJ45 x1&lt;/td&gt;
&lt;td&gt;M1勝&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 安裝教學、心得筆記</title>
    <link href="http://wwssllabcd.github.io/2014/12/22/how-to-install-hexo/"/>
    <id>http://wwssllabcd.github.io/2014/12/22/how-to-install-hexo/</id>
    <published>2014-12-22T08:48:07.000Z</published>
    <updated>2020-11-07T16:03:13.091Z</updated>
    
    <content type="html"><![CDATA[<p>自從用了 Octopress ( static page + markdown 寫 blog 後 )，我發現我回不去了以前那些所謂聰明的 blog system，以前在看 blog 的時候就超討厭 blog 自動產生一些 tag 等東西而把網頁弄得超慢，明明每次生成的東西都一樣，每一次都要自動產生的什麼鬼的，看了就不爽  </p><p>不過 Octopress 很久沒更新，且又只能限定使用 Ruby 1.9.3，造成很多不方便，所以我又跳槽到同樣是 Static Page 的 Blog System -- <a href="http://hexo.io/">Hexo</a>，特別是作者 <a href="https://twitter.com/tommy351">tommy351</a> 是台灣人，所以用起來更是愉快，這邊有<a href="http://zespia.tw/blog/2012/10/11/hexo-debut/">作者對 hexo 的介紹</a><br><img src="https://lh4.googleusercontent.com/-zW5Mdi4neqc/VJkouOcaeCI/AAAAAAAAswE/EMMODfCyNTU/s0/GitHub_icon.jpg" alt="Hexo 可建構在 GitHub 上面，為什麼放這張圖是因為它可愛 XD"></p><h1 id="安裝-Hexo"><a href="#安裝-Hexo" class="headerlink" title="安裝 Hexo "></a>安裝 Hexo </h1><h2 id="安裝-Hexo-所需檔案"><a href="#安裝-Hexo-所需檔案" class="headerlink" title="安裝 Hexo 所需檔案"></a>安裝 Hexo 所需檔案</h2><p>Hexo 是建構在 Node.js 上面，所以第一步就是安裝 Node.js，到 <a href="http://nodejs.org/">http://nodejs.org/</a> 下載並安裝，安裝好 Node.js 後，在程式集中會出現 <code>Node.js command prompt</code>，點開後會進入到命令提示字元，接下來輸入</p><pre><code>npm install hexo-cli -g</code></pre><p>而在 Ubuntu 下面安裝則要加上 sudo， 之後不再詳述此點</p><pre><code>sudo npm install hexo-cli -g</code></pre><p>安裝好後可以鍵入 hexo 看看有沒有反應，若有反應就代表安裝好了</p><pre><code>hexo # 測試 hexo 是否被正確安裝</code></pre><a id="more"></a><h2 id="建置你的-Hexo-Blog"><a href="#建置你的-Hexo-Blog" class="headerlink" title="建置你的 Hexo Blog"></a>建置你的 Hexo Blog</h2><p>選定你所要的目錄後(這邊取名叫<code>Blog</code>)，輸入</p><pre><code>hexo init Blogcd Blognpm install</code></pre><p>這樣就完成了初步的建置，這樣大致的就完成了建置了，簡單吧，若要檢視Blog可以使用</p><pre><code>hexo g  # 產生 bloghexo s  # 讓 blog 可以在 local 端檢視</code></pre><p>然後打開瀏覽器，輸入 <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000</a> 就可以看到你的 Blog 了</p><h2 id="把-Blog-放在-Github-上"><a href="#把-Blog-放在-Github-上" class="headerlink" title="把 Blog 放在 Github 上"></a>把 Blog 放在 Github 上</h2><p>首先先開一個 Repostory，取名叫 Blog 後，記住該 Repostory 的 clone 路徑後，打開本地端 Blog 中的_config.yml，尋找 <code>deploy:</code>後，type 輸入 github，repository 就去 github 那邊，把你專案的 repo 路徑抄在這，最好是選 ssh 的，branch 選 gh-pages <code>(固定，很重要，因為 github 固定以此 branch 作為網站的目錄)</code>，最後會長成像以下這個樣子</p><pre><code>deploy:    type: github    repository: git@github.com:yourname/yourRepo.git    branch: gh-pages</code></pre><p>記住，repository 後面的 yourname，請改成你的帳號，而 yourRepo 就是你剛剛取的名子，其實這個也是 git clone 使用的路徑<br>若真的不行的話，請參考<a href="http://www.jianshu.com/p/05289a4bc8b2">如何搭建一個獨立博客</a>，這邊就不再詳述  </p><p>PS: 而新版的 Hexo 已把 deploy 的方式改變，詳見 <a href="http://hexo.io/docs/deployment.html">Hexo Deployment</a>  </p><p>若發生 ERROR Deployer not found: git，請執行以下指令試試</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>接下來找到 URL 的部份，root 那邊必須要跟你的 repo 一樣，如下所示</p><pre><code># URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://xxx.github.io/Blogroot: /Blog/</code></pre><p>設好後，回到 nodejs，鍵入</p><pre><code>hexo d  # 部署 blog 到 GitHub 上</code></pre><p>就可以上傳你的 blog 到 github 了</p><h2 id="使用標準的-markdown"><a href="#使用標準的-markdown" class="headerlink" title="使用標準的 markdown"></a>使用標準的 markdown</h2><p>由於新版的 Hexo 使用 hexo-renderer-marked 來控制 Markdown ，而所以還要在調整一下，在 _config.yml 中，鍵入以下參數   </p><pre><code>marked:    gfm: true    pedantic: false    sanitize: false    tables: false    breaks: false    smartLists: false    smartypants: false</code></pre><p>其中 breaks 是控制斷行的，一般來說 markdown 是採用兩個空格( two space )來代表<code>&lt;p&gt;</code>，若喜歡用 markdown 的格式的話，這邊要設為 false，建議除了 gfm 是設 true 之外. 都設為 false 比較好  </p><h2 id="建立新文章"><a href="#建立新文章" class="headerlink" title="建立新文章"></a>建立新文章</h2><pre><code>hexo new &quot;postName&quot;  # 建立一個新的文章</code></pre><h1 id="增加其他功能"><a href="#增加其他功能" class="headerlink" title="增加其他功能"></a>增加其他功能</h1><h2 id="加入留言"><a href="#加入留言" class="headerlink" title="加入留言 "></a>加入留言 </h2><p>使用 <a href="https://disqus.com/">Disqus</a>，在_config.yml中，尋找 disqus_shortname ，並把後面加成你 Disqus 的 id </p><pre><code># Disqusdisqus_shortname: 名稱</code></pre><h2 id="加入-Google-Analytics"><a href="#加入-Google-Analytics" class="headerlink" title="加入 Google Analytics"></a>加入 Google Analytics</h2><p>Hexo 有兩個 _config.yml，一個在根目錄，一個則是 theme 使用，這邊的就要用到 theme 的 _config.yml，而以預設的 theme 來做範例，編輯 theme 目錄下的 _config.yml</p><pre><code>./themes/light/_config.yml</code></pre><p>找到<code>google_analytics:</code>後，把 ID 貼在這邊即可</p><h2 id="加入-TOC-Table-Of-Content"><a href="#加入-TOC-Table-Of-Content" class="headerlink" title="加入 TOC ( Table Of Content) "></a>加入 TOC ( Table Of Content) </h2><p>以預設的 theme 為例，在.\themes\landscape\layout_partial\article.ejs中，找到<code>&lt;%- post.content %&gt;</code>後，再把以下的段落，加在<code>&lt;%- post.content %&gt;</code>之前</p><pre><code>&lt;% if(post.toc == true)&#123; %&gt;        &lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt;            &lt;%- toc(post.content) %&gt;        &lt;/div&gt;&lt;% &#125; %&gt;</code></pre><p>以上段落就是加入 TOC 的位置，適時上可以在任何你喜歡的地方加入<br>然後在每篇文章的屬性那邊，加入</p><pre><code>toc: true </code></pre><p>就可以決定要不要打開該文章，而這邊可以利用 markdown 的<code>===</code>與<code>---</code>做 TOC 一級、二級的控制<br>題外話，這邊也可以觀察到，post 其實就是對應到文章的屬性  </p><pre><code>post.content: 文章內容post.title: 文章標題post.toc: 這邊 toc 屬性其實是自己加的，若沒設定應該是 null 的值吧</code></pre><h2 id="加入-sitemap"><a href="#加入-sitemap" class="headerlink" title="加入 sitemap "></a>加入 sitemap </h2><p>使用 sitemap 可以讓搜尋引擎可以快一點把你的網站抓回去, 加入的方法也很簡單, 鍵入</p><pre><code>npm install hexo-generator-sitemap --save</code></pre><p>然後在 <code>_config.yml</code> 中加入以下選項即可</p><pre><code>sitemap:    path: sitemap.xml</code></pre><h2 id="加入-RSS-Feed"><a href="#加入-RSS-Feed" class="headerlink" title="加入 RSS Feed "></a>加入 RSS Feed </h2><p>使用 feed 可以讓別人訂閱你的文章, 鍵入</p><pre><code>npm install hexo-generator-feed</code></pre><p>然後在 <code>_config.yml</code> 中加入</p><pre><code>#Feed Atomfeed:    type: atom    path: atom.xml    limit: 20</code></pre><p>即可</p><h1 id="從-Octopress-轉換到-Hexo"><a href="#從-Octopress-轉換到-Hexo" class="headerlink" title="從 Octopress 轉換到 Hexo"></a>從 Octopress 轉換到 Hexo</h1><p>其實要轉換不會太麻煩，只是有幾個地方要注意的就是了  </p><h2 id="網站的根目錄"><a href="#網站的根目錄" class="headerlink" title="網站的根目錄"></a>網站的根目錄</h2><p>在 _config.yml 中，網站的根目錄最好設為 <code>blog</code>(注意大小寫)，如下所示</p><pre><code>root: /blog/</code></pre><h2 id="Octopress-的文章放在-hexo-上-Compile"><a href="#Octopress-的文章放在-hexo-上-Compile" class="headerlink" title="Octopress 的文章放在 hexo 上 Compile"></a>Octopress 的文章放在 hexo 上 Compile</h2><p>文章可以直接放過去，只是 categories 要換成 tag 會比較好，不換也可以，只是 hexo 會變成 categories 而已</p><h2 id="新文章的格式"><a href="#新文章的格式" class="headerlink" title="新文章的格式"></a>新文章的格式</h2><p>Octopress 產生的 markdown 檔案是有帶日期的，但 Hexo 沒有，如果想讓 Hexo 帶日期，可以修改 _config.yml中的 <code>new_post_name</code>，改成下列格式即可</p><pre><code>new_post_name: :year-:month-:day-:title.md</code></pre><p>不過這樣改，hexo 產生文章的 link 依然是以 title 為主，這樣剛好相容於 octopress，真是太棒了  </p><h1 id="換佈景主題"><a href="#換佈景主題" class="headerlink" title="換佈景主題"></a>換佈景主題</h1><p>可先到 <a href="https://github.com/hexojs/hexo/wiki/Themes">Hexo Theme</a> 先決定好一個主題後，把該主題clone 下來，放在/theme 目錄中，如我想要換 daisy 這個主題，則需要做以下步驟</p><pre><code>git clone https://github.com/imbyron/hexo-theme-daisy.git ./themes/daisy  </code></pre><p>接著在_config.yml中，尋找 theme 這個關鍵字後，輸入剛載下來的那個目錄的名稱，如下所示</p><pre><code>theme: daisy</code></pre><h2 id="修改-default-theme-的封面"><a href="#修改-default-theme-的封面" class="headerlink" title="修改 default theme 的封面"></a>修改 default theme 的封面</h2><p>修改封面，各家的都不太一樣，要自己去找，而修改 landscape 的封面為以下兩個<br>修改封面圖案(圖片大小為 1920x1200 )</p><pre><code>YourBlogPath/themes/landscape/source/css/images/banner.jpg</code></pre><p>使用外部封面圖案</p><pre><code>YourBlogPath/themes/landscape/source/css/_variables.styl</code></pre><p>裡面的<code>banner-url = &quot;images/banner.jpg&quot;</code><br>在這邊提供一個小技巧, 因為原始的 theme 是搭配黑色為底， 所以我們可以去 Flickr 那邊找CC授權的<a href="https://www.flickr.com/search/?q=milkway">銀河(milk way)</a>照片，看到滿意的就抓下來當封面這樣就可以弄得跟預設的不一樣了</p><h2 id="修改-theme-cover"><a href="#修改-theme-cover" class="headerlink" title="修改 theme -- cover"></a>修改 theme -- cover</h2><p>Hexo 的 theme 中，有個叫 <a href="https://github.com/daisygao/hexo-themes-cover">theme cover</a> 做的蠻可愛的，也蠻乾淨的，所以這邊拿來當作範例  </p><ul><li>修改封面: 在 theme/cover下的 _comfig.yml 中修改   </li><li>修改中間的小圖: 放在/source/logo.png  </li><li>修改 brower 的 ico: 放在/source/favicon.ico</li></ul><p>而_comfig.yml中的 auto_change 最好也關掉，如果不想再文章下面出現分享到微博之類的，就把 add this 也關掉，留言系統，若想使用原本的 default 值，就把 comment_provider 槓掉即可</p><h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><h2 id="執行-hexo-d-後，出現-xxx-page-not-found"><a href="#執行-hexo-d-後，出現-xxx-page-not-found" class="headerlink" title="執行 hexo d 後，出現 xxx page not found "></a>執行 hexo d 後，出現 xxx page not found </h2><p>檢查文章檔案名稱是否包含空白</p><h2 id="執行-hexo-g-後，出現-warning-LF-will-be-replaced-by-CRLF"><a href="#執行-hexo-g-後，出現-warning-LF-will-be-replaced-by-CRLF" class="headerlink" title="執行 hexo g 後，出現 warning: LF will be replaced by CRLF"></a>執行 hexo g 後，出現 warning: LF will be replaced by CRLF</h2><p>輸入以下指令</p><pre><code>git config --global core.autocrlf false</code></pre><h2 id="在其他的地方-別台電腦-check-out-下來你的-blog-src"><a href="#在其他的地方-別台電腦-check-out-下來你的-blog-src" class="headerlink" title="在其他的地方(別台電腦) check out 下來你的 blog src  "></a>在其他的地方(別台電腦) check out 下來你的 blog src  </h2><p>因為 Hexo 的 Module 是跟著目錄的，所以如果把 code check out 下來，還是要在該目錄執行  </p><pre><code>npm install</code></pre><p>或者是</p><pre><code>npm install hexo-renderer-ejs --savenpm install hexo-renderer-marked --savenpm install hexo-renderer-stylus --save</code></pre><p>這三個，你會觀察到 ./node_modules 多了一些檔案  </p><h2 id="出現-src-refspec-master-does-not-match-any"><a href="#出現-src-refspec-master-does-not-match-any" class="headerlink" title="出現 src refspec master does not match any"></a>出現 src refspec master does not match any</h2><p>檢查一下你的 repo 是否還沒有上傳檔案，你可以先把 src 上傳之後，在做 deploy 的動作看看</p><h2 id="出現-spawn-ENOENT-at-errnoException-childprocess-js-1001-11"><a href="#出現-spawn-ENOENT-at-errnoException-childprocess-js-1001-11" class="headerlink" title="出現 spawn ENOENT at errnoException childprocess.js:1001:11"></a>出現 spawn ENOENT at errnoException childprocess.js:1001:11</h2><ul><li>輸入 git 檢查一下你的環境是否可以使用 git，如果不行的話，要把 git 加入到環境變數中才行   </li><li>輸入 node -v  檢查一下你的環境是否可以使用 node    </li><li>輸入 hexo --version 檢查一下你的環境是否可以使用 hexo   </li></ul><h2 id="出現-fatal-Could-not-read-from-remote-repository"><a href="#出現-fatal-Could-not-read-from-remote-repository" class="headerlink" title="出現 fatal: Could not read from remote repository."></a>出現 fatal: Could not read from remote repository.</h2><p>檢查 Git ssh 設定，或者是在 Git Bash 中執行</p><h2 id="出現-events-js-85-的錯誤"><a href="#出現-events-js-85-的錯誤" class="headerlink" title="出現 events.js:85 的錯誤"></a>出現 events.js:85 的錯誤</h2><p>執行 hexo d 發生錯誤，錯誤訊息如下所示</p><pre><code>INFO  Deploying: gitINFO  Clearing .deploy folder...INFO  Copying files from public folder...events.js:85    throw er; // Unhandled &#39;error&#39; event        ^Error: spawn git ENOENT    at exports._errnoException (util.js:746:11)    at Process.ChildProcess._handle.onexit (child_process.js:1053:32)    at child_process.js:1144:20    at process._tickCallback (node.js:355:11)</code></pre><p>解法: 在 Git Bash 中執行 hexo d 即可</p><h2 id="執行-hexo-d-出現-permission-denied-publickey"><a href="#執行-hexo-d-出現-permission-denied-publickey" class="headerlink" title="執行 hexo d 出現 permission denied (publickey)."></a>執行 hexo d 出現 permission denied (publickey).</h2><ul><li><p>先檢查自己的 .ssh 目錄( windows 是放在 C:\Users\yourname.ssh\  ) 有沒有放入 id_rsa</p></li><li><p>若有id_rsa檔案，但是還是有問題的話，可能是權限問題，特別是用 window 系統 copy 過去，修改成以下即可</p><p>  cd ~/.ssh  chmod 700 id_rsa</p></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://dreamerslab.com/blog/tw/how-to-setup-a-node-js-development-environment-on-windows/">如何在 Windows 上設定 node.js 的開發環境</a><br><a href="http://www.jianshu.com/p/05289a4bc8b2">如何搭建一個獨立博客——簡明Github Pages與Hexo教程</a><br><a href="http://ibruce.info/2013/11/22/hexo-your-blog/">hexo你的博客</a><br><a href="http://code.wileam.com/update-hexo/">升級hexo的一些坑</a><br><a href="http://blog.sunnyxx.com/2014/03/07/hexo_customize/">hexo的私人訂製</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自從用了 Octopress ( static page + markdown 寫 blog 後 )，我發現我回不去了以前那些所謂聰明的 blog system，以前在看 blog 的時候就超討厭 blog 自動產生一些 tag 等東西而把網頁弄得超慢，
明明每次生成的東西都一樣，每一次都要自動產生的什麼鬼的，看了就不爽  &lt;/p&gt;
&lt;p&gt;不過 Octopress 很久沒更新，且又只能限定使用 Ruby 1.9.3，造成很多不方便，所以我又跳槽到同樣是 Static Page 的 Blog System -- &lt;a href=&quot;http://hexo.io/&quot;&gt;Hexo&lt;/a&gt;，
特別是作者 &lt;a href=&quot;https://twitter.com/tommy351&quot;&gt;tommy351&lt;/a&gt; 是台灣人，所以用起來更是愉快，
這邊有&lt;a href=&quot;http://zespia.tw/blog/2012/10/11/hexo-debut/&quot;&gt;作者對 hexo 的介紹&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://lh4.googleusercontent.com/-zW5Mdi4neqc/VJkouOcaeCI/AAAAAAAAswE/EMMODfCyNTU/s0/GitHub_icon.jpg&quot; alt=&quot;Hexo 可建構在 GitHub 上面，為什麼放這張圖是因為它可愛 XD&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;安裝-Hexo&quot;&gt;&lt;a href=&quot;#安裝-Hexo&quot; class=&quot;headerlink&quot; title=&quot;安裝 Hexo &quot;&gt;&lt;/a&gt;安裝 Hexo &lt;/h1&gt;&lt;h2 id=&quot;安裝-Hexo-所需檔案&quot;&gt;&lt;a href=&quot;#安裝-Hexo-所需檔案&quot; class=&quot;headerlink&quot; title=&quot;安裝 Hexo 所需檔案&quot;&gt;&lt;/a&gt;安裝 Hexo 所需檔案&lt;/h2&gt;&lt;p&gt;Hexo 是建構在 Node.js 上面，所以第一步就是安裝 Node.js，到 &lt;a href=&quot;http://nodejs.org/&quot;&gt;http://nodejs.org/&lt;/a&gt; 下載並安裝，
安裝好 Node.js 後，在程式集中會出現 &lt;code&gt;Node.js command prompt&lt;/code&gt;，點開後會進入到命令提示字元，接下來輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-cli -g&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在 Ubuntu 下面安裝則要加上 sudo， 之後不再詳述此點&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo npm install hexo-cli -g&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安裝好後可以鍵入 hexo 看看有沒有反應，若有反應就代表安裝好了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo # 測試 hexo 是否被正確安裝&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Hexo" scheme="http://wwssllabcd.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Firefox addon-SDK 介紹, page-mod</title>
    <link href="http://wwssllabcd.github.io/2014/12/21/building-an-extension-for-firefox-PageMod/"/>
    <id>http://wwssllabcd.github.io/2014/12/21/building-an-extension-for-firefox-PageMod/</id>
    <published>2014-12-21T08:45:54.000Z</published>
    <updated>2016-06-05T16:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用時機"><a href="#使用時機" class="headerlink" title="使用時機"></a>使用時機</h1><p>今天要介紹的是 Firefox addon-SDK 中的 <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/page-mod">page-mod</a>, 使用時機為<code>想要把讀回來的網頁, 再加以修改</code>, 例如</p><ol><li>把某網站的排版重新排一下, 例如台鐵的火車時刻表</li><li>想把某些網站廣告區塊移除掉</li><li>想把網頁中特定資訊給顯現出來, 例如某影音網站的影片下載連結</li></ol><p>就可以使用這個, 使用的方式如下</p><h1 id="page-mode-簡介"><a href="#page-mode-簡介" class="headerlink" title="page-mode 簡介"></a>page-mode 簡介</h1><p>官方給的範例如下  </p><pre><code>var pageMod = require(&quot;sdk/page-mod&quot;);pageMod.PageMod(&#123;    include: &quot;*.mozilla.org&quot;,    contentScript: &#39;window.alert(&quot;Page matches ruleset&quot;);&#39;&#125;);</code></pre><a id="more"></a><p>這邊簡單的說明使用方式  </p><pre><code>include: 要對哪個 url 做動作, 符合的才會做接下來的動作  contentScript: 符合include 的條件後, 接下來的動作</code></pre><p>以上程式碼意思為假若 url 是 <code>*.mozilla.org</code> 的話, 則會跳出訊息<code>Page matches ruleset</code>, 當然簡單的 JS 可以這樣弄, 比較複雜的 JS 建議使用 file, 如下所示</p><pre><code>pageMod.PageMod(&#123;    include: &quot;*.mozilla.org&quot;,    contentScriptFile: &quot;./my-script.js&quot;&#125;);</code></pre><p>這邊從 <code>contentScript</code> 變成了 <code>contentScriptFile</code>, 然後 <code>./my-script.js</code> 的路徑是在 <code>/data</code> 區, 來看看<code>my-script.js</code>裡面長怎樣吧   </p><pre><code>//my-script.jswindow.alert(&quot;Page matches ruleset&quot;);   </code></pre><p>只有一行, 其實就是把 contentScript 中的括號拿掉, 就是.js中的內容了</p><h1 id="實戰-製作某影音網站的下載器"><a href="#實戰-製作某影音網站的下載器" class="headerlink" title="實戰 -- 製作某影音網站的下載器"></a>實戰 -- 製作某影音網站的下載器</h1><p>先來看一下 main.js, 當然, 目標網站的網址被我馬賽克掉了:D    </p><pre><code>var pageMod = require(&quot;sdk/page-mod&quot;);var targeURL = &quot;http://www.thisXX.com/video/*&quot;pageMod.PageMod(&#123;    include: targeURL,    contentScriptFile: &quot;./my-script.js&quot;&#125;);</code></pre><p>main.js 一如往常的簡單, 這邊說明了要針對哪個網站做動作外就沒事了, 一樣的我們把難的工作交給外部的 Java Script 檔案  </p><h2 id="找出下載連結"><a href="#找出下載連結" class="headerlink" title="找出下載連結"></a>找出下載連結</h2><p>我們的目標就是該網頁的唯一的 flv 連結 -- <code>即 http 開頭, .flv結尾</code>, 先做一個 function 來取連結</p><pre><code>var getFlvUrl = function(source)&#123;    // find .flv    var endWord = &quot;.flv&quot;;    var endPtr = source.indexOf(endWord);    var startIdx = source.lastIndexOf(&quot;http://&quot;, endPtr);    var len = endWord.length;    return source.substring(startIdx, endPtr + len  );&#125;</code></pre><p>這邊使用 indexOf 來找連結, 事實上用 regualr express 應該會更簡單, 之後再改善即可  </p><h2 id="在原網頁中-加入下載連結"><a href="#在原網頁中-加入下載連結" class="headerlink" title="在原網頁中, 加入下載連結"></a>在原網頁中, 加入下載連結</h2><p>接下來就是找一個地方放這個連結, 但如果隨便放的話, 有可能或破壞原始網頁的結構, 所以最好網頁還是一樣維持原狀, 只是在某個地方偷偷插入一段下載連結, 先來做一個超連結的 html code, 然後再把這段 code 插入原來的網頁</p><pre><code>var downloadInfo = &quot;&lt;P&gt;&lt;a href=&quot; + url + &quot;&gt;&quot; + url + &quot;&lt;/a&gt;&lt;P&gt;&quot;;</code></pre><p>接下來就是製作插入的 function, 這邊的概念也很簡單, 給定一個插入的目標還有字串, 先利用keyword 找出插入的點後, 利用substring 把原始網頁一分為二,接下來就是返還修改過的網頁, 一整個超簡單  </p><pre><code>var insertString = function(source, msg, keyword)&#123;    var idx = source.indexOf(keyword) + keyword.length;    var front = source.substring(0, idx);    var back =  source.substring(idx, source.length);        return front + msg + back;&#125;</code></pre><h2 id="把所有東西組裝起來"><a href="#把所有東西組裝起來" class="headerlink" title="把所有東西組裝起來"></a>把所有東西組裝起來</h2><p>最後就是把工具都組合起來, 這邊採用<code>點擊</code>兩字當作插入的關鍵字位置, 利用 <code>getFlvUrl(</code>) 取出 url, 利用 <code>insertString()</code> 插入下載連結後, 返還修改過的 html code 給瀏覽器    </p><pre><code>var url = getFlvUrl(document.body.innerHTML); var insert = &quot;&lt;P&gt;&lt;a href=&quot; + url + &quot;&gt;&quot; + url + &quot;&lt;/a&gt;&lt;P&gt;&quot;;var html = insertString(document.body.innerHTML, insert, &quot;點擊&quot;);document.body.innerHTML = html;</code></pre><p>整個<code>my-script.js</code>如下所示</p><pre><code>//my-script.jsvar getFlvUrl = function(source)&#123;    // find .flv    var endWord = &quot;.flv&quot;;    var endPtr = source.indexOf(endWord);    var startIdx = source.lastIndexOf(&quot;http://&quot;, endPtr);    var len = endWord.length;    return source.substring(startIdx, endPtr + len  );&#125;var insertString = function(source, msg, keyword)&#123;    var idx = source.indexOf(keyword) + keyword.length;    var front = source.substring(0, idx);    var back =  source.substring(idx, source.length);    return front + msg + back;&#125;var url = getFlvUrl(document.body.innerHTML); var insert = &quot;&lt;P&gt;&lt;a href=&quot; + url + &quot;&gt;&quot; + url + &quot;&lt;/a&gt;&lt;P&gt;&quot;;var html = insertString(document.body.innerHTML, insert, &quot;點擊&quot;);document.body.innerHTML = html;</code></pre><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>Firefox 的 addon-SDK 其實把很多事情都簡化了, 做一個附加元件其實很簡單的</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用時機&quot;&gt;&lt;a href=&quot;#使用時機&quot; class=&quot;headerlink&quot; title=&quot;使用時機&quot;&gt;&lt;/a&gt;使用時機&lt;/h1&gt;&lt;p&gt;今天要介紹的是 Firefox addon-SDK 中的 &lt;a href=&quot;https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/page-mod&quot;&gt;page-mod&lt;/a&gt;, 使用時機為&lt;code&gt;想要把讀回來的網頁, 再加以修改&lt;/code&gt;, 
例如&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把某網站的排版重新排一下, 例如台鐵的火車時刻表&lt;/li&gt;
&lt;li&gt;想把某些網站廣告區塊移除掉&lt;/li&gt;
&lt;li&gt;想把網頁中特定資訊給顯現出來, 例如某影音網站的影片下載連結&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就可以使用這個, 使用的方式如下&lt;/p&gt;
&lt;h1 id=&quot;page-mode-簡介&quot;&gt;&lt;a href=&quot;#page-mode-簡介&quot; class=&quot;headerlink&quot; title=&quot;page-mode 簡介&quot;&gt;&lt;/a&gt;page-mode 簡介&lt;/h1&gt;&lt;p&gt;官方給的範例如下  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var pageMod = require(&amp;quot;sdk/page-mod&amp;quot;);
pageMod.PageMod(&amp;#123;
    include: &amp;quot;*.mozilla.org&amp;quot;,
    contentScript: &amp;#39;window.alert(&amp;quot;Page matches ruleset&amp;quot;);&amp;#39;
&amp;#125;);&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Firefox extension" scheme="http://wwssllabcd.github.io/tags/Firefox-extension/"/>
    
  </entry>
  
  <entry>
    <title>打造一個 Firefox 附加元件</title>
    <link href="http://wwssllabcd.github.io/2014/05/03/building-an-extension-for-firefox/"/>
    <id>http://wwssllabcd.github.io/2014/05/03/building-an-extension-for-firefox/</id>
    <published>2014-05-02T17:32:00.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="開始之前"><a href="#開始之前" class="headerlink" title="開始之前"></a>開始之前</h1><p>以下會介紹 Mozilla 所推出的 Add-on SDK, 並且用它來打造你第一個 Firefox extension，要做的套件功能是利用 Add-on SDK 抓取匯率網站的資料，重新整理之後顯示出來  </p><p>首先先建立開發平台, 以下是需要的工具, 分別是 addon-sdk, python, firefox<img src="https://lh6.googleusercontent.com/-z0GbZ6KBNSA/VJexItwKtsI/AAAAAAAAsuM/2tHAspCDwrs/s0/Prerequisites.jpg" alt="Prerequisites"></p><ul><li><p>addon-sdk 請到 <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Installation">Mozilla 官網下載</a>, 下載完解壓縮後, 放在你喜歡的地方即可( 如 d:\project\addon-sdk)</p></li><li><p>除了 addon-sdk 外, 也需要 <a href="http://zh.wikipedia.org/zh-tw/Python">Python</a>, 由於我的平台是 windows, 所以就裝了 <a href="https://www.python.org/downloads/">Python for win</a>, 雖然有 <code>2.7.6</code>與 <code>3.4.0</code> 可以選擇, 不過mozilla 建議裝 2.7.X 的比較好, 安裝步驟就是下一步一直按下去, 沒難度.</p></li></ul><p>都安裝好了之後, 就使用<a href="http://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E5%AD%97%E5%85%83">命令提示字元</a>(以下簡稱 command line), 到 addon-sdk 下面接下來鍵入    bin\activate就會看到命令提示字元變得不太一樣了, 如下狀況<img src="https://lh4.googleusercontent.com/-zx2gUQKNiDA/VJexI1cktEI/AAAAAAAAsuI/Up_TR96b8Hw/s0/activate.jpg" alt="activate">  </p><p>這時候就是進入了 addon-sdk 開發模式, 不過這個動作在每一次關掉 command line 就要重複一次, 所以最好的做法還是把這一連串的啟動動作做成批次檔如下(我 addon-sdk 放在 d:\addon-sdk)</p><pre><code>d:cd\addon-sdkbin\activate</code></pre><a id="more"></a><h1 id="建立一個新的專案"><a href="#建立一個新的專案" class="headerlink" title="建立一個新的專案"></a>建立一個新的專案</h1><p>根據上一步, 啟動了addon-sdk 後, 在你想要的地方開始建立專案資料夾, 並且 initial 他</p><pre><code>mkdir my_addoncd my_addoncfx init</code></pre><p>執行起來大概長這樣<br><img src="https://lh6.googleusercontent.com/--JE6-Q96vNg/VJexJkW8erI/AAAAAAAAsuY/dHz8BMapgsM/s0/cfxInit.jpg" alt="cfxInit">  </p><h1 id="開始第一支程式-Hello-World"><a href="#開始第一支程式-Hello-World" class="headerlink" title="開始第一支程式 -- Hello World"></a>開始第一支程式 -- Hello World</h1><p>目錄中的 lib 的資料夾, 裡面有個 <code>main.js</code>, 則是套件的起點, 用編輯器打開, 鍵入以下程式碼</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var widgets &#x3D; require(&quot;sdk&#x2F;widget&quot;).Widget;</span><br><span class="line">myWedget &#x3D; widgets(&#123;</span><br><span class="line">id: &quot;I-am-wedget&quot;,</span><br><span class="line">label: &quot;wedget&quot;,</span><br><span class="line">content: &quot;Hello World!&quot;,</span><br><span class="line">tooltip: &quot;I-am-tooltip&quot;,</span><br><span class="line">width: 100</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>把<code>main.js</code>編碼選擇 UTF-8 後儲存關閉, 接下來就可以看看效果如何了<br>鍵入 </p><pre><code>cfx run</code></pre><p>之後就會跳出一個乾淨的 Firefox, 並且上面有你剛做的套件, 基本上 Wedget 算是顯示用的, 很簡單吧<img src="https://lh4.googleusercontent.com/-j8rzmz7qQeg/VJexKJ9PyhI/AAAAAAAAsug/oCEDsbIeVnU/s0/helloworld.jpg" alt="HelloWorld">  </p><h2 id="有關資源的存取"><a href="#有關資源的存取" class="headerlink" title="有關資源的存取"></a>有關資源的存取</h2><p>my_addon 目錄會出現數個資料夾, 如lib, data, doc, test 等, 其中 data 區對應到 code 裡面的 resource 的根目錄,如<code>./a.png</code>的意思就是代表存取 data 區裡面的 a.png 的意思，如果要用到外部的 JavaScript file ，也是放在 ./data中  </p><h2 id="放出-Message"><a href="#放出-Message" class="headerlink" title="放出 Message "></a>放出 Message </h2><p>使用 console.log 即可，如下所示  </p><pre><code>console.log(&quot;A= %D&quot;, 100)</code></pre><h1 id="實戰-製作一個抓取匯率的套件"><a href="#實戰-製作一個抓取匯率的套件" class="headerlink" title="實戰 -- 製作一個抓取匯率的套件"></a>實戰 -- 製作一個抓取匯率的套件</h1><h2 id="抓取某銀行網頁匯率的資料-使用-page-worker-取回網頁"><a href="#抓取某銀行網頁匯率的資料-使用-page-worker-取回網頁" class="headerlink" title="抓取某銀行網頁匯率的資料, 使用 page-worker 取回網頁"></a>抓取某銀行網頁匯率的資料, 使用 page-worker 取回網頁</h2><p>此時就要用 <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/page-worker">page-worker</a> 來幫你實現了, 延續剛剛的 Wedget, 這次我們來抓某個網頁的資料, 並且用 tooltip 的方式, 把它顯示在 Wedget 上面  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var widgets &#x3D; require(&quot;sdk&#x2F;widget&quot;).Widget;</span><br><span class="line">myWedget &#x3D; widgets(&#123;</span><br><span class="line">id: &quot;I-am-wedget&quot;,</span><br><span class="line">label: &quot;wedget&quot;,</span><br><span class="line">content: &quot;Hello World!&quot;,</span><br><span class="line">tooltip: &quot;I-am-tooltip&quot;,</span><br><span class="line">width: 100</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var pageWorkers &#x3D; require(&quot;sdk&#x2F;page-worker&quot;);</span><br><span class="line">var myWedget, myPW</span><br><span class="line">var script &#x3D; &quot;postMessage(document.body.innerHTML);&quot;;</span><br><span class="line">var targetURL &#x3D; &quot;http:&#x2F;&#x2F;rate.bot.com.tw&#x2F;Pages&#x2F;Static&#x2F;UIP003.zh-TW.htm&quot;;</span><br><span class="line"></span><br><span class="line">myPW &#x3D; pageWorkers.Page(&#123;</span><br><span class="line">contentURL: targetURL,</span><br><span class="line">contentScript: script,</span><br><span class="line">contentScriptWhen: &quot;ready&quot;,</span><br><span class="line">onMessage: function(message) &#123;</span><br><span class="line">myWedget.tooltip &#x3D; message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>這邊說明一下 PageWorkers 的屬性部分  </p><ul><li>contentURL: 代表的是要抓的 url</li><li>contentScript: 代表的是,抓回來要做什麼要的處理, 這邊我們只有把 document.body.innerHTML 藉由 postMessage 傳送出去</li><li>onMessage: 則負責接收 postMessage 丟出來的訊息, 也就是該網頁的 innerHTML 了, 並且把他設給 Wedget 的 tooltip </li></ul><p>我隨便選一個提供匯率的網頁, 並且把他設定給 targetURL, 他會把該網頁的 html, 顯示成為 Wedget 的 tooltip 上面, 原本把滑鼠移上去會顯示 <code>I-am-tooltip</code>, 現在已經變成亂七八糟的 html code 了, 如下所示<img src="https://lh5.googleusercontent.com/-QG7ut0HyUXo/VJexKX3oBrI/AAAAAAAAsuk/qIfCLqA8x50/s0/htmlCode.jpg" alt="htmlCode">  </p><h2 id="進一步的清理網頁資料"><a href="#進一步的清理網頁資料" class="headerlink" title="進一步的清理網頁資料"></a>進一步的清理網頁資料</h2><p>接下來就有點是 dirty work 了, 我們如果要把每個匯率的資料抓出來的話, 要怎做?<br>先觀察 html, 發現在匯率前面都會有串字串叫</p><pre><code>&quot;/Images/Flags/America.gif&quot;</code></pre><p>結束的字串都是為</p><pre><code>&quot;&lt;/td&gt;&lt;td class=&quot;</code></pre><p>我們利用這兩個字串當作識別項, 試看看能否把匯率的值給抓出來  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var findKeyWord &#x3D; function(keyWord, source, cellNo)</span><br><span class="line">&#123;</span><br><span class="line">var startWord &#x3D; &quot;&#x2F;Images&#x2F;Flags&#x2F;America.gif&quot;;</span><br><span class="line">var endWord &#x3D; &quot;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通常是Table的起始</span><br><span class="line">var startIdx &#x3D; source.indexOf(startWord);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從table的起點往後找KeyWord</span><br><span class="line">var keyWordIdx &#x3D; source.indexOf(keyWord,startIdx);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從keyword往後找結束符號</span><br><span class="line">var temp &#x3D; keyWordIdx;</span><br><span class="line">for(i&#x3D;0; i&lt;cellNo; i++)&#123;</span><br><span class="line">temp &#x3D; source.indexOf(endWord,temp)+1;</span><br><span class="line">&#125;</span><br><span class="line">endIdx &#x3D; temp-1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從EndIndex往前找，找&gt;關鍵字，但是要往前移一個</span><br><span class="line">var curIdx &#x3D; source.lastIndexOf(&quot;&gt;&quot;,endIdx)+1;</span><br><span class="line">return source.substring(curIdx,endIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>傳入要找的關鍵字(keyword), 資料來源(source), 還有要取第幾格的號碼(cellNo)來取出特定格數的資料出來, 貌似可以做到.  </p><p>再加點輔助程式吧, 現在只要呼叫 getResult 並且把 html 傳入的話, 就會得到完整的匯率表了  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">var getResult &#x3D; function(msg)&#123;</span><br><span class="line">var res &#x3D; &quot;&quot;;</span><br><span class="line">res +&#x3D; &quot;幣別： 現金買入 , 即期買入&quot;;</span><br><span class="line">res +&#x3D; getOneString(&quot;美金 ：&quot;, &quot;美金 (USD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;港幣 ：&quot;, &quot;港幣 (HKD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;英鎊 ：&quot;, &quot;英鎊 (GBP)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;澳幣 ：&quot;, &quot;澳幣 (AUD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;加拿大幣：&quot;, &quot;加拿大幣 (CAD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;新加坡幣：&quot;, &quot;新加坡幣 (SGD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;新加坡幣：&quot;, &quot;瑞士法朗 (CHF)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;日圓 ：&quot;, &quot;日圓 (JPY)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;南非幣 ：&quot;, &quot;南非幣 (ZAR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;瑞典幣 ：&quot;, &quot;瑞典幣 (SEK)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;紐元 ：&quot;, &quot;紐元 (NZD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;泰幣 ：&quot;, &quot;泰幣 (THB)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;菲國比索：&quot;, &quot;菲國比索 (PHP)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;印尼幣 ：&quot;, &quot;印尼幣 (IDR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;歐元 ：&quot;, &quot;歐元 (EUR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;韓元 ：&quot;, &quot;韓元 (KRW)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;越南盾 ：&quot;, &quot;越南盾 (VND)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;馬來幣 ：&quot;, &quot;馬來幣 (MYR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;人民幣 ：&quot;, &quot;人民幣 (CNY)&quot;, msg);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getOneString &#x3D; function(title, keyWord, html)&#123;</span><br><span class="line">var res_1, res_2;</span><br><span class="line">var res &#x3D; &quot;&quot;;</span><br><span class="line">res_1 &#x3D; findKeyWord(keyWord, html, 2);</span><br><span class="line">res_2 &#x3D; findKeyWord(keyWord, html, 4);</span><br><span class="line">res &#x3D; &quot;\n&quot; + title + res_1 + &quot;, &quot; + res_2;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var findKeyWord &#x3D; function(keyWord, source, cellNo)</span><br><span class="line">&#123;</span><br><span class="line">var startWord &#x3D; &quot;&#x2F;Images&#x2F;Flags&#x2F;America.gif&quot;;</span><br><span class="line">var endWord &#x3D; &quot;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通常是Table的起始</span><br><span class="line">var startIdx &#x3D; source.indexOf(startWord);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從table的起點往後找KeyWord</span><br><span class="line">var keyWordIdx &#x3D; source.indexOf(keyWord,startIdx);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從keyword往後找結束符號</span><br><span class="line">var temp &#x3D; keyWordIdx;</span><br><span class="line">for(i&#x3D;0; i&lt;cellNo; i++)&#123;</span><br><span class="line">temp &#x3D; source.indexOf(endWord,temp)+1;</span><br><span class="line">&#125;</span><br><span class="line">endIdx &#x3D; temp-1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從EndIndex往前找，找&gt;關鍵字，但是要往前移一個</span><br><span class="line">var curIdx &#x3D; source.lastIndexOf(&quot;&gt;&quot;,endIdx)+1;</span><br><span class="line">return source.substring(curIdx,endIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很髒很麻煩, 且一旦該網頁換掉格式就沒用了, 不是嗎?<br>我也沒辦法, 不推 API介接, 不推開放資料統一格式就是這樣麻煩, 先不提了.<br>現在我們只要在 pageWorkers 的 onMessage 加上 剛新作的 function -- getResult 就可以了   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onMessage: function(message) &#123;</span><br><span class="line">myWedget.tooltip &#x3D; getResult(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把所有東西組裝起來"><a href="#把所有東西組裝起來" class="headerlink" title="把所有東西組裝起來"></a>把所有東西組裝起來</h2><p>來看看效果吧, 很簡單吧<br><img src="https://lh6.googleusercontent.com/-XLs50aKm4qc/VJexK0N9uwI/AAAAAAAAsuw/YTqSzO1Pad0/s0/result.jpg" alt="result">  </p><p>我再把整個程式整理一下,大家可以參考  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">var widgets &#x3D; require(&quot;sdk&#x2F;widget&quot;).Widget;</span><br><span class="line">var pageWorkers &#x3D; require(&quot;sdk&#x2F;page-worker&quot;);</span><br><span class="line">var myWedget, myPW</span><br><span class="line"></span><br><span class="line">myWedget &#x3D; widgets(&#123;</span><br><span class="line">id: &quot;erw-wedget&quot;,</span><br><span class="line">label: &quot;erw&quot;,</span><br><span class="line">content: &quot;即時匯率&quot;,</span><br><span class="line">tooltip: &quot;wait ready&quot;,</span><br><span class="line">width: 50</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">var script &#x3D; &quot;postMessage(document.body.innerHTML);&quot;;</span><br><span class="line">var targetURL &#x3D; &quot;http:&#x2F;&#x2F;rate.bot.com.tw&#x2F;Pages&#x2F;Static&#x2F;UIP003.zh-TW.htm&quot;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">myPW &#x3D; pageWorkers.Page(&#123;</span><br><span class="line">contentURL: targetURL,</span><br><span class="line">contentScript: script,</span><br><span class="line">contentScriptWhen: &quot;ready&quot;,</span><br><span class="line">onMessage: function(message) &#123;</span><br><span class="line">myWedget.tooltip &#x3D; getResult(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var getResult &#x3D; function(msg)&#123;</span><br><span class="line">var res &#x3D; &quot;&quot;;</span><br><span class="line">res +&#x3D; &quot;幣別： 現金買入 , 即期買入&quot;;</span><br><span class="line">res +&#x3D; getOneString(&quot;美金 ：&quot;, &quot;美金 (USD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;港幣 ：&quot;, &quot;港幣 (HKD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;英鎊 ：&quot;, &quot;英鎊 (GBP)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;澳幣 ：&quot;, &quot;澳幣 (AUD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;加拿大幣：&quot;, &quot;加拿大幣 (CAD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;新加坡幣：&quot;, &quot;新加坡幣 (SGD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;新加坡幣：&quot;, &quot;瑞士法朗 (CHF)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;日圓 ：&quot;, &quot;日圓 (JPY)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;南非幣 ：&quot;, &quot;南非幣 (ZAR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;瑞典幣 ：&quot;, &quot;瑞典幣 (SEK)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;紐元 ：&quot;, &quot;紐元 (NZD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;泰幣 ：&quot;, &quot;泰幣 (THB)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;菲國比索：&quot;, &quot;菲國比索 (PHP)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;印尼幣 ：&quot;, &quot;印尼幣 (IDR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;歐元 ：&quot;, &quot;歐元 (EUR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;韓元 ：&quot;, &quot;韓元 (KRW)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;越南盾 ：&quot;, &quot;越南盾 (VND)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;馬來幣 ：&quot;, &quot;馬來幣 (MYR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;人民幣 ：&quot;, &quot;人民幣 (CNY)&quot;, msg);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getOneString &#x3D; function(title, keyWord, html)&#123;</span><br><span class="line">var res_1, res_2;</span><br><span class="line">var res &#x3D; &quot;&quot;;</span><br><span class="line">res_1 &#x3D; findKeyWord(keyWord, html, 2);</span><br><span class="line">res_2 &#x3D; findKeyWord(keyWord, html, 4);</span><br><span class="line">res &#x3D; &quot;\n&quot; + title + res_1 + &quot;, &quot; + res_2;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var findKeyWord &#x3D; function(keyWord, source, cellNo)&#123;</span><br><span class="line">var startWord &#x3D; &quot;&#x2F;Images&#x2F;Flags&#x2F;America.gif&quot;;</span><br><span class="line">var endWord &#x3D; &quot;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通常是Table的起始</span><br><span class="line">var startIdx &#x3D; source.indexOf(startWord);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從table的起點往後找KeyWord</span><br><span class="line">var keyWordIdx &#x3D; source.indexOf(keyWord,startIdx);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從keyword往後找結束符號</span><br><span class="line">var temp &#x3D; keyWordIdx;</span><br><span class="line">for(i&#x3D;0; i&lt;cellNo; i++)&#123;</span><br><span class="line">temp &#x3D; source.indexOf(endWord,temp)+1;</span><br><span class="line">&#125;</span><br><span class="line">endIdx &#x3D; temp-1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從EndIndex往前找，找&gt;關鍵字，但是要往前移一個</span><br><span class="line">var curIdx &#x3D; source.lastIndexOf(&quot;&gt;&quot;,endIdx)+1;</span><br><span class="line">return source.substring(curIdx,endIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>其實 Mozilla 也有出<a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Installation">官方教學</a>, 大家也可以參考看看</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;開始之前&quot;&gt;&lt;a href=&quot;#開始之前&quot; class=&quot;headerlink&quot; title=&quot;開始之前&quot;&gt;&lt;/a&gt;開始之前&lt;/h1&gt;&lt;p&gt;以下會介紹 Mozilla 所推出的 Add-on SDK, 並且用它來打造你第一個 Firefox extension，要做的套件功能是利用 Add-on SDK 抓取匯率網站的資料，重新整理之後顯示出來  &lt;/p&gt;
&lt;p&gt;首先先建立開發平台, 以下是需要的工具, 分別是 addon-sdk, python, firefox
&lt;img src=&quot;https://lh6.googleusercontent.com/-z0GbZ6KBNSA/VJexItwKtsI/AAAAAAAAsuM/2tHAspCDwrs/s0/Prerequisites.jpg&quot; alt=&quot;Prerequisites&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;addon-sdk 請到 &lt;a href=&quot;https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Installation&quot;&gt;Mozilla 官網下載&lt;/a&gt;, 
下載完解壓縮後, 放在你喜歡的地方即可( 如 d:\project\addon-sdk)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除了 addon-sdk 外, 也需要 &lt;a href=&quot;http://zh.wikipedia.org/zh-tw/Python&quot;&gt;Python&lt;/a&gt;, 由於我的平台是 windows, 所以就裝了 &lt;a href=&quot;https://www.python.org/downloads/&quot;&gt;Python for win&lt;/a&gt;, 
雖然有 &lt;code&gt;2.7.6&lt;/code&gt;與 &lt;code&gt;3.4.0&lt;/code&gt; 可以選擇, 不過mozilla 建議裝 2.7.X 的比較好, 安裝步驟就是下一步一直按下去, 沒難度.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;都安裝好了之後, 就使用&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E5%AD%97%E5%85%83&quot;&gt;命令提示字元&lt;/a&gt;(以下簡稱 command line), 到 addon-sdk 下面
接下來鍵入
    bin\activate
就會看到命令提示字元變得不太一樣了, 如下狀況
&lt;img src=&quot;https://lh4.googleusercontent.com/-zx2gUQKNiDA/VJexI1cktEI/AAAAAAAAsuI/Up_TR96b8Hw/s0/activate.jpg&quot; alt=&quot;activate&quot;&gt;  &lt;/p&gt;
&lt;p&gt;這時候就是進入了 addon-sdk 開發模式, 不過這個動作在每一次關掉 command line 就要重複一次, 所以最好的做法還是把這一連串的啟動動作做成批次檔如下(我 addon-sdk 放在 d:\addon-sdk)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;d:
cd\addon-sdk
bin\activate&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Firefox extension" scheme="http://wwssllabcd.github.io/tags/Firefox-extension/"/>
    
  </entry>
  
</feed>
