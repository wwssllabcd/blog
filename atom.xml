<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>printf(&quot; I&#39;m EricWang &quot;)</title>
  
  
  <link href="http://wwssllabcd.github.io/atom.xml" rel="self"/>
  
  <link href="http://wwssllabcd.github.io/"/>
  <updated>2021-02-10T05:19:47.291Z</updated>
  <id>http://wwssllabcd.github.io/</id>
  
  <author>
    <name>EricWang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>從零開始的 Gameboy 模擬器開發 -- Step 2</title>
    <link href="http://wwssllabcd.github.io/2021/02/10/how-to-build-a-gameboy-emulator-2/"/>
    <id>http://wwssllabcd.github.io/2021/02/10/how-to-build-a-gameboy-emulator-2/</id>
    <published>2021-02-09T16:24:46.000Z</published>
    <updated>2021-02-10T05:19:47.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立-opcode-map"><a href="#建立-opcode-map" class="headerlink" title="建立 opcode map "></a>建立 opcode map </h2><p>在開始之前讀取第一道指令之前，我們要做一件很不有趣的事情，就是建立所有 op code 的 map</p><p>首先我們建立 opcode_map.c，裡面的內容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void not_support_cb_code() &#123; ASSERT_CODE(0, &quot;not support CB code&quot;); &#125;</span><br><span class="line">void not_support_op_code() &#123; ASSERT_CODE(0, &quot;not support op code&quot;); &#125;</span><br><span class="line"></span><br><span class="line">void op_00() &#123; not_support_op_code(); &#125;</span><br><span class="line">.......</span><br><span class="line">void op_FF() &#123; not_support_op_code(); &#125;</span><br><span class="line"></span><br><span class="line">void op_cb_00() &#123; not_support_cb_code(); &#125;</span><br><span class="line">.......</span><br><span class="line">void op_cb_FF() &#123; not_support_cb_code(); &#125;</span><br><span class="line"></span><br><span class="line">opcode_fun g_opcode_fun_map[0x100] &#x3D; &#123;</span><br><span class="line">    GEN_FUN_MAP(, 0), GEN_FUN_MAP(, 1), GEN_FUN_MAP(, 2), GEN_FUN_MAP(, 3),</span><br><span class="line">    GEN_FUN_MAP(, 4), GEN_FUN_MAP(, 5), GEN_FUN_MAP(, 6), GEN_FUN_MAP(, 7),</span><br><span class="line">    GEN_FUN_MAP(, 8), GEN_FUN_MAP(, 9), GEN_FUN_MAP(, A), GEN_FUN_MAP(, B),</span><br><span class="line">    GEN_FUN_MAP(, C), GEN_FUN_MAP(, D), GEN_FUN_MAP(, E), GEN_FUN_MAP(, F)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">opcode_fun g_opcode_cb_fun_map[0x100] &#x3D; &#123;</span><br><span class="line">    GEN_FUN_MAP(cb_, 0), GEN_FUN_MAP(cb_, 1), GEN_FUN_MAP(cb_, 2), GEN_FUN_MAP(cb_, 3),</span><br><span class="line">    GEN_FUN_MAP(cb_, 4), GEN_FUN_MAP(cb_, 5), GEN_FUN_MAP(cb_, 6), GEN_FUN_MAP(cb_, 7),</span><br><span class="line">    GEN_FUN_MAP(cb_, 8), GEN_FUN_MAP(cb_, 9), GEN_FUN_MAP(cb_, A), GEN_FUN_MAP(cb_, B),</span><br><span class="line">    GEN_FUN_MAP(cb_, C), GEN_FUN_MAP(cb_, D), GEN_FUN_MAP(cb_, E), GEN_FUN_MAP(cb_, F)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 GEN_FUN_MAP() macro 是幫你產生 op_00(), op_01 ... op_FF 的格式，因為一個一個打實在太累了，當然你有毅力我也不反對</p><a id="more"></a><p>這邊的重點放在兩個 array, 分別是 <code>opcode_fun g_opcode_fun_map[0x100]</code> 與 <code>opcode_fun g_opcode_cb_fun_map[0x100]</code>，也就是說，我們使用一個 function pointer 的 array，然後使用該 array 的 index 當作 op code 呼叫號碼，這樣就不用寫落落長的 switch case 了，有了 opcode 了，我們就可以開始 fetch 指令了。新增以下的 code 到 cpu.c 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">eu8 fetch(void) &#123;</span><br><span class="line">    eu8 val &#x3D; get_ram(REG_PC);</span><br><span class="line">    INC_REG(pc);</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 execute_opcode() &#123;</span><br><span class="line">    eu8 opcode &#x3D; fetch();</span><br><span class="line">    opcode_fun_usp op_map &#x3D; g_opcode_fun_map;</span><br><span class="line">    bool is_cb_cmd &#x3D; false;</span><br><span class="line"></span><br><span class="line">    if (opcode &#x3D;&#x3D; PREFIX_CMD) &#123;</span><br><span class="line">        opcode &#x3D; fetch();</span><br><span class="line">        op_map &#x3D; g_opcode_cb_fun_map;</span><br><span class="line">        is_cb_cmd &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    op_map[opcode]();</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 cpu_tick() &#123;</span><br><span class="line">    return execute_opcode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tick() &#123;</span><br><span class="line">    cpu_tick();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void run_cpu() &#123;</span><br><span class="line">    while (g_cpu.running) &#123;</span><br><span class="line">        tick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fetch() 其實就是以 pc 當作記憶體位置，然後把該記憶體位置的值取出來，取出來後 pc 就要步進1</li><li>Gameboy 的 op code 有兩種，一種是 normal 的，一種是老任新增的 -- 以 0xCB 做前綴的 external op code ，所以我們這邊一旦遇到 cb cmd 的時候，就使用 cb cmd 的 function array，反之則用正常的 function array</li></ul><hr><h2 id="boot-code-的選擇"><a href="#boot-code-的選擇" class="headerlink" title="boot code 的選擇"></a>boot code 的選擇</h2><p>好，在開始之前，還有一件事很重要就是，這顆 cpu 的 pc 是從 0 開始讀，然後我們又把 game rom 放到 0 ~ 32k 的地方，理論上 pc = 0 開始讀的位置是 game rom 的第 0 byte，但是呢，如果你有注意到的話，其實 address 0 ~ 255 這個位置會跟 boot rom 重疊，也就是說 boot rom 與 game com 在 address 0 ~ 255 byte 的地方產生了 overlay</p><p>那既然 overlay 了，那我去讀 address 0，到底是讀到的是 game rom 的第一個 byte，還是 boot rom 的第一個 byte 呢? 為了讓 fw 可以選擇使用哪個 code，所以有個 0xFF50 這個 boot_rom_disable 的 register  會做切換的功能，當我們要存取 0 ~ 255 的位置時，就要先去看一下這個 reg，當 boot_rom_disable 設為 0 時，我們的 mmu 就要送出 boot rom 的值，反之就會讀到 game rom 的位置，這個 reg 預設是讀 boot rom， 而一旦當要開始執行遊戲畫面時，fw 就會把這個 register 切到 1，這樣 mmu 就必須把這塊記憶體 mapping 到 game rom 去</p><p>那這個 isp 的功能要實作也很簡單，就是在額外宣告一個 eu8 boot_rom_dmg[0x100] ，並且在 get_ram_ptr 動手腳就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eu8_p get_ram_ptr(RamAddr address) &#123;</span><br><span class="line">    if (address &lt; BOOT_ROM_LENGTH) &#123;</span><br><span class="line">        if (g_zero_page-&gt;boot_rom_disable &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return (eu8_p)&amp;boot_rom_dmg[address];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (eu8_p)&amp;g_ram[address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 ok 之後，我們就可以正式的 fatch 第一個指令了，此時順利的話，你會 fetch 第一個 op code ，這個是從 boot rom 提出來的，號碼為 0x31，此時如果繼續執行的話會碰到 error ，因為我們在所有沒有實作的 cmd 裡面都加上了 not_support_op_code()，進而會引發 assert，所以我們的目標就是把所有的 cmd 給做出來</p><hr><h2 id="建立起-256-256-個-opcode"><a href="#建立起-256-256-個-opcode" class="headerlink" title="建立起 256 + 256 個 opcode"></a>建立起 256 + 256 個 opcode</h2><p>這邊雖然一共有 normal op + external op 最多 512 道指令，但你如果仔細觀察的話，其實很多指令都相同，只是來源 register 或是目標 register 不同，我的建議是按照手冊一個一個做下去，這樣在實作的時候也比較不會亂</p><p>回到教學這邊，雖然每個 cmd 都是短短的，即便如此，若講解每道指令的話會使用很多篇幅，所以這邊只會挑重點講</p><p>首先我們先做點前置作業，在 cpu.c 中加入等下會用到的 function，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void disable_halt() &#123;</span><br><span class="line">    g_cpu.halt &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void enable_halt() &#123;</span><br><span class="line">    g_cpu.halt &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stack_push(WordReg_p reg) &#123;</span><br><span class="line">    DEC_REG(sp);</span><br><span class="line">    set_ram(REG_SP, REG_VAL(REG_HIGH(reg)));</span><br><span class="line">    DEC_REG(sp);</span><br><span class="line">    set_ram(REG_SP, REG_VAL(REG_LOW(reg)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void stack_pop(WordReg_p reg) &#123;</span><br><span class="line">    REG_VAL(REG_LOW(reg)) &#x3D; get_ram(REG_SP);</span><br><span class="line">    INC_REG(sp);</span><br><span class="line">    REG_VAL(REG_HIGH(reg)) &#x3D; get_ram(REG_SP);</span><br><span class="line">    INC_REG(sp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu16 fetch_word() &#123;</span><br><span class="line">    eu16 val &#x3D; 0;</span><br><span class="line">    val |&#x3D; fetch();</span><br><span class="line">    val |&#x3D; fetch() &lt;&lt; 8;</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 cpu_tick() &#123;</span><br><span class="line">    if (g_cpu.halt) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return execute_opcode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到其實實作的方式都很簡單， fetch_word 就是使用 fetch 兩次，而 stack_push 就是先把 sp 減一後，在把 pc 所指向的 ram 的值讀出來放到 sp 所指的位置，stack 的操作大多是以 WordRegister 的方式而 stack_pop 就是反過來做，此外，我們也增加了 halt 的 function ，並在原本的 cpu_tick() 中，加入 check g_cpu.halt 來模擬 halt 的指令</p><hr><h2 id="LD-r1-r2-指令"><a href="#LD-r1-r2-指令" class="headerlink" title="LD, r1 r2 指令"></a>LD, r1 r2 指令</h2><p>這個指令是最多使用的，從 op code 0x40~0x7F 都是用它做出來的，所以一下子 64 個指令就完成了，他的實作方式也很簡單，就是把 r2 這個 byte ，設給 r1 這個 byte register</p><p>而有時候設值目標不是 register ，而是記憶體位置，所以這邊就又弄一個 opcode_ld_r1_r2_addr() ，C 不支援同名異式的 Polymorphism ，所以抽象表現力就比較差一點，不過對於這個小專案來說還是可以忍受的範圍內就是了，當然 reg 與記憶體位置你也可以看成都是這隻模擬器的記憶體位置，真的發狠起來要搞合併也不是不行，只是這樣 code 會變成更難理解，這樣就本末倒置了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void opcode_ld_r1_r2(ByteReg_p r1, eu8 r2) &#123;</span><br><span class="line">    REG_VAL(r1) &#x3D; r2;</span><br><span class="line">&#125;</span><br><span class="line">void opcode_ld_r1_r2_addr(RamAddr address, eu8 r2) &#123;</span><br><span class="line">    set_ram(address, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊也稍微貼一下他在 opcode_map.c 中的樣子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void op_40() &#123; opcode_ld_r1_r2(b, REG_B); &#125;</span><br><span class="line">void op_41() &#123; opcode_ld_r1_r2(b, REG_C); &#125;</span><br><span class="line">void op_42() &#123; opcode_ld_r1_r2(b, REG_D); &#125;</span><br><span class="line">void op_43() &#123; opcode_ld_r1_r2(b, REG_E); &#125;</span><br><span class="line">void op_44() &#123; opcode_ld_r1_r2(b, REG_H); &#125;</span><br><span class="line">void op_45() &#123; opcode_ld_r1_r2(b, REG_L); &#125;</span><br><span class="line">void op_46() &#123; opcode_ld_r1_r2(b, RAM_VAL_HL); &#125;</span><br><span class="line">....</span><br><span class="line">void op_48() &#123; opcode_ld_r1_r2(c, REG_B); &#125;</span><br><span class="line">void op_49() &#123; opcode_ld_r1_r2(c, REG_C); &#125;</span><br><span class="line">void op_4A() &#123; opcode_ld_r1_r2(c, REG_D); &#125;</span><br><span class="line">void op_4B() &#123; opcode_ld_r1_r2(c, REG_E); &#125;</span><br><span class="line">void op_4C() &#123; opcode_ld_r1_r2(c, REG_H); &#125;</span><br><span class="line">void op_4D() &#123; opcode_ld_r1_r2(c, REG_L); &#125;</span><br><span class="line">void op_4E() &#123; opcode_ld_r1_r2(c, RAM_VAL_HL); &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="bit-b-r，res-b-r-與-set-b-r-指令"><a href="#bit-b-r，res-b-r-與-set-b-r-指令" class="headerlink" title="bit b, r，res, b r 與 set, b r 指令"></a>bit b, r，res, b r 與 set, b r 指令</h2><p>在 cb cmd 中，也是有跟 opcode_ld_r1_r2 一樣廣泛使用的 cmd ，那就是 opcode_cb_bit_b_r() ， opcode_cb_res_b_r()與 opcode_cb_set_b_r()，他們也是各占 64 個 opcode，算是很補的 cmd， 作法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void opcode_cb_bit_b_r(eu8 val, eu8 bit) &#123;</span><br><span class="line">    set_z(CHECK_BIT(val, bit) &#x3D;&#x3D; 0);</span><br><span class="line">    set_n(false);</span><br><span class="line">    set_h(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_cb_res_b_r(ByteReg_p reg, eu8 bit) &#123;</span><br><span class="line">    CLEAR_BIT(REG_VAL(reg), bit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_cb_res_b_r_addr(RamAddr addr, eu8 bit) &#123;</span><br><span class="line">    eu8 res &#x3D; get_ram(addr);</span><br><span class="line">    CLEAR_BIT(res, bit);</span><br><span class="line">    set_ram(addr, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_cb_set_b_r(ByteReg_p reg, eu8 bit) &#123;</span><br><span class="line">    SET_BIT(REG_VAL(reg), bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這3個 function 只有  opcode_cb_bit_b_r 需要注意的就是，你必須要開始設定 flags，不過這3個 function 的 flag 比較沒那麼複雜，我挑一個比較複雜的運算來討論一下</p><hr><h2 id="add-a-n-與-adc-a-n-指令"><a href="#add-a-n-與-adc-a-n-指令" class="headerlink" title="add_a_n 與 adc_a_n 指令"></a>add_a_n 與 adc_a_n 指令</h2><p>以下是 opcode 0x80 ~ 0x87 的 add_a_n 與 opcode 0x88 ~ 0x8F 的 adc_a_n 的實作，順帶一提的是，這邊 function 的命名規則是，如果是對應到 op code 的話就會以 &quot;opcode_ &quot; 為開頭，如果沒這開頭的就都是 base function 了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool check_hc_add(eu32 summand, eu32 addend, eu32 mask) &#123;</span><br><span class="line">    return ((summand &amp; mask) + (addend &amp; mask) &gt; mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu32 add_a_b(eu32 summand, eu32 addend, eu32 mask) &#123;</span><br><span class="line">    eu32 result &#x3D; summand + addend;</span><br><span class="line"></span><br><span class="line">    set_z((result &amp; mask) &#x3D;&#x3D; 0);</span><br><span class="line">    set_n(false);</span><br><span class="line">    set_h(check_hc_add(summand, addend, mask &gt;&gt; 4));</span><br><span class="line">    set_c(result &gt; mask);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_add_a_n(eu8 n) &#123;</span><br><span class="line">    REG_VAL(a) &#x3D; (eu8)add_a_b(REG_VAL(a), n, 0xFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_adc_a_n(eu8 n) &#123;</span><br><span class="line">    opcode_add_a_n(n + flags-&gt;c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>opcode_adc_a_n 與 opcode_add_a_n 其實是由 add_a_b 組成，這邊可看到 add 指令對 flag 的變化，在大部分的狀況規則整理如下</p><ul><li>flag-&gt;z: 是用來判斷運算結果是不是為0</li><li>flag-&gt;n: 代表是不是減法</li><li>flag-&gt;h: 代表 bit 4 有沒有產生變化，也就是 halt carry 的意思</li><li>flag-&gt;c: 就是代表 carry，也就是運算結果本身有無溢位</li></ul><p>對於 flag-&gt;c 來說，要判斷兩個值相加是否 overflow，所以就直接設了一個 eu32 result 的變數來存放相加過的值，並且判斷相加後是否超過 0x100 即可，反正我們是 32 位元的 cpu，要觀察兩個 8 bit regsiter 相加後是否溢位其實是一塊小蛋糕</p><hr><h2 id="rlc-指令"><a href="#rlc-指令" class="headerlink" title="rlc 指令"></a>rlc 指令</h2><p>除了加/減法會影響到 flag 外，它們也會拿去支援一些 cmd，可說是多才多藝，例如 cb cmd 的 opcde 0x00 ~ 0x07 的 rlc，他的內容是把輸入值左移一位，那這樣最高位就會消失，不過這個指令會把最高位的 bit，保存在 flag-&gt;c 中，不過這個指令有趣的地方就在於它其實也把消失的 bit，又加回到 bit 0 的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">eu8 rlx_n(eu8 value, eu8 plus) &#123;</span><br><span class="line">    eu8 result &#x3D; (value &lt;&lt; 1) | plus;</span><br><span class="line"></span><br><span class="line">    set_z(result &#x3D;&#x3D; 0);</span><br><span class="line">    set_n(false);</span><br><span class="line">    set_h(false);</span><br><span class="line">    set_c(CHECK_BIT(value, 7));</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_cb_rlc_n(ByteReg_p reg) &#123;</span><br><span class="line">    eu8 plus &#x3D; CHECK_BIT(REG_VAL(reg), 7);</span><br><span class="line">    REG_VAL(reg) &#x3D; rlx_n(REG_VAL(reg), plus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_cb_rlc_n_addr(RamAddr addr) &#123;</span><br><span class="line">    eu8 plus &#x3D; CHECK_BIT(get_ram(addr), 7);</span><br><span class="line">    set_ram(addr, rlx_n(get_ram(addr), plus));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="jr-cc-n-指令"><a href="#jr-cc-n-指令" class="headerlink" title="jr cc, n 指令"></a>jr cc, n 指令</h2><p>最後講一下 opcode_jr_cc_n()，他其實是用 jr_n 組合出來的，特別要提的是，如果判斷是不需要 jump 的話，PC 也必須要往前移動一個，所以這邊就使用 INC_REG(pc) 來達到這個目的</p><p>而跳轉命令的實作也很簡單，就是改變 pc 值就可以了，所以 jr_n 指令的作法就是把現在的 pc 加上一個 offset，而這個 offset 的是從 fetch 而來，不過 jr_n 這邊是有順序性的，你一定要先 fetch 才可以做 offset 的動作，因為 fetch 會改變 pc 的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void opcode_jr_n() &#123;</span><br><span class="line">    es8 offset &#x3D; fetch();</span><br><span class="line">    REG_PC &#x3D; REG_PC + offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_jr_cc_n(bool condition) &#123;</span><br><span class="line">    if (condition) &#123;</span><br><span class="line">        opcode_jr_n();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        INC_REG(pc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="di-與-ei-指令"><a href="#di-與-ei-指令" class="headerlink" title="di 與 ei 指令"></a>di 與 ei 指令</h2><p>再來比較特別的就是 di 與 ei，這個是打開 interrupt，我的感覺有點像是 8051 中的 EA=1 的感覺</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void opcode_di() &#123;</span><br><span class="line">    g_cpu.enable_interrupt &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void opcode_ei() &#123;</span><br><span class="line">    g_cpu.enable_interrupt &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其實 op code 大概就是這樣，真正需要認真實作的部分約100行左右，除了一個叫 daa 指令之外, 剩下的大部分都很簡單，就是組合再組合就搞定了，接下來下一篇就是要寫 gb 的 video 與 tile 系統了</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;建立-opcode-map&quot;&gt;&lt;a href=&quot;#建立-opcode-map&quot; class=&quot;headerlink&quot; title=&quot;建立 opcode map &quot;&gt;&lt;/a&gt;建立 opcode map &lt;/h2&gt;&lt;p&gt;在開始之前讀取第一道指令之前，我們要做一件很不有趣的事情，就是建立所有 op code 的 map&lt;/p&gt;
&lt;p&gt;首先我們建立 opcode_map.c，裡面的內容如下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void not_support_cb_code() &amp;#123; ASSERT_CODE(0, &amp;quot;not support CB code&amp;quot;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void not_support_op_code() &amp;#123; ASSERT_CODE(0, &amp;quot;not support op code&amp;quot;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void op_00() &amp;#123; not_support_op_code(); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void op_FF() &amp;#123; not_support_op_code(); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void op_cb_00() &amp;#123; not_support_cb_code(); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void op_cb_FF() &amp;#123; not_support_cb_code(); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;opcode_fun g_opcode_fun_map[0x100] &amp;#x3D; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(, 0), GEN_FUN_MAP(, 1), GEN_FUN_MAP(, 2), GEN_FUN_MAP(, 3),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(, 4), GEN_FUN_MAP(, 5), GEN_FUN_MAP(, 6), GEN_FUN_MAP(, 7),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(, 8), GEN_FUN_MAP(, 9), GEN_FUN_MAP(, A), GEN_FUN_MAP(, B),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(, C), GEN_FUN_MAP(, D), GEN_FUN_MAP(, E), GEN_FUN_MAP(, F)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;opcode_fun g_opcode_cb_fun_map[0x100] &amp;#x3D; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(cb_, 0), GEN_FUN_MAP(cb_, 1), GEN_FUN_MAP(cb_, 2), GEN_FUN_MAP(cb_, 3),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(cb_, 4), GEN_FUN_MAP(cb_, 5), GEN_FUN_MAP(cb_, 6), GEN_FUN_MAP(cb_, 7),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(cb_, 8), GEN_FUN_MAP(cb_, 9), GEN_FUN_MAP(cb_, A), GEN_FUN_MAP(cb_, B),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    GEN_FUN_MAP(cb_, C), GEN_FUN_MAP(cb_, D), GEN_FUN_MAP(cb_, E), GEN_FUN_MAP(cb_, F)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中 GEN_FUN_MAP() macro 是幫你產生 op_00(), op_01 ... op_FF 的格式，因為一個一個打實在太累了，當然你有毅力我也不反對&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="c" scheme="http://wwssllabcd.github.io/tags/c/"/>
    
    <category term="emulator" scheme="http://wwssllabcd.github.io/tags/emulator/"/>
    
  </entry>
  
  <entry>
    <title>從零開始的 Gameboy 模擬器開發 -- Step 1</title>
    <link href="http://wwssllabcd.github.io/2021/02/08/how-to-build-a-gameboy-emulator-1/"/>
    <id>http://wwssllabcd.github.io/2021/02/08/how-to-build-a-gameboy-emulator-1/</id>
    <published>2021-02-07T16:24:46.000Z</published>
    <updated>2021-02-10T05:22:08.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建立硬體描述"><a href="#建立硬體描述" class="headerlink" title="建立硬體描述"></a>建立硬體描述</h1><p>我們首先對 cpu 做描述， 先介紹 LR35902 這顆 cpu 其中的 4 個 word Register(Register，以後均簡稱 Reg) 分別為 <code>AF，BC，DE，HL</code>，這 4 個 word reg，比較特別的是，它們個別又可以拆成 byte reg ，例如 AF 就可以拆成兩個 byte reg <code>A(accumulator)</code>與 <code>F(Flags)</code> 來使用的，或者是合併讀取，例如 HL 常常當作 ram address 使用</p><p>到這邊如果你覺得陌生的話，建議你可以去惡補一下 cpu 暫存器的知識</p><p>考量 reg 可以分開讀取，或是合併讀取的特性，所以我們需要建立某種的描述，是可以分開，也可以合併的讀寫，翻翻 C 的手冊，發現使用 union 就可以達到這種目的了，所以我們使用 typedef 建立起對 byte reg 與 wordd reg 的描述</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    eu8 all;</span><br><span class="line">&#125;ByteReg;</span><br><span class="line">ERIC_GEN_POINTER_TYPE(ByteReg);</span><br><span class="line"></span><br><span class="line">typedef union &#123;</span><br><span class="line">    eu16 all;</span><br><span class="line">    struct &#123;</span><br><span class="line">        ByteReg low;</span><br><span class="line">        ByteReg high;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;WordReg;</span><br><span class="line">ERIC_GEN_POINTER_TYPE(WordReg);</span><br><span class="line"></span><br><span class="line">typedef union &#123;</span><br><span class="line">    eu8 all;</span><br><span class="line">    struct &#123;</span><br><span class="line">        eu8 : 4;</span><br><span class="line">        eu8 c : 1;</span><br><span class="line">        eu8 h : 1;</span><br><span class="line">        eu8 n : 1;</span><br><span class="line">        eu8 z : 1;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;FlagReg;</span><br><span class="line">ERIC_GEN_POINTER_TYPE(FlagReg);</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        WordReg af;</span><br><span class="line">        struct &#123;</span><br><span class="line">            FlagReg f;</span><br><span class="line">            ByteReg a;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    union &#123;</span><br><span class="line">        WordReg bc;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ByteReg c;</span><br><span class="line">            ByteReg b;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    union &#123;</span><br><span class="line">        WordReg de;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ByteReg e;</span><br><span class="line">            ByteReg d;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    union &#123;</span><br><span class="line">        WordReg hl;</span><br><span class="line">        struct &#123;</span><br><span class="line">            ByteReg l;</span><br><span class="line">            ByteReg h;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    WordReg sp;</span><br><span class="line">    WordReg pc;</span><br><span class="line"></span><br><span class="line">    bool halt;</span><br><span class="line">    bool running;</span><br><span class="line">    bool enable_interrupt;</span><br><span class="line">    eu32 clock_cnt;</span><br><span class="line"></span><br><span class="line">&#125;Cpu;</span><br><span class="line">ERIC_GEN_POINTER_TYPE(Cpu);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到 word reg 是由兩個 byte reg 來組成的，而她又有一個 all 的屬性，是可以存取本身的 word 的值，剛好符合我們的需求，而我們把 word reg 與 byte reg 的取值變數全部都命名為 all，因為這樣會比較有一致性，當你需要存取不管是 ByteReg 或者是 WordReg，一律都使用 all 就可以存取了，這樣一來我們就能得到一個通用的取值的方法</p><p>其中的 ERIC_GEN_POINTER_TYPE 的 Macro 他會幫你產生 xxx_p, xxx_sp, xxx_usp 的 type，例如 <code>Cpu_usp cpu</code> 就會等同於 <code>Cpu* cpu</code> 的意思，另外，cpu struct 方面，我們也建立了 SP, PC, 的 Word register ，此外也建立一些變數，例如 </p><ul><li>halt 是給 halt 指令使用,</li><li>running 是開/關模擬器使用</li><li>enable_interrupt 是用來支援 ei 與 di 命令，它給我的感覺很像是 8051 中的 EA</li><li>clock_cnt 是用來模擬 cpu 內部的 clock，這個 clock 會跟產生畫面有關係</li></ul><p>這邊有個比較特別的 FlagReg_p，他其實就 AF 裡面的 F，又稱為 flags，他只有 4 個 bit 是有用的，所以我們使用分號的方式把那幾個 flag 都限定為 1 bit</p><hr><p>有了一個 Cpu type 後，我們就可以建立一個全域變數 g_cpu 了，這邊我們全域變數一律使用 <code>g_</code> 開頭，我們只有針對全域變數使用匈牙利命名法外，其他情況則不使用，方便我們對全域變數的管制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Cpu g_cpu &#x3D; &#123;</span><br><span class="line">    .af &#x3D; 0,</span><br><span class="line">    .bc &#x3D; 0,</span><br><span class="line">    .de &#x3D; 0,</span><br><span class="line">    .hl &#x3D; 0,</span><br><span class="line">    .sp &#x3D; 0,</span><br><span class="line">    .pc &#x3D; 0,</span><br><span class="line">    .halt &#x3D; false,</span><br><span class="line">    .running &#x3D; true,</span><br><span class="line">    .enable_interrupt&#x3D; false,</span><br><span class="line">    .clock_cnt &#x3D; 0,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>為了方便起見，我們也對比較常用的 register 建立對應的全域變數，可以讓我們之後在寫 opcode 的時候比較直覺一點，也可以少打幾個字，這邊的全域變數又都沒有加 <code>g_</code> ，直接光速打臉上面的原則，原因是加上去真的很醜，所以這邊會有個 trade off，反正我們都知道 af 是全域的 Register 就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WordReg_p af &#x3D; &amp;g_cpu.af;</span><br><span class="line">WordReg_p bc &#x3D; &amp;g_cpu.bc;</span><br><span class="line">WordReg_p de &#x3D; &amp;g_cpu.de;</span><br><span class="line">WordReg_p hl &#x3D; &amp;g_cpu.hl;</span><br><span class="line">WordReg_p sp &#x3D; &amp;g_cpu.sp;</span><br><span class="line">WordReg_p pc &#x3D; &amp;g_cpu.pc;</span><br><span class="line"></span><br><span class="line">ByteReg_p a &#x3D; &amp;g_cpu.a;</span><br><span class="line">FlagReg_p flags &#x3D; &amp;g_cpu.f;</span><br><span class="line">ByteReg_p b &#x3D; &amp;g_cpu.b;</span><br><span class="line">ByteReg_p c &#x3D; &amp;g_cpu.c;</span><br><span class="line">ByteReg_p d &#x3D; &amp;g_cpu.d;</span><br><span class="line">ByteReg_p e &#x3D; &amp;g_cpu.e;</span><br><span class="line">ByteReg_p h &#x3D; &amp;g_cpu.h;</span><br><span class="line">ByteReg_p l &#x3D; &amp;g_cpu.l;</span><br></pre></td></tr></table></figure><p>我們故意地把所有的 register 都變成了 pointer 型態，原因是要統一存取的格式，例如我今天要取一個 byre reg 與 word reg 的方式都是使用 reg-&gt;all</p><hr><p>所以我們也建立一些對 flags 設定的方式，如下所示，而其中的 SET_FLAG 只是幫你把 bool 轉成 1 or 0 而已，如果是 true，他就會回傳1，反之則0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void set_z(bool val) &#123;</span><br><span class="line">    flags-&gt;z &#x3D; SET_FLAG(val);</span><br><span class="line">&#125;</span><br><span class="line">void set_h(bool val) &#123;</span><br><span class="line">    flags-&gt;h &#x3D; SET_FLAG(val);</span><br><span class="line">&#125;</span><br><span class="line">void set_n(bool val) &#123;</span><br><span class="line">    flags-&gt;n &#x3D; SET_FLAG(val);</span><br><span class="line">&#125;</span><br><span class="line">void set_c(bool val) &#123;</span><br><span class="line">    flags-&gt;c &#x3D; SET_FLAG(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下來建立一些 macro 也是讓我們可以使用比較直覺的方式去存取 Register 的值，而不是依賴 -&gt;all 或是 -&gt;high 這種特定的方式讀取，我們可以利用 macro 去隱藏底層的實作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define REG_VAL(REG)                              ((REG)-&gt;all)</span><br><span class="line">#define INC_REG(REG)                              (REG_VAL(REG)++)</span><br><span class="line">#define DEC_REG(REG)                              (REG_VAL(REG)--)</span><br><span class="line"></span><br><span class="line">#define REG_HIGH(REG)                             (&amp;(REG)-&gt;high)</span><br><span class="line">#define REG_LOW(REG)                              (&amp;(REG)-&gt;low)</span><br><span class="line"></span><br><span class="line">#define REG_A                       REG_VAL(a)</span><br><span class="line">#define REG_B                       REG_VAL(b)</span><br><span class="line">#define REG_C                       REG_VAL(c)</span><br><span class="line">#define REG_D                       REG_VAL(d)</span><br><span class="line">#define REG_E                       REG_VAL(e)</span><br><span class="line">#define REG_F                       REG_VAL(f)</span><br><span class="line">#define REG_H                       REG_VAL(h)</span><br><span class="line">#define REG_L                       REG_VAL(l)</span><br><span class="line">#define REG_AF                      REG_VAL(af)</span><br><span class="line">#define REG_BC                      REG_VAL(bc)</span><br><span class="line">#define REG_DE                      REG_VAL(de)</span><br><span class="line">#define REG_HL                      REG_VAL(hl)</span><br><span class="line">#define REG_SP                      REG_VAL(sp)</span><br><span class="line">#define REG_PC                      REG_VAL(pc)</span><br><span class="line"></span><br><span class="line">#define FLAG_Z                      (flags-&gt;z)</span><br><span class="line">#define FLAG_NZ                    (!flags-&gt;z)</span><br><span class="line">#define FLAG_C                      (flags-&gt;c)</span><br><span class="line">#define FLAG_NC                    (!flags-&gt;c)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這邊的規則大概是</p><ul><li>如果你想要讀取變數 Register 的值，你就使用 REG_VAL()，例如 ByteReg reg 的讀值方式就是 REG_VAL(reg)</li><li>如果你想要讀取特定 Register 的值，你就是使用 REG_A，REG_B ... 等方式</li></ul><hr><h1 id="建立記憶體管理"><a href="#建立記憶體管理" class="headerlink" title="建立記憶體管理"></a>建立記憶體管理</h1><p>接著建立 mmu(memory management unit) ，這個是負責管理記憶體的地方，所有的記憶體的存取都會經過這隻程式 -- 沒有例外，也就是我們會建立一個 64k 的 byte array，而這個 array 會假裝自己是 cpu 的 ram，其實這種說法並不正確，我們的目的應該是 mmu 會把自己假裝成是一種可以存取的裝置，但是本身實作的內容是什麼並不重要，就像是上面的 reg 的 macro，我們一直推遲 reg 取值的方式，直到最後一刻的 REG_VAL 才暴露出來原來是一個叫 all 的變數，在這之前我們都一直在玩文字遊戲，換句話說，只是 mmu 在實作的方式剛好是使用 byte array，有天你不高興，把 array 換成一個檔案，或是雲端某個可以存放資料的地方也是可以的</p><p>回到記憶體的話題，當然真實世界的 cpu 根據 sram 的位置，會有 internal sram 與 external sram 之分，像是 LR35902 這顆 cpu 的 0xFF00 的位置就是所謂的 Zero page，我猜它跟 8051 一樣 -- 藉由鎖定一個 register (也許是 P2)，達到快速讀取記憶體的方式，不過對我們來說是不太重要的，就通通看成 ram 就可以了</p><hr><p>開始實作 mmu 吧，新增檔案 mmu.c 並加入以下的 code </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">eu8 g_ram[GB_RAM_SIZE] &#x3D; &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">eu8_p get_ram_ptr(RamAddr address) &#123;</span><br><span class="line">    return (eu8_p)&amp;g_ram[address];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu8 get_ram(RamAddr address) &#123;</span><br><span class="line">    return (*get_ram_ptr(address));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set_ram(RamAddr address, eu8 val) &#123;</span><br><span class="line">    (*get_ram_ptr(address)) &#x3D; val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_mmu(eu8_p rom) &#123;</span><br><span class="line">    mem_cpy(g_ram + GAME_ROM_START_ADDR, rom, GAME_ROM_LENGTH);</span><br><span class="line">    set_ram(0xFF00, 0x3F);</span><br><span class="line">    set_ram(0xFF02, 0xFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>對應到 cpu 的 rom 就是 g_ram[_64K] 了，然後提供 gettter / setter，還有 init_mmu()</p><p>g_ram 利用 <code>eu8 g_ram[GB_RAM_SIZE] = &#123;0&#125;</code> 的方式來達到 init buffer 的功能，不過我們還需要一個 init_mmu() 的 functin，它會把 game-rom copy 到 rom 0 ~ 32k 的位置，addres 0的位置有點特別，蠻重要的，晚一點會在說明，這邊還有一點比較特別的是 <code>0xFF00</code> 與 <code>0xFF02</code> 的初始值是 0x3F 與 0xFF，這邊就先照填吧</p><p>cpu.c 這邊也增加 run code ，其中 tick 就是執行 opcode 的地方，基本上 cpu 進到 run_cpu() 會在這邊無限循環直到關機為止，不過這邊我們先讓他強制停止，等晚一點再來處理 opcode </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void tick() &#123;</span><br><span class="line">    g_cpu.running &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void run_cpu() &#123;</span><br><span class="line">    while (g_cpu.running) &#123;</span><br><span class="line">        tick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void power_on_cpu(eu8_p rom) &#123;</span><br><span class="line">    init_mmu(rom);</span><br><span class="line">    run_cpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們也順便把 game rom 讀進來，game rom 的檔案請自己想辦法嚕，我們在 main 中把 rom 讀進來，並且傳入 power_on_cpu，這段 code 你可以想像成把遊戲 rom 插入主機後，然後 power on 的樣子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;SDL.h&gt;</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line">#include &quot;adapter_sdl.h&quot;</span><br><span class="line">#include &quot;cpu.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    printf(&quot;start\n&quot;);</span><br><span class="line">    if (argc &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_sdl(&quot;My Gameboy Emulator&quot;, SCREEN_WIDTH * SDL_PIXEL_SIZE, SCREEN_HEIGHT * SDL_PIXEL_SIZE);</span><br><span class="line"></span><br><span class="line">    echar_p romFileName &#x3D; argv[1];</span><br><span class="line">    eu8 rom[GAME_ROM_LENGTH];</span><br><span class="line">    file_read(romFileName, rom, _32K);</span><br><span class="line"></span><br><span class="line">    power_on_cpu(rom);</span><br><span class="line"></span><br><span class="line">    SDL_Quit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前為止，我們基本上已經完成了初步的架構，一個 cpu，一個記憶體，然後我們也把 rom 讀進來了，接下來就可以開始化身成 cpu ，去執行一道道 op code 了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;建立硬體描述&quot;&gt;&lt;a href=&quot;#建立硬體描述&quot; class=&quot;headerlink&quot; title=&quot;建立硬體描述&quot;&gt;&lt;/a&gt;建立硬體描述&lt;/h1&gt;&lt;p&gt;我們首先對 cpu 做描述， 先介紹 LR35902 這顆 cpu 其中的 4 個 word Register(Register，以後均簡稱 Reg) 分別為 &lt;code&gt;AF，BC，DE，HL&lt;/code&gt;，這 4 個 word reg，比較特別的是，它們個別又可以拆成 byte reg ，例如 AF 就可以拆成兩個 byte reg &lt;code&gt;A(accumulator)&lt;/code&gt;與 &lt;code&gt;F(Flags)&lt;/code&gt; 來使用的，或者是合併讀取，例如 HL 常常當作 ram address 使用&lt;/p&gt;
&lt;p&gt;到這邊如果你覺得陌生的話，建議你可以去惡補一下 cpu 暫存器的知識&lt;/p&gt;
&lt;p&gt;考量 reg 可以分開讀取，或是合併讀取的特性，所以我們需要建立某種的描述，是可以分開，也可以合併的讀寫，翻翻 C 的手冊，發現使用 union 就可以達到這種目的了，所以我們使用 typedef 建立起對 byte reg 與 wordd reg 的描述&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="c" scheme="http://wwssllabcd.github.io/tags/c/"/>
    
    <category term="emulator" scheme="http://wwssllabcd.github.io/tags/emulator/"/>
    
  </entry>
  
  <entry>
    <title>從零開始的 Gameboy 模擬器開發 -- Step 0</title>
    <link href="http://wwssllabcd.github.io/2021/02/07/how-to-build-a-gameboy-emulator-0/"/>
    <id>http://wwssllabcd.github.io/2021/02/07/how-to-build-a-gameboy-emulator-0/</id>
    <published>2021-02-06T16:24:46.000Z</published>
    <updated>2021-02-10T05:19:25.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="緣由"><a href="#緣由" class="headerlink" title="緣由"></a>緣由</h1><p>工作上使用 8051 蠻多年了，以前就有想要寫一個 cpu 模擬器的念頭，某一陣子還收到一間美商寫 arm 模擬器的工作邀約，不過以不熟為理由推掉了，後來看到 Jserv 與 <a href="https://yodalee.me/2020/12/2020_rust_gameboy/">yodalee 的文章</a>，想說我應該也可以做到這件事，就像是 <a href="https://zh.wikipedia.org/wiki/%E4%B9%94%E6%B2%BB%C2%B7%E9%A9%AC%E6%B4%9B%E9%87%8C">George Mallory</a> 說的，&quot;因為山就在那，所以我登山(Because it&#39;s there)&quot;，做這件事的起因也沒什麼特別的，差不多也就是因為我覺得我可以，所以我去做看看的感覺</p><hr><h2 id="語言的選擇"><a href="#語言的選擇" class="headerlink" title="語言的選擇"></a>語言的選擇</h2><p>使用 C 語言，原因很單純就是，我只有找到一個 project 的 code 是比較乾淨的，然後他剛好是 C code 這樣，我之前有找到幾個 gbe 的 project ，但 source code 實在是太亂了，對於一個模擬器的新手要看他們的code 進而理出整個邏輯是很困難的，所以這次先選擇使用 C 開發，可能之後做完後會找機會 porting 到其他語言像是 rust、python 這兩個抽象性較高的語言，或是使用 Java Script，這樣也許會有機會可以在 web 上玩，或是 Haskell 感覺也蠻有趣的</p><a id="more"></a><hr><h2 id="Platform-的選擇"><a href="#Platform-的選擇" class="headerlink" title="Platform 的選擇"></a>Platform 的選擇</h2><p>使用 window + VC community 當作開發環境，當然使用 ubuntu(or wsl) + vs code + gcc + gdb 也是可以，這是個人喜好問題，可能之後我也會 porting 到 linux 上面去，反正就不要用一些奇怪的東西的話，盡量使用標準 C 的話，porting 就不會太困難</p><hr><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>其實有幾個目的，第一個就是看到很多 project 對於硬體上面的描述感覺很亂，我覺得如果巧妙的使用 struct 或是二維陣列的話，會可以把 code 寫得更漂亮，另外的一個目的就是試看看能不能使用 C 語言進行高階語言的設計，看能做到怎樣的程度</p><hr><h2 id="參考文件"><a href="#參考文件" class="headerlink" title="參考文件"></a>參考文件</h2><p>基本上你一定會反覆參考這些文件 ，所以就先在這邊列出，建議開始前可以先去看，有個概念</p><ul><li><a href="https://media.ccc.de/v/33c3-8029-the_ultimate_game_boy_talk#t=1445">The Ultimate Game Boy Talk</a> 這篇演講講的非常好，講者應該是非常用心的在準備這篇的演講</li><li><a href="https://fdocuments.in/document/gameboy-cpu-manual.html">Game Boy CPU Manual </a> 這手冊對於整個 GB 的 cpu 寫得很詳細 </li></ul><p>剩下的參考資料就比較沒那麼完整了，但是還是會對剛開始建立起觀念有幫助</p><ul><li><a href="https://yodalee.me/2020/12/2020_rust_gameboy/">Rust Gameboy Emulator -- by yodalee</a>: yodalee 使用 rust 的特性來，用簡單的 code 就可以大量建立 CPU 的 instruction，我就是看了這篇才決定也要動手做的</li><li><a href="http://accu.cc/content/gameboy/preface/">GameBoy 仿真器教程</a>: 這篇蠻完整的介紹了 Gameboy 各項，對於 video 的說明的方面的寫的不錯</li><li><a href="https://hackmd.io/@RinHizakura/BJ6HoW29v">Game Boy 的硬體設計與運作原理</a>: 這篇是成大資工系的專題，這邊不得不提到 <a href="http://wiki.csie.ncku.edu.tw/User/jserv">Jserv大大</a>對於台灣資訊教育的貢獻，沒有他這個專題，也不會有 yodalee 那篇文章，也更不會有我這篇文章了，當然專題的其他同學也有整理有關 GB 的資料也很棒，不過這篇是可以搭配 &quot;The Ultimate Game Boy Talk&quot; 一起閱讀的，而雖然這對同學只是一個專題，但是所產出的資料會永遠地被人參考</li></ul><p>最後的參考文件就是我的 source code ，你可以在<a href="https://github.com/wwssllabcd/EricGbEmu">這邊</a>找到目前專案的 source code</p><hr><h1 id="從零開始的-Gameboy-模擬器開發-Step-0-建立開發環境"><a href="#從零開始的-Gameboy-模擬器開發-Step-0-建立開發環境" class="headerlink" title="從零開始的 Gameboy 模擬器開發 -- Step 0: 建立開發環境"></a>從零開始的 Gameboy 模擬器開發 -- Step 0: 建立開發環境</h1><p>首先我們先建立一個 win32 console 的空專案，並取一個自己喜歡的名字，我這邊就先取了 EricGbEmu(名字不會影響後續的開發)，先行編譯與安全性檢查的都拿掉建立完的時候會出現一個 EricGbEmu.cpp 的專案，把 EricGbe.cpp 改成 main.c ，並且把其他的東西都砍掉，整個專案只剩 main.c 後，試著編譯 &amp; run 看看是否可以 pass如果可以順利 compile pass 的話，就把這些檔案放入 git  中，當作 first init</p><p>若不行，這邊也有教<a href="https://michaelchen.tech/windows-programming/use-vs2019-for-c-projects/">如何使用 VC 建立一個 C 的 project </a></p><hr><h2 id="加入常用到的-code"><a href="#加入常用到的-code" class="headerlink" title="加入常用到的 code "></a>加入常用到的 code </h2><ul><li>建立一個 folder 叫 common，把我以前累積常用的 define 與 utility 等小東西加入，以便加速開發</li><li>建立 folder 叫 type 與 define，之後若是新增 type 與 define 就丟到這裡來，這樣比較不會亂亂的</li></ul><hr><h2 id="加入-sdl-2"><a href="#加入-sdl-2" class="headerlink" title="加入 sdl 2 "></a>加入 sdl 2 </h2><p>從 <a href="https://www.libsdl.org/download-2.0.php">SDL 2 網站</a>下載 SDL2-devel-2.0.14-VC.zip ，解壓縮後就可以使用了再把 include 目錄，再去連結/輸入/其他相依性那邊輸入 <code>SDL2.lib; SDL2main.lib; SDL2test.lib</code> 就可以了記得不要在其他相依性那邊 include sdl2.dll，否則會發生 <code>檔案無效或毀損: 無法在 0x308 讀取</code> 的錯誤</p><p>若不行的話，這邊有<a href="https://lazyfoo.net/tutorials/SDL/01_hello_SDL/windows/msvc2019/index.php">Setting up SDL 2 on Visual Studio 2019 Community</a> 可以參考</p><p>接著建立一個叫 <code>adapter_sdl.c</code> 當作我們的 code 與 sdl2 介接的橋樑，code 如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;adapter_sdl.h&quot;</span><br><span class="line">#include &lt;SDL.h&gt;</span><br><span class="line">#define NULL_PTR (0)</span><br><span class="line"></span><br><span class="line">SDL_Window* g_window;</span><br><span class="line">SDL_Renderer* g_renderer;</span><br><span class="line">SDL_Texture* g_texture;</span><br><span class="line">uint32_t* g_sdl_pixels;</span><br><span class="line"></span><br><span class="line">void init_sdl(char* title, eu32 width, eu32 height) &#123;</span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);</span><br><span class="line">    g_window &#x3D; SDL_CreateWindow(title, SDL_WINDOWPOS_UNDEFINED,  SDL_WINDOWPOS_UNDEFINED, width, height, SDL_WINDOW_OPENGL);</span><br><span class="line">    if (g_window &#x3D;&#x3D; NULL_PTR) &#123;</span><br><span class="line">        ASSERT_CODE(0, &quot;Failed to initialise SD&#x3D;%X&quot;, g_window);</span><br><span class="line">    &#125;</span><br><span class="line">    g_renderer &#x3D; SDL_CreateRenderer(g_window, -1, SDL_RENDERER_ACCELERATED |  SDL_RENDERER_PRESENTVSYNC);</span><br><span class="line">    g_texture &#x3D; SDL_CreateTexture(g_renderer, SDL_PIXELFORMAT_ARGB8888,  SDL_TEXTUREACCESS_STREAMING, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這邊有個叫 ASSERT_CODE 的，是我使用 assert 的方式，你也可以改成你自己喜歡的方式去處理 error handling </p><hr><h2 id="顯示遊戲視窗"><a href="#顯示遊戲視窗" class="headerlink" title="顯示遊戲視窗"></a>顯示遊戲視窗</h2><p>修改 main.c 中的 main() 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;SDL.h&gt;</span><br><span class="line">#include &quot;header.h&quot;</span><br><span class="line">#include &quot;adapter_sdl.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;start\n&quot;);</span><br><span class="line">   </span><br><span class="line">    init_sdl(&quot;My Gameboy Emulator&quot;, SCREEN_WIDTH, SCREEN_WIDTH);</span><br><span class="line">    system(&quot;PAUSE&quot;);</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中比較特別的是，這個 <code>main.c</code> 中，即便你沒用到 sdl 相關程式，你也一定要 <code>include &lt;SDL.h&gt;</code>， 因為 sdl 需要對你的 main funciton 動手腳，所以這邊只能照做</p><p>接下來就可以執行我們的 code 了， 若你執行時出現 <code>因為找不到 SDL2.dll</code> ，就代表你還沒把 <code>SDL2.dll, SDL2.lib, SDL2main.lib, SDL2test.lib</code> 這幾個檔案 copy 到執行目錄上，這個要手動做</p><p>若一切順利，理論上你應該會看到一個小的白色框框，那個就是模擬器的螢幕，但又因為我們設定的螢幕太小，所以連你打的 title 都看不到，這個問題我們之後會去解，現在就先不要管他</p><p>到此我們 Step 0 就告一個段落了，接下來就是真正要開發 code 了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;緣由&quot;&gt;&lt;a href=&quot;#緣由&quot; class=&quot;headerlink&quot; title=&quot;緣由&quot;&gt;&lt;/a&gt;緣由&lt;/h1&gt;&lt;p&gt;工作上使用 8051 蠻多年了，以前就有想要寫一個 cpu 模擬器的念頭，某一陣子還收到一間美商寫 arm 模擬器的工作邀約，不過以不熟為理由推掉了，後來看到 Jserv 與 &lt;a href=&quot;https://yodalee.me/2020/12/2020_rust_gameboy/&quot;&gt;yodalee 的文章&lt;/a&gt;，想說我應該也可以做到這件事，就像是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B9%94%E6%B2%BB%C2%B7%E9%A9%AC%E6%B4%9B%E9%87%8C&quot;&gt;George Mallory&lt;/a&gt; 說的，&amp;quot;因為山就在那，所以我登山(Because it&amp;#39;s there)&amp;quot;，做這件事的起因也沒什麼特別的，差不多也就是因為我覺得我可以，所以我去做看看的感覺&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;語言的選擇&quot;&gt;&lt;a href=&quot;#語言的選擇&quot; class=&quot;headerlink&quot; title=&quot;語言的選擇&quot;&gt;&lt;/a&gt;語言的選擇&lt;/h2&gt;&lt;p&gt;使用 C 語言，原因很單純就是，我只有找到一個 project 的 code 是比較乾淨的，然後他剛好是 C code 這樣，我之前有找到幾個 gbe 的 project ，但 source code 實在是太亂了，對於一個模擬器的新手要看他們的code 進而理出整個邏輯是很困難的，所以這次先選擇使用 C 開發，可能之後做完後會找機會 porting 到其他語言像是 rust、python 這兩個抽象性較高的語言，或是使用 Java Script，這樣也許會有機會可以在 web 上玩，或是 Haskell 感覺也蠻有趣的&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="c" scheme="http://wwssllabcd.github.io/tags/c/"/>
    
    <category term="emulator" scheme="http://wwssllabcd.github.io/tags/emulator/"/>
    
  </entry>
  
  <entry>
    <title>RPI-4 安裝 android tv</title>
    <link href="http://wwssllabcd.github.io/2020/11/08/how-to-intall-android-tv-in-raspberry-pi-4/"/>
    <id>http://wwssllabcd.github.io/2020/11/08/how-to-intall-android-tv-in-raspberry-pi-4/</id>
    <published>2020-11-07T17:07:44.000Z</published>
    <updated>2020-11-08T13:21:53.352Z</updated>
    
    <content type="html"><![CDATA[<p>首先你需要下載 android tv for raspberry pi 4 的 image file ，使用的是 LineageOS 17.1 Android TV (Android 10)</p><ul><li><a href="https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/">https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/</a></li></ul><p>在安裝之前有幾點要注意的</p><ul><li>只能支援 HDMI</li><li>最初解析度為 1920*1080</li></ul><p>所以說，如果你的螢幕是 DVI 的話，你可以離開了，因為不會有畫面，先提醒你以免白忙一場</p><p>下載後使用 Win32 Disk Imager 燒錄即可，這邊跟之前的 Rpi 做法並沒有不一樣，如果還是不行，那你可以參考以前的<a href="https://wwssllabcd.github.io/blog/2013/01/31/2013-01-31-how-to-setup-raspberry-pi/#%E5%AE%89%E8%A3%9D-OS">教學</a>，燒完後，插上卡片，直接開機就可以進入到 android tv 了</p><p>這邊有燒錄相關教學</p><ul><li><a href="https://ifunoffice.com/raspberry-pi-install-android9/">https://ifunoffice.com/raspberry-pi-install-android9/</a></li></ul><p>這邊也有一點很重要的要先講，就是如果你等下遇到任何問題找不到答案的，你應該要回去<a href="https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/">官網</a>找，那邊通常都已經有答案了</p><a id="more"></a><h2 id="下載需要的檔案"><a href="#下載需要的檔案" class="headerlink" title="下載需要的檔案"></a>下載需要的檔案</h2><p>在開始之前，我建議你先下載兩個，分別是<br>    * <a href="https://opengapps.org/">gapp</a><br>    * <a href="https://androidfilehost.com/?fid=8889791610682901035">recover2boot</a>: 要刷這個, 才能從 twrp 回到 android os</p><p>去<a href="https://opengapps.org/">opengapp</a> 下載 gapp，我們要選 </p><ul><li>arm</li><li>android 10</li><li>tv stock</li></ul><p>選好之後就可以下載了</p><p>接下來要準備<code>recover2boot</code>，你可以在以下連結找到</p><ul><li><a href="https://androidfilehost.com/?fid=8889791610682901035">https://androidfilehost.com/?fid=8889791610682901035</a></li></ul><h2 id="關機-android-tv"><a href="#關機-android-tv" class="headerlink" title="關機 android tv "></a>關機 android tv </h2><p>這邊先提一下，關機選項在</p><pre><code>setting/device prrferance/about/shutdown</code></pre><h2 id="安裝-Google-app"><a href="#安裝-Google-app" class="headerlink" title="安裝 Google app"></a>安裝 Google app</h2><p>步驟有點多，主要流程為先打開 Developer option 後，開啟 root 與 terminal 後，你才可以切到 recover mode 做 twrp 並寫入 google app 到 rom 中，其實就是跟刷手機版本的 lineage 的 gapp 大同小異，以下是步驟</p><ul><li>打開 Developer option<ul><li>setting/about 後，按10下&quot;關於&quot;標籤就可以了，跟一般的 android 是一樣的作法，</li></ul></li><li>打開 root 權限<ul><li>一樣在 Developer options</li></ul></li><li>打開本機終端機<ul><li>在 Developer options</li></ul></li></ul><p>如果你在 Developer options 可以順利地打開<code>本機終端機</code>，你就可以去<code>應用程式</code>那邊就會看到，</p><p>進入本機終端機後，先打 </p><pre><code>su rpi4-recovery.sh </code></pre><p>接下來你就可以重開機了，如果順利的話你會進到 TRWP </p><h2 id="使用-TRWP-刷入-GAPP"><a href="#使用-TRWP-刷入-GAPP" class="headerlink" title="使用 TRWP 刷入 GAPP"></a>使用 TRWP 刷入 GAPP</h2><p>接下來你可以把剛剛下載的 gapp 與 recover2boot 放到 usb 上，並且插入 rpi4，此時你在 trwp 應該要可以認的到那隻 usb，接下來就要刷 gapp，刷法跟一般的手機刷法是一樣的，唯一不同的是刷 rpi 不會變磚，所以就大膽地刷吧</p><p>這邊列出步驟</p><ol><li>Download open_gapps-arm-10.0-tvstock-xxxxxxxx.zip and save it to your device’s internal storage or use an external USB drive</li><li>Boot to TWRP recovery (你應該已經進入了)</li><li>Install open_gapps-arm-10.0-tvstock-xxxxxxxx.zip from your selected storage</li><li>Wipe-&gt;Factory reset!</li><li>Boot out of recovery (see FAQ)</li></ol><p>這邊要注意的是，如果你刷好，並且重開機後，還是回到 TRWP，此時你就必須刷<code>recover2boot</code>，他可以切換 partition 到 boot，刷完之後重開機應該就能進入到 android tv 了，重開機之後，你應該就可以使用 googe store 了，之後應該就不用教了，裝自己喜歡的 app 吧，若還是卡關，這邊有其他刷 gapp 的相關教學，你可以參考看看</p><ul><li><a href="https://www.makeuseof.com/tag/build-android-tv-box-raspberry-pi/">https://www.makeuseof.com/tag/build-android-tv-box-raspberry-pi/</a></li><li><a href="https://itigic.com/install-android-tv-on-raspberry-pi-with-lineageos/">https://itigic.com/install-android-tv-on-raspberry-pi-with-lineageos/</a></li></ul><h2 id="android-tv-操作"><a href="#android-tv-操作" class="headerlink" title="android tv 操作"></a>android tv 操作</h2><p>這邊列出一些 android tv 的操作 </p><ul><li>F1 = Home, </li><li>F2 = Back, </li><li>F3 = Multi-tasking, </li><li>F4 = Menu, </li><li>F5 = Power, </li><li>F11 = Volume down,</li><li>F12 = Volume up. </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先你需要下載 android tv for raspberry pi 4 的 image file ，使用的是 LineageOS 17.1 Android TV (Android 10)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/&quot;&gt;https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在安裝之前有幾點要注意的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能支援 HDMI&lt;/li&gt;
&lt;li&gt;最初解析度為 1920*1080&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以說，如果你的螢幕是 DVI 的話，你可以離開了，因為不會有畫面，先提醒你以免白忙一場&lt;/p&gt;
&lt;p&gt;下載後使用 Win32 Disk Imager 燒錄即可，這邊跟之前的 Rpi 做法並沒有不一樣，如果還是不行，那你可以參考以前的&lt;a href=&quot;https://wwssllabcd.github.io/blog/2013/01/31/2013-01-31-how-to-setup-raspberry-pi/#%E5%AE%89%E8%A3%9D-OS&quot;&gt;教學&lt;/a&gt;，燒完後，插上卡片，直接開機就可以進入到 android tv 了&lt;/p&gt;
&lt;p&gt;這邊有燒錄相關教學&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ifunoffice.com/raspberry-pi-install-android9/&quot;&gt;https://ifunoffice.com/raspberry-pi-install-android9/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這邊也有一點很重要的要先講，就是如果你等下遇到任何問題找不到答案的，你應該要回去&lt;a href=&quot;https://konstakang.com/devices/rpi4/LineageOS17.1-ATV/&quot;&gt;官網&lt;/a&gt;找，那邊通常都已經有答案了&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>kodi 教學，心得</title>
    <link href="http://wwssllabcd.github.io/2020/11/08/how-to-use-kodi/"/>
    <id>http://wwssllabcd.github.io/2020/11/08/how-to-use-kodi/</id>
    <published>2020-11-07T16:24:46.000Z</published>
    <updated>2020-11-08T13:19:54.983Z</updated>
    
    <content type="html"><![CDATA[<p>Kodi 是一套 media center 軟體，其前身為 xbmc，這邊列出一些相關的資源</p><h2 id="遠程控制-使用手機-APP-Yatse"><a href="#遠程控制-使用手機-APP-Yatse" class="headerlink" title="遠程控制 -- 使用手機 APP: Yatse"></a>遠程控制 -- 使用手機 APP: Yatse</h2><p>Yastse 是一款 Kodi 的遙控及投放工具，你可以在 google store 找到</p><p>不過你必須要先在 kodi 打開遠程控制，打開的地方在</p><pre><code>控制-&gt;允許通過 HTTP 遠程控制，允許異地程序遠程控制</code></pre><p>你也可以打開Web界面，這樣就可以直接使用瀏覽器控制 kodi</p><h2 id="遠程控制-使用-firefox"><a href="#遠程控制-使用-firefox" class="headerlink" title="遠程控制 -- 使用 firefox "></a>遠程控制 -- 使用 firefox </h2><p>Firefox 有很多 kodi 的套件可供遠端控制，這裡不再詳述</p><h2 id="使用-kodi-檔案總管，並從-usb-copy-檔案到-kodi"><a href="#使用-kodi-檔案總管，並從-usb-copy-檔案到-kodi" class="headerlink" title="使用 kodi 檔案總管，並從 usb copy 檔案到 kodi"></a>使用 kodi 檔案總管，並從 usb copy 檔案到 kodi</h2><p>選擇    系統-&gt;檔案總管</p><p>你就可以啟動 kodi 的檔案總管，左邊的框是操作的地方，按 C 可以叫出選單，按空白可以複選檔案例如你可以按 C 選複製，就會複製到右邊，若右邊的你找不到你要的路徑，就必須要新增瀏覽路徑</p><a id="more"></a><h2 id="調整音量音量"><a href="#調整音量音量" class="headerlink" title="調整音量音量"></a>調整音量音量</h2><ul><li>使用鍵盤上的 + - 鈕就可以</li><li>Yastse 也可以</li></ul><h2 id="設定-kodi-時間"><a href="#設定-kodi-時間" class="headerlink" title="設定 kodi 時間"></a>設定 kodi 時間</h2><ol><li>選擇 Settings &gt; Interface &gt; Regional.</li><li>注意你的 settings level 是在 Expert</li><li>如果是的話，你就可以看到 time zone 這個選項</li></ol><h2 id="安裝附加元件，遇到-kodi-script-module-urlresolver-error-dependency"><a href="#安裝附加元件，遇到-kodi-script-module-urlresolver-error-dependency" class="headerlink" title="安裝附加元件，遇到 kodi script module urlresolver error dependency"></a>安裝附加元件，遇到 kodi script module urlresolver error dependency</h2><p>請根據 error log, 下載相對應的 add-on，例如 </p><pre><code>urlsolver https://github.com/kodil/kodil/tree/master/repo/script.module.urlresolver</code></pre><p>這個代表你需要安裝 urlsolver</p><h2 id="收看直播電視"><a href="#收看直播電視" class="headerlink" title="收看直播電視"></a>收看直播電視</h2><p>必須要先安裝 add-on : <code>IPTV Simple PVR</code>，這個是 Kodi 的 IPTV 直播電視和廣播 PVR 客戶端插件，安裝完後，我們必須要指定 IPTV 要讀取哪一個直播節目的列表，IPTV 是使用 m3u8 的格式，所以我們必須要找到 m3u8 格式的直播來源</p><p>有很多 m3u8 的連結是可以 google 的到的，甚至你去 github 使用搜尋也可以找到很多，不過這個項目很大很複雜，所以之後會另開專頁說明</p><h2 id="安裝-youtube"><a href="#安裝-youtube" class="headerlink" title="安裝 youtube "></a>安裝 youtube </h2><p>你需要先安裝附加套件 Youtube，在 repository 可以找到，以下是該套件的原作者連結<a href="https://github.com/anxdpanic/plugin.video.youtube">https://github.com/anxdpanic/plugin.video.youtube</a></p><p>這邊是官方連結<a href="https://forum.kodi.tv/showthread.php?tid=356934">https://forum.kodi.tv/showthread.php?tid=356934</a></p><p>安裝完套件後，你還必須要建立 Youtube API key，可見以下連結的教學<a href="https://seo-michael.co.uk/how-to-create-your-own-youtube-api-key-id-and-secret/">https://seo-michael.co.uk/how-to-create-your-own-youtube-api-key-id-and-secret/</a></p><p>好像可以改外觀輸入密碼並允許許可後，您就可以開始了。 但是，它可能看起來不像包含所有視頻縮略圖的普通YouTube主頁。 要獲得該外觀，請從左側面板中將 Vi ewtype 更改為 Wall，如下所示</p><h2 id="安裝-Netflix"><a href="#安裝-Netflix" class="headerlink" title="安裝 Netflix "></a>安裝 Netflix </h2><p>也很麻煩，主要是登入的問題，我後來是使用 auth-key 才能登入</p><p>該套件的原始網站</p><ul><li><a href="https://github.com/CastagnaIT/plugin.video.netflix">https://github.com/CastagnaIT/plugin.video.netflix</a></li></ul><p>login with auth key  </p><ul><li><a href="https://github.com/CastagnaIT/plugin.video.netflix/wiki/Login-with-Authentication-key">https://github.com/CastagnaIT/plugin.video.netflix/wiki/Login-with-Authentication-key</a></li></ul><h2 id="kodi-套件介紹"><a href="#kodi-套件介紹" class="headerlink" title="kodi 套件介紹"></a>kodi 套件介紹</h2><ul><li>kodi 中文套件庫:  <ul><li>他是套件庫，所以只要裝這個的話，你就可以在裡面找到很多中文相關的套件，維護的不錯，很多開發者也會幫忙撰寫一些例如 bilibili, youku 的套件</li><li>該套件庫的官網<ul><li><a href="https://github.com/taxigps/xbmc-addons-chinese">https://github.com/taxigps/xbmc-addons-chinese</a></li></ul></li><li>介紹與安裝教學: <ul><li><a href="https://blog.gtwang.org/iot/openelec-xbmc-kodi-chinese-addons/">https://blog.gtwang.org/iot/openelec-xbmc-kodi-chinese-addons/</a></li><li><a href="https://github.com/imDazui/Tvlist-awesome-m3u-m3u8/blob/master/Kodi-addons.md">https://github.com/imDazui/Tvlist-awesome-m3u-m3u8/blob/master/Kodi-addons.md</a></li></ul></li></ul></li><li>kodi exodus: <ul><li>這是提供國外影片的套件</li><li><a href="https://ppkkkp.blogspot.com/2017/10/exodus-kodi-new.html">https://ppkkkp.blogspot.com/2017/10/exodus-kodi-new.html</a></li></ul></li><li>動畫瘋<ul><li><a href="https://github.com/YWJamesLin/bahamut_anime_player_kodi">https://github.com/YWJamesLin/bahamut_anime_player_kodi</a></li></ul></li><li>kodi 套件介紹<ul><li><a href="https://zh.vpnmentor.com/blog/%E9%9B%BB%E5%BD%B1%E5%8F%8A%E9%9B%BB%E8%A6%96%E5%B0%88%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3kodi%E9%99%84%E5%8A%A0%E5%85%83%E4%BB%B6/">https://zh.vpnmentor.com/blog/%E9%9B%BB%E5%BD%B1%E5%8F%8A%E9%9B%BB%E8%A6%96%E5%B0%88%E7%94%A8%E7%9A%84%E6%9C%80%E4%BD%B3kodi%E9%99%84%E5%8A%A0%E5%85%83%E4%BB%B6/</a></li><li><a href="https://zh.wizcase.com/blog/%E7%94%B5%E8%A7%86%E7%94%A8%E5%A4%A7kodi%E9%99%84%E5%8A%A0%E7%BB%84%E4%BB%B6%EF%BC%88%E5%90%AB%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97%EF%BC%89-%E5%B9%B4%E6%9B%B4%E6%96%B0/">https://zh.wizcase.com/blog/%E7%94%B5%E8%A7%86%E7%94%A8%E5%A4%A7kodi%E9%99%84%E5%8A%A0%E7%BB%84%E4%BB%B6%EF%BC%88%E5%90%AB%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97%EF%BC%89-%E5%B9%B4%E6%9B%B4%E6%96%B0/</a></li></ul></li></ul><h2 id="kodi-播放光碟機-CD-ROM"><a href="#kodi-播放光碟機-CD-ROM" class="headerlink" title="kodi 播放光碟機 (CD-ROM)"></a>kodi 播放光碟機 (CD-ROM)</h2><p>2 wayt to play</p><ul><li>使用主畫面左邊的選項上面會有播放光碟片的圖案，memu 應該會自動出現&quot;光碟&quot;選項才對</li><li>使用 cdrom 的路徑 <code>cdda://local/</code></li></ul><h2 id="自行撰寫-kodi-套件"><a href="#自行撰寫-kodi-套件" class="headerlink" title="自行撰寫 kodi 套件"></a>自行撰寫 kodi 套件</h2><p>這邊提供幾個 resource </p><p>kodi doc</p><ul><li><a href="https://codedocs.xyz/AlwinEsch/kodi/group__python.html">https://codedocs.xyz/AlwinEsch/kodi/group__python.html</a></li></ul><p>其他教學</p><ul><li><a href="https://kodi.wiki/view/HOW-TO:HelloWorld_addon">https://kodi.wiki/view/HOW-TO:HelloWorld_addon</a></li><li><a href="http://kfbiji.com/article/b15db97eceb78756">http://kfbiji.com/article/b15db97eceb78756</a></li><li><a href="https://pypi.org/project/kodi-addon-checker/">https://pypi.org/project/kodi-addon-checker/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kodi 是一套 media center 軟體，其前身為 xbmc，這邊列出一些相關的資源&lt;/p&gt;
&lt;h2 id=&quot;遠程控制-使用手機-APP-Yatse&quot;&gt;&lt;a href=&quot;#遠程控制-使用手機-APP-Yatse&quot; class=&quot;headerlink&quot; title=&quot;遠程控制 -- 使用手機 APP: Yatse&quot;&gt;&lt;/a&gt;遠程控制 -- 使用手機 APP: Yatse&lt;/h2&gt;&lt;p&gt;Yastse 是一款 Kodi 的遙控及投放工具，你可以在 google store 找到&lt;/p&gt;
&lt;p&gt;不過你必須要先在 kodi 打開遠程控制，打開的地方在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;控制-&amp;gt;允許通過 HTTP 遠程控制，允許異地程序遠程控制&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你也可以打開Web界面，這樣就可以直接使用瀏覽器控制 kodi&lt;/p&gt;
&lt;h2 id=&quot;遠程控制-使用-firefox&quot;&gt;&lt;a href=&quot;#遠程控制-使用-firefox&quot; class=&quot;headerlink&quot; title=&quot;遠程控制 -- 使用 firefox &quot;&gt;&lt;/a&gt;遠程控制 -- 使用 firefox &lt;/h2&gt;&lt;p&gt;Firefox 有很多 kodi 的套件可供遠端控制，這裡不再詳述&lt;/p&gt;
&lt;h2 id=&quot;使用-kodi-檔案總管，並從-usb-copy-檔案到-kodi&quot;&gt;&lt;a href=&quot;#使用-kodi-檔案總管，並從-usb-copy-檔案到-kodi&quot; class=&quot;headerlink&quot; title=&quot;使用 kodi 檔案總管，並從 usb copy 檔案到 kodi&quot;&gt;&lt;/a&gt;使用 kodi 檔案總管，並從 usb copy 檔案到 kodi&lt;/h2&gt;&lt;p&gt;選擇
    系統-&amp;gt;檔案總管&lt;/p&gt;
&lt;p&gt;你就可以啟動 kodi 的檔案總管，左邊的框是操作的地方，按 C 可以叫出選單，按空白可以複選檔案例如你可以按 C 選複製，就會複製到右邊，若右邊的你找不到你要的路徑，就必須要新增瀏覽路徑&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
    <category term="Kodi" scheme="http://wwssllabcd.github.io/tags/Kodi/"/>
    
  </entry>
  
  <entry>
    <title>how-to-install-kodi-in-raspberry-pi-4</title>
    <link href="http://wwssllabcd.github.io/2020/11/08/how-to-install-kodi-in-raspberry-pi-4/"/>
    <id>http://wwssllabcd.github.io/2020/11/08/how-to-install-kodi-in-raspberry-pi-4/</id>
    <published>2020-11-07T16:06:48.000Z</published>
    <updated>2020-11-07T16:58:00.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RPI-4-安裝-kodi-的心得"><a href="#RPI-4-安裝-kodi-的心得" class="headerlink" title="RPI 4 安裝 kodi 的心得"></a>RPI 4 安裝 kodi 的心得</h2><p>因為之前的rpi 效能都不太好，所以, 許久沒碰 rpi, 這次出了8GB 號稱可以接近桌機的效能，所以就買一台試看看</p><p>PS: 寫在前頭，如果你打算使用 DVI 螢幕當作 RPI 的螢幕的話，你可能要注意，rpi 有機會不能輸出畫面</p><h2 id="購買"><a href="#購買" class="headerlink" title="購買"></a>購買</h2><p>我這次是去台灣樹梅派購買的，我購買的是 8GB + 散熱殼，那個散熱殼我蠻滿意的，風扇也是靜音風扇，只是風扇安裝需要一點技巧，好像裝錯邊風扇就會很吵，記得風扇正反不要裝錯，有貼貼紙的地方是反面，否則你的風扇不會轉</p><h2 id="安裝-kodi，使用-LibreElec"><a href="#安裝-kodi，使用-LibreElec" class="headerlink" title="安裝 kodi，使用 LibreElec"></a>安裝 kodi，使用 LibreElec</h2><p>在 rpi 4 上面安裝 kodi 已經很簡單了，LibreElec 這個專案已經把 os + kodi 整合起來，所以我們就直接安裝 libreelec 就可以了，請到以下網站抓取 image file </p><p><a href="https://libreelec.tv/raspberry-pi-4/">https://libreelec.tv/raspberry-pi-4/</a></p><p>該網站提供的下載的檔案叫做 &quot;LibreELEC-RPi4.arm-9.2.6.img.gz&quot;，下載完後使用 7z，解開她得到 img file 後，就可以使用  Win32 Disk Imager 燒錄即可，這邊跟之前的 Rpi 做法並沒有不一樣</p><p>如果還是不行，那你可以參考以前的<a href="https://wwssllabcd.github.io/blog/2013/01/31/2013-01-31-how-to-setup-raspberry-pi/#%E5%AE%89%E8%A3%9D-OS">教學</a></p><p>燒完之後，插入至RPI後，接上電源就可以使用了</p><a id="more"></a><h2 id="常見問題"><a href="#常見問題" class="headerlink" title="常見問題"></a>常見問題</h2><h2 id="沒有畫面，沒有螢幕"><a href="#沒有畫面，沒有螢幕" class="headerlink" title="沒有畫面，沒有螢幕"></a>沒有畫面，沒有螢幕</h2><p>Raspberry Pi 僅支持具有 DVI-D 插槽的設備如果你的螢幕只能使用 DVI 的話就會很麻煩，特別是那種很古老的 DVI 介面，你必須要取得你螢幕能支援的解析度</p><p>所以你必須要能在 console 執行以下指令</p><pre><code>/opt/vc/bin/tvservice -d edid.dat/opt/vc/bin/edidparser edid.dat</code></pre><p>以便得到你螢幕的參數，但是你又沒螢幕，也看不到，自然也沒法輸入指令，這邊提供兩個做法</p><ol><li>你可以使用 ssh / telnet 的方式登入到 rpi ，自然就可以下指令</li><li>找一台可以順利顯示的螢幕，輸入上述 edid 指令後，先不要執行，然後再把你的螢幕接到不能顯示的螢幕上後，再去執行該指令後，再把螢幕接回來，這樣一來你就可以得到那台無法顯示畫面的螢幕的 edid 檔案了</li></ol><p>拿到參數後，關機後修改 config.txt ，你就可以根據螢幕回報的解析度組合，來設定能支援的參數，以下連結有 video option 可以參考</p><ul><li><a href="https://www.raspberrypi.org/documentation/configuration/config-txt/video.md">https://www.raspberrypi.org/documentation/configuration/config-txt/video.md</a></li><li><a href="https://elinux.org/RPiconfig#Video_mode_options">https://elinux.org/RPiconfig#Video_mode_options</a></li><li><a href="https://pimylifeup.com/raspberry-pi-screen-resolution/">https://pimylifeup.com/raspberry-pi-screen-resolution/</a></li></ul><p>主要就是要修改 <code>hdmi_group</code> 與  <code>hdmi_mode</code> 這兩個參數</p><h2 id="沒有畫面，沒有螢幕-continue"><a href="#沒有畫面，沒有螢幕-continue" class="headerlink" title="沒有畫面，沒有螢幕(continue)"></a>沒有畫面，沒有螢幕(continue)</h2><p>如果還是不行，可以試看看在 <code>config.txt</code> 中，設定 hdmi 的輸出的選項，如以下選項都可以試試</p><pre><code>hdmi_drive chooses between HDMI and DVI modeshdmi_drive=1 Normal DVI mode (No sound)hdmi_drive=2 Normal HDMI mode (Sound will be sent if supported and enabled)</code></pre><p>讓 config.txt 強制設定螢幕介面為你裝置的介面</p><h2 id="kodi-有畫面沒有聲音"><a href="#kodi-有畫面沒有聲音" class="headerlink" title="kodi 有畫面沒有聲音"></a>kodi 有畫面沒有聲音</h2><ul><li>把 hdmi 線改接到比較靠近電源的那個插孔(注意，RPI4 會有兩個 hdmi 輸出的接孔，靠近電源的那一個才是主要的輸出)</li><li>檢查 config.txt 是否為 <code>hdmi_drive=2</code></li><li>檢查 kodi 的設定，是否沒有設定成 hdmi 輸出音效</li><li>在系統設定那邊, 選[設定]-&gt;[音效設定], 檢查輸出設定是否為[hdmi or alalog]</li></ul><h2 id="SSH-打不開"><a href="#SSH-打不開" class="headerlink" title="SSH 打不開"></a>SSH 打不開</h2><p>可能是沒有安裝 ssh ，請使用指令安裝</p><pre><code>sudo service ssh start</code></pre><p>或者是根本沒安裝</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;RPI-4-安裝-kodi-的心得&quot;&gt;&lt;a href=&quot;#RPI-4-安裝-kodi-的心得&quot; class=&quot;headerlink&quot; title=&quot;RPI 4 安裝 kodi 的心得&quot;&gt;&lt;/a&gt;RPI 4 安裝 kodi 的心得&lt;/h2&gt;&lt;p&gt;因為之前的rpi 效能都不太好，所以, 許久沒碰 rpi, 這次出了8GB 號稱可以接近桌機的效能，所以就買一台試看看&lt;/p&gt;
&lt;p&gt;PS: 寫在前頭，如果你打算使用 DVI 螢幕當作 RPI 的螢幕的話，你可能要注意，rpi 有機會不能輸出畫面&lt;/p&gt;
&lt;h2 id=&quot;購買&quot;&gt;&lt;a href=&quot;#購買&quot; class=&quot;headerlink&quot; title=&quot;購買&quot;&gt;&lt;/a&gt;購買&lt;/h2&gt;&lt;p&gt;我這次是去台灣樹梅派購買的，我購買的是 8GB + 散熱殼，那個散熱殼我蠻滿意的，風扇也是靜音風扇，只是風扇安裝需要一點技巧，好像裝錯邊風扇就會很吵，記得風扇正反不要裝錯，有貼貼紙的地方是反面，否則你的風扇不會轉&lt;/p&gt;
&lt;h2 id=&quot;安裝-kodi，使用-LibreElec&quot;&gt;&lt;a href=&quot;#安裝-kodi，使用-LibreElec&quot; class=&quot;headerlink&quot; title=&quot;安裝 kodi，使用 LibreElec&quot;&gt;&lt;/a&gt;安裝 kodi，使用 LibreElec&lt;/h2&gt;&lt;p&gt;在 rpi 4 上面安裝 kodi 已經很簡單了，LibreElec 這個專案已經把 os + kodi 整合起來，所以我們就直接安裝 libreelec 就可以了，請到以下網站抓取 image file &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://libreelec.tv/raspberry-pi-4/&quot;&gt;https://libreelec.tv/raspberry-pi-4/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;該網站提供的下載的檔案叫做 &amp;quot;LibreELEC-RPi4.arm-9.2.6.img.gz&amp;quot;，下載完後使用 7z，解開她得到 img file 後，就可以使用  Win32 Disk Imager 燒錄即可，這邊跟之前的 Rpi 做法並沒有不一樣&lt;/p&gt;
&lt;p&gt;如果還是不行，那你可以參考以前的&lt;a href=&quot;https://wwssllabcd.github.io/blog/2013/01/31/2013-01-31-how-to-setup-raspberry-pi/#%E5%AE%89%E8%A3%9D-OS&quot;&gt;教學&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;燒完之後，插入至RPI後，接上電源就可以使用了&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>指數型投資(Investment of indexing)</title>
    <link href="http://wwssllabcd.github.io/2020/02/16/Investment-of-indexing/"/>
    <id>http://wwssllabcd.github.io/2020/02/16/Investment-of-indexing/</id>
    <published>2020-02-15T20:29:30.000Z</published>
    <updated>2020-11-07T16:58:07.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>這篇是給目前不能自己挑到好股票, 但又想做投資的人看的</li><li>這邊主要的核心概念是&quot;分散&quot;, 若是能挑到好股票的人看了這篇, 不但沒幫助, 反而會有害</li></ul><h2 id="核心概念-分散投資標的以降低風險"><a href="#核心概念-分散投資標的以降低風險" class="headerlink" title="核心概念 -- 分散投資標的以降低風險"></a>核心概念 -- 分散投資標的以降低風險</h2><ul><li>分散股票種類: 購買 ETF 分散投資目標的風險</li><li>分散購入時機: 定期定額</li><li>分散股票區域性: 購入全球 ETF</li><li>分散股票類型: 股票 + 債的資產配置</li></ul><p>我先講結論, 然後再慢慢解釋我為何這樣推薦, 而作法就是   </p><h3 id="quot-定期定額購買-指數型-ETF-quot"><a href="#quot-定期定額購買-指數型-ETF-quot" class="headerlink" title="&quot;定期定額購買 指數型 ETF &quot;"></a>&quot;定期定額購買 指數型 ETF &quot;</h3><p>方法很多種, 從簡單到複雜:   </p><ol><li>利用富邦證劵, 定期定額購買富邦采吉50(006208) ETF<ul><li>投資低消為 1000元, 適合小資上班族</li><li><a href="https://www.fubon.com/securities/hot_new/open-now/etf.html">富邦定期定額 ETF</a> 1萬元以內, 手續費只要1元</li></ul></li><li>利用複委託, 例如<a href="https://www.dcn.com.tw/re-consigned/charge.htm">大昌證券複委託</a> , 定期定額購買 VT + BNDW, 或是 AOA 系列的 ETF</li><li>開網路劵商, 如 <a href="https://www.firstrade.com/content/zh-tw/welcome">Firstrade</a> or <a href="https://www.tdameritrade.com/">TD Ameritrade</a> 帳戶, 定期定額購買 VT + BNDW + VNQ ... etc</li></ol><a id="more"></a><h2 id="本文開始"><a href="#本文開始" class="headerlink" title="本文開始"></a>本文開始</h2><p>通常我們想要購買股票投資時, 會遇到兩個問題就是</p><ul><li>買哪支股票?</li><li>什麼時候買?</li></ul><p>股票那麼多種, 在規畫退休金時, 從早期的中鋼開始, 經過中華電信, 到現在的金融股, 其實變動很大, 10年前的手機很紅, 如果買了 HTC 當作退休金, 放到現在無法退休吧, 也就是說其實做長期投資, 光是 10 年其實變化就很大, 不論是公司或是產業, 因為時間一拉長的關係, 原本看好的市場或是公司不免產生一些變化, 而把退休金放在這些標的上面, 一旦發生變化那不是很可怕? </p><p>所以主動選擇產業跟公司, 其實是不太好的策略, 要避免這個問題就是要分散產業與公司, 其實有一種簡單的方法就是買市場指數型 ETF(大盤) </p><p>這邊再把這兩個問題整理一下  </p><ul><li>買哪支股票?<ul><li>我不會選股, 也看不出股票真正價值, 所以不買個股</li><li>採用 ETF 指數投資, 例如投資市值前50大的公司的 0050<ul><li>被動投資不見得會輸主動投資, 0050 其實打敗很多人</li><li>不用研究股票, 就有更多的時間拿來運用</li><li>不用怕下市, 台灣市值前50大的公司若都倒了, 那台灣應該也毀了吧, 而且買其他個股的會比你先死</li><li>連股神巴菲特都開始買 SP 500 的ETF了</li><li>買大盤指數也減少了人為操弄, 避免股市巨鯨進出而被影響</li></ul></li></ul></li><li>什麼時候買?<ul><li>世上沒人可以預估進場時機</li><li>所以使用定期購買法分散風險<ul><li>利用平均法, 長時間下來你不會買在低點, 也不會買到高點, 而是買在平均點</li></ul></li></ul></li></ul><p>也就是說, 利用定期定額購買大盤, 你就會獲得到大盤的利潤, 你不會比大盤賺, 你也不會比大盤差, 你就是拿到大盤成長的利潤</p><h2 id="戰勝市場-大盤-很難嗎"><a href="#戰勝市場-大盤-很難嗎" class="headerlink" title="戰勝市場(大盤), 很難嗎?"></a>戰勝市場(大盤), 很難嗎?</h2><p>我參考到的資料是打敗大盤不是不能, 但是很難, 你可能要花上相當大的資源才能打敗大盤, 投報率很低, 這個問題的答案理論基礎在於市場是否為效率市場有關, 大概是說假設去掉手續費, 這其實是一場零和遊戲, 那假設每個人都很厲害, 就代表市場裡的每個人都很有效率的購買股票, 最後這些人也只能拿到跟大盤一樣的利潤, 那今天有一個人比較遜, 跑來市場, 最後那些很有效率的人賺到的錢的總和就是那個比較遜的人虧的總和</p><p>不過我舉另一個例子, 巴菲特在 2008 年跟公開賭50萬美金, 賭沒有任何的對沖基金可以贏的了 Vanguard S&amp;P500 ETF(美國標普500指數型基金, 代號 VOO, 簡單的來說你可以把它想像成美國50), 2018 年巴菲特賭贏了, 這個結論也代表經理人是多餘的 :D, 他在2017 年也說過沒有人可以打敗大盤指數型基金</p><p>這個故事你可以在這邊找到: <a href="https://wealth.businessweekly.com.tw/GArticle.aspx?id=ARTL000124494">從與經理人的10年賭約，看巴菲特價值投資法</a></p><h2 id="市場一定會成長嗎"><a href="#市場一定會成長嗎" class="headerlink" title="市場一定會成長嗎?"></a>市場一定會成長嗎?</h2><p>理論上會的, 人類不斷的產生經濟活動就會創造更多的價值, 所以說你如果長期買空頭的話, 會蠻慘的</p><h2 id="台灣追蹤指數的-ETF-元大台灣-50-0050-VS-富邦台灣采吉-50-006208"><a href="#台灣追蹤指數的-ETF-元大台灣-50-0050-VS-富邦台灣采吉-50-006208" class="headerlink" title="台灣追蹤指數的 ETF -- 元大台灣 50(0050) VS 富邦台灣采吉 50(006208)"></a>台灣追蹤指數的 ETF -- 元大台灣 50(0050) VS 富邦台灣采吉 50(006208)</h2><p>在台灣有兩隻 EFT分別都是追蹤大盤指數, 分別是元大台灣 50(代號: 0050) 與富邦台灣采吉 50(代號: 006208), 基本上這兩隻性質很像, 那我們要選哪一隻呢? </p><p>在評斷 ETF 時, 有幾點要注意的</p><ul><li>追蹤誤差是多少?<ul><li>例如 元大台灣 50(0050) 與 富邦台灣采吉 50(006208) 都是追蹤大盤, 但是大盤今年漲 10%, ETF 不見得會跟著漲 10%, 可能會漲 9.5%, 如果爛一點的話可能會更低, 9%, 8% 之類的, 這種與標的物差太多的就是不好的 ETF, 相反的, 如果該 ETF 比大盤來得高, 例如是賺 10%, 11%, 也不是好的 ETF</li></ul></li><li>內扣費用高低?<ul><li>因為指數型 ETF 不需要靠經理人殺進殺出, 是根據指數做操作的, 所以管理費應該會隨著基金規模變大而下降</li><li>有良心的業者隨著規模變大應該要調降管理費用</li></ul></li></ul><p>綜合以上兩點, 我會建議你買<a href="https://websys.fsit.com.tw/FubonETF/Funds/Profile.aspx?stock=006208">富邦50</a>, 是因為 <em>&quot;富貴要人幫, 買股買這張&quot;</em> 嗎? 並不是, 而是因為他有比較低的手續費與內扣費用, 追蹤大盤的能力也很好的緣故</p><p><a href="https://www.twse.com.tw/zh/ETF/fund/0050">台灣50的費用為 0.355%</a><a href="https://www.twse.com.tw/zh/ETF/fund/00692">富邦50的費用為 0.185%</a></p><p>網路有不少分析文章, 想知道更細部的原因可以看以下幾篇</p><ul><li><a href="https://greenhornfinancefootnote.blogspot.com/2019/10/50etf0062082019.html">台50 vs 富邦 50 -- 綠角</a></li><li><a href="https://rich01.com/0050etf-vs-006208etf/">富邦台50ETF(006208)vs台灣50(0050)報酬與費用比較》小資族挑哪個好</a></li><li><a href="https://wealth.businessweekly.com.tw/GArticle.aspx?id=ARTL000120248">同樣追蹤台股大盤...月投5千買「便宜版0050」，管理費更低、賺更多！</a></li></ul><h2 id="指數型-ETF-VS-存股"><a href="#指數型-ETF-VS-存股" class="headerlink" title="指數型 ETF VS 存股"></a>指數型 ETF VS 存股</h2><p>現在也蠻流行固定購買某些特定的股票, 例如定期定額買入中華電信, 兆豐金等股票, 這些人稱存股族, 那這種投資方式好嗎?</p><p>首先, 投資的方式應該沒什麼好不好, 只有適不適合自己, 只要你能買下去, 晚上能睡好覺的就是好方式, 而&quot;定期定額購買定存股&quot;與&quot;定期定額購買大盤指數型 ETF (如台灣50)&quot; 其實差別只有在買入標, 但我覺得買入 ETF 更好, 以下是推論</p><ul><li>存股不能買了不管<ul><li>退休應該是很久的事情, 至少超過10年</li><li>10年前表現好的定存股, 10年後不見得會好</li><li>指數型 ETF 每年會自動調整, 定存股需要手動調整</li><li>不要買固定股票當存股, 除非你常常盯著他</li></ul></li></ul><p>當然, 也許你會想說定存股也可以自行調整, 這當然可以, 這邊只是提出存股不能放著不管的想法, 所以才建議購買大盤指數型 ETF, 畢竟我們不想花大時間去研究哪個股票適合當定存股, 你如果能時時刻刻照顧你的股票, 那也是 ok 的</p><h2 id="EFT-哪種比較好-元大台灣50-0050-VS-元大高股息-0056-VS-富邦公司治理-006208"><a href="#EFT-哪種比較好-元大台灣50-0050-VS-元大高股息-0056-VS-富邦公司治理-006208" class="headerlink" title="EFT 哪種比較好 -- 元大台灣50(0050) VS 元大高股息(0056) VS 富邦公司治理(006208)"></a>EFT 哪種比較好 -- 元大台灣50(0050) VS 元大高股息(0056) VS 富邦公司治理(006208)</h2><p>這幾隻都是很熱門的 ETF, 哪種比較好呢? 這邊先列出基本資料</p><ul><li>元大台灣50: 是追蹤大盤指數 ETF, 由市值最大的50大公司, 依照市值比例組成</li><li>元大高股息: 是由配股配息高的股票</li><li>富邦公司治理: 追蹤金管會發布的公司治理名單所組成</li></ul><p>直接講結論:<br>挑選 &quot;非人為能介入&quot; 的, 所以就是選大盤指數 ETF (台灣50), 理由是人可以介入的話, 就可能會出問題, 如果你認為它們兩個績效一樣的話, 那你就買指數型就好了, 問題會比較少, 更何況 0056 雖然名稱叫高股息, 但不見得會配贏 0050, 且管理費比 0050 還高, 雖然富邦公司治理(006208)其實跟大盤趨勢很像, 但基本上完全是不同的概念, 一個是主動型選股, 一個是被動選股, 績效相同只是剛巧而已</p><p>現在也看到很多不是以市場當作指數的 ETF , 例如元大高股息(0056) 就是, 雖然也叫做指數型 ETF 但其實跟原本針對市場做的指數型投資概念差很多, 千萬別搞錯了, 同理富邦公司治理(006208)也是</p><h2 id="存退休金的方式"><a href="#存退休金的方式" class="headerlink" title="存退休金的方式"></a>存退休金的方式</h2><p>定期定額其實很適合上班族, 當你每個月定期定額存入5000元到指數型基金, 等到 20 年假設你 60歲, 你可以每個月提 5000 元, 至少可以提 20 年, 至少提領到 80 歲, 當然股票是比較有波動的投資, 所以我們必須不斷地分散風險, 同時又拿到市場成長的果實</p><p>當然光是購買台灣 50 ETF 是遠遠不夠的, 你還需要資產配置, 例如搭配一點點的債劵或是 REIT 等, 這個可能等之後再來討論</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>假設我們決定要買&quot;台灣 50&quot;, 仔細想想, <strong>定期定額購買台灣50</strong> 這決策中, 背後代表什麼?    </p><ul><li>定期定額購買 + 台灣 50 ETF<ul><li>定期定額購買: 代表放棄選擇進入市場的時間, 被動進場</li><li>台灣 50 ETF: 代表放棄選股, 因為是他幫你選好了, 被動選股</li></ul></li></ul><p>最後你會發現, 我的策略其實是叫你 </p><h4 id="quot-放棄選股-也放棄選入場時機來買股票-quot"><a href="#quot-放棄選股-也放棄選入場時機來買股票-quot" class="headerlink" title="&quot;放棄選股, 也放棄選入場時機來買股票&quot;"></a>&quot;放棄選股, 也放棄選入場時機來買股票&quot;</h4><p> 這結論聽起來非常違反人性 😄</p><p>不過我非財經研究專家, 所以上面有些東西推論起來其實是有點卡卡的, 不過工程師就是要做實驗, 這個違反人性的事, 你可以每個月花1000塊, 定期定額購買 ETF, 一年後你可以再來看看這種奇怪的方式到底是好, 還是不好, 結果搞不好會讓你大吃一驚喔</p><p>最後我在文中一直提到個概念就是 <strong>分散標的</strong>, 以降低風險 , 舉一反三的你一定會發現, 我們談到的分散的範圍也只是在台灣這塊市場而已, 若是把每個國家市場都看成一間公司, 其實你會發現我們最終還是在投資一間公司而已, 而這個問題就留在下次討論嚕</p><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><p>這邊提供更多市場價值的解釋, 可以看看</p><ul><li><a href="https://www.ptt.cc/bbs/Stock/M.1523074420.A.B23.html">被動型ETF投資方式及心得</a></li></ul><p>若你還想看更多有關指數化與被動投資的文章, 可以看看下面的連結</p><ul><li>被動投資是什麼<ul><li><a href="https://rich01.com/what-passive-invest/">https://rich01.com/what-passive-invest/</a></li><li><a href="https://pgfinnote.com/understanding-passive-investing/">https://pgfinnote.com/understanding-passive-investing/</a></li><li><a href="https://www.etf168.com.tw/Article/Article?articleID=211">https://www.etf168.com.tw/Article/Article?articleID=211</a></li><li><a href="http://justin0904.pixnet.net/blog/post/222388512">http://justin0904.pixnet.net/blog/post/222388512</a></li><li><a href="https://as223400.pixnet.net/blog/post/227830082-%E8%A2%AB%E5%8B%95%E6%8A%95%E8%B3%87-%E4%BD%8E%E9%A2%A8%E9%9A%AA%E7%9A%84%E6%87%B6%E4%BA%BA%E6%8A%95%E8%B3%87%E6%96%B9%E6%B3%95">https://as223400.pixnet.net/blog/post/227830082-%E8%A2%AB%E5%8B%95%E6%8A%95%E8%B3%87-%E4%BD%8E%E9%A2%A8%E9%9A%AA%E7%9A%84%E6%87%B6%E4%BA%BA%E6%8A%95%E8%B3%87%E6%96%B9%E6%B3%95</a></li><li><a href="https://www.etf168.com.tw/Article/Article?articleID=211">https://www.etf168.com.tw/Article/Article?articleID=211</a></li></ul></li><li>指數化投資是什麼<ul><li><a href="https://greenhornfinancefootnote.blogspot.com/2013/08/1greenhorns-investment-principles.html">https://greenhornfinancefootnote.blogspot.com/2013/08/1greenhorns-investment-principles.html</a></li><li><a href="https://greenhornfinancefootnote.blogspot.com/2016/02/indexing-best-choice-for-professionals.html">https://greenhornfinancefootnote.blogspot.com/2016/02/indexing-best-choice-for-professionals.html</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;這篇是給目前不能自己挑到好股票, 但又想做投資的人看的&lt;/li&gt;
&lt;li&gt;這邊主要的核心概念是&amp;quot;分散&amp;quot;, 若是能挑到好股票的人看了這篇, 不但沒幫助, 反而會有害&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;核心概念-分散投資標的以降低風險&quot;&gt;&lt;a href=&quot;#核心概念-分散投資標的以降低風險&quot; class=&quot;headerlink&quot; title=&quot;核心概念 -- 分散投資標的以降低風險&quot;&gt;&lt;/a&gt;核心概念 -- 分散投資標的以降低風險&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分散股票種類: 購買 ETF 分散投資目標的風險&lt;/li&gt;
&lt;li&gt;分散購入時機: 定期定額&lt;/li&gt;
&lt;li&gt;分散股票區域性: 購入全球 ETF&lt;/li&gt;
&lt;li&gt;分散股票類型: 股票 + 債的資產配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我先講結論, 然後再慢慢解釋我為何這樣推薦, 而作法就是   &lt;/p&gt;
&lt;h3 id=&quot;quot-定期定額購買-指數型-ETF-quot&quot;&gt;&lt;a href=&quot;#quot-定期定額購買-指數型-ETF-quot&quot; class=&quot;headerlink&quot; title=&quot;&amp;quot;定期定額購買 指數型 ETF &amp;quot;&quot;&gt;&lt;/a&gt;&amp;quot;定期定額購買 指數型 ETF &amp;quot;&lt;/h3&gt;&lt;p&gt;方法很多種, 從簡單到複雜:   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用富邦證劵, 定期定額購買富邦采吉50(006208) ETF&lt;ul&gt;
&lt;li&gt;投資低消為 1000元, 適合小資上班族&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.fubon.com/securities/hot_new/open-now/etf.html&quot;&gt;富邦定期定額 ETF&lt;/a&gt; 1萬元以內, 手續費只要1元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用複委託, 例如&lt;a href=&quot;https://www.dcn.com.tw/re-consigned/charge.htm&quot;&gt;大昌證券複委託&lt;/a&gt; , 定期定額購買 VT + BNDW, 或是 AOA 系列的 ETF&lt;/li&gt;
&lt;li&gt;開網路劵商, 如 &lt;a href=&quot;https://www.firstrade.com/content/zh-tw/welcome&quot;&gt;Firstrade&lt;/a&gt; or &lt;a href=&quot;https://www.tdameritrade.com/&quot;&gt;TD Ameritrade&lt;/a&gt; 帳戶, 定期定額購買 VT + BNDW + VNQ ... etc&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Investment" scheme="http://wwssllabcd.github.io/tags/Investment/"/>
    
  </entry>
  
  <entry>
    <title>Python windows 安裝, 心得, 教學</title>
    <link href="http://wwssllabcd.github.io/2018/05/21/how-to-install-python-on-windows/"/>
    <id>http://wwssllabcd.github.io/2018/05/21/how-to-install-python-on-windows/</id>
    <published>2018-05-20T17:13:59.000Z</published>
    <updated>2018-06-19T15:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下載並安裝-Python"><a href="#下載並安裝-Python" class="headerlink" title="下載並安裝 Python"></a>下載並安裝 Python</h2><p>請至 <a href="https://www.python.org/downloads/windows/">Python windows 下載頁面</a>, 不是每個版本都有 window 的安裝版</p><ol><li>最好選擇 Python 3.x, 因為選 2.7 會有檔名多國語言問題, dos 下讀檔會亂碼, py 3 就沒有這問題  </li><li>最好選 32bit 的, 因為如果要打包成單一執行檔(exe file), 打包完在 32 bit 的環境跑不起來, 且有 include dll 批配的問題  </li><li>要選 32bit 還是 64 bit, 基本上要看你用到的 DLL 決定, 例如你有些額外的 dll 是使用 w32 的, 那基本上你使用 64bit 的 ptyhon 就不行, 使用而且 64 bit dll 還有 ctype call address 的問題, 建議如果不想搞死自己, 那就最好是選 32bit 的比較保險</li></ol><p>這邊是選 <a href="https://www.python.org/ftp/python/3.6.5/python-3.6.5.exe">Python 3.6.5</a> 下載</p><p>安裝時請注意以下幾點</p><ul><li>請注意安裝路徑, 他預設是在&quot;使用者&quot;目錄下面, 最好換到非中文目錄底下</li><li>要移除時, 必須執行安裝程式後, 裡面有個uninstall, 在 window 那邊好像找不到移除方式</li><li>安裝時選 customize install, 這樣才可以自選安裝路徑</li><li>也順便選 Add python 3.6 to path</li></ul><a id="more"></a><h2 id="安裝-pip"><a href="#安裝-pip" class="headerlink" title="安裝 pip"></a>安裝 pip</h2><p>如果是安裝 python 3.5 以上的, 都會預設安裝 pip, 所以只要更新 pip 即可, 這邊舉出了舉多種 python 取得 pip 所對應的方法, 分述如下:</p><ul><li><p>Python 3.4 以前的版本: 取得 get-pip.py 後, 放到 Python 安裝目錄下後, 執行</p><pre><code>  python get-pip.py   </code></pre></li></ul><p>pip 會建立在例如 <code>D:\Python27\Scripts</code> 之下, 請把 <code>get-pip.py</code> 這個 script 加入到 path 中</p><ul><li><p>Python 3.6: 是內建pip的, 所以要使用的時候, 直接打開 dos cmd 輸入 pip 指令即可更新 pip (前面的 python 不能省略)    </p><pre><code>  python -m pip install --upgrade pip</code></pre></li></ul><p>更新某個套件也可以用 pip, 若要更新 pyqt5 時, 指令如下</p><pre><code>pip install -U pyqt5</code></pre><p>其他指令可藉由 <code>pip -h</code> 查到</p><h2 id="關於-pip-與-pip3-的差異"><a href="#關於-pip-與-pip3-的差異" class="headerlink" title="關於 pip 與 pip3 的差異"></a>關於 pip 與 pip3 的差異</h2><p>pip 和 pip3 都在 Python36\Scripts\ 目錄下, 如果同時裝有python2 和 python3, pip 默認給 python2 用, pip3 指定給 python3 用, 如果只裝有 python3，則pip和pip3是等價的, 安裝了python3之後，就會有pip3</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;下載並安裝-Python&quot;&gt;&lt;a href=&quot;#下載並安裝-Python&quot; class=&quot;headerlink&quot; title=&quot;下載並安裝 Python&quot;&gt;&lt;/a&gt;下載並安裝 Python&lt;/h2&gt;&lt;p&gt;請至 &lt;a href=&quot;https://www.python.org/downloads/windows/&quot;&gt;Python windows 下載頁面&lt;/a&gt;, 不是每個版本都有 window 的安裝版&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最好選擇 Python 3.x, 因為選 2.7 會有檔名多國語言問題, dos 下讀檔會亂碼, py 3 就沒有這問題  &lt;/li&gt;
&lt;li&gt;最好選 32bit 的, 因為如果要打包成單一執行檔(exe file), 打包完在 32 bit 的環境跑不起來, 且有 include dll 批配的問題  &lt;/li&gt;
&lt;li&gt;要選 32bit 還是 64 bit, 基本上要看你用到的 DLL 決定, 例如你有些額外的 dll 是使用 w32 的, 那基本上你使用 64bit 的 ptyhon 就不行, 使用而且 64 bit dll 還有 ctype call address 的問題, 建議如果不想搞死自己, 那就最好是選 32bit 的比較保險&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這邊是選 &lt;a href=&quot;https://www.python.org/ftp/python/3.6.5/python-3.6.5.exe&quot;&gt;Python 3.6.5&lt;/a&gt; 下載&lt;/p&gt;
&lt;p&gt;安裝時請注意以下幾點&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;請注意安裝路徑, 他預設是在&amp;quot;使用者&amp;quot;目錄下面, 最好換到非中文目錄底下&lt;/li&gt;
&lt;li&gt;要移除時, 必須執行安裝程式後, 裡面有個uninstall, 在 window 那邊好像找不到移除方式&lt;/li&gt;
&lt;li&gt;安裝時選 customize install, 這樣才可以自選安裝路徑&lt;/li&gt;
&lt;li&gt;也順便選 Add python 3.6 to path&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://wwssllabcd.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>安裝 PyQt</title>
    <link href="http://wwssllabcd.github.io/2018/05/21/how-to-install-pyqt/"/>
    <id>http://wwssllabcd.github.io/2018/05/21/how-to-install-pyqt/</id>
    <published>2018-05-20T17:13:59.000Z</published>
    <updated>2018-06-19T15:15:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安裝-PyQt"><a href="#安裝-PyQt" class="headerlink" title="安裝 PyQt "></a>安裝 PyQt </h2><p>PyQT 為 python 的一款 GUI 程式, 是採用 GPL licence, 但也是不是每一版都有 windows 安裝版<br>注意: 這邊可能會更推薦使用 pip 安裝, 指令為</p><pre><code> pip install pyqt5</code></pre><p>pip 會自動根據 python 的版本自動匹配, 我這邊使用 <code>python 3.6.5</code> 批配到的是 <code>pyqt 5.10.1</code></p><pre><code>雖然 PyQt 可以自行從官網下載並安裝, 但請務必使用 pip 安裝, 後面使用的時候問題會比較少</code></pre><h2 id="安裝-Pyqt5-tools"><a href="#安裝-Pyqt5-tools" class="headerlink" title="安裝 Pyqt5-tools"></a>安裝 Pyqt5-tools</h2><p>使用 pip 安裝 PyQt 時, 並不會把 Pyqt designr 給安裝起來, 所以使用 pip 安裝 Pyqt5-tools, 以便取得 QT designer</p><pre><code>pip install pyqt5-tools</code></pre><p>而 designer 會在 </p><pre><code>D:\Python\Python36-32\Lib\site-packages\pyqt5-tools</code></pre><p>中找到</p><a id="more"></a><h2 id="PyQt-的-ui-檔轉換"><a href="#PyQt-的-ui-檔轉換" class="headerlink" title="PyQt 的 ui 檔轉換"></a>PyQt 的 ui 檔轉換</h2><p>安裝好 pyqt5 後, 可以使用 qt design 來設計 UI, 把 UI 設計好了之後存檔, 會產生 .ui檔 接下來要使用此ui 檔, 我們必須把此 ui 檔案轉換成 .py檔，方便我們直接在 Python 中使用, 使用 CMD 切換到設計好的 ui 所在目錄下，執行此指令(ui檔我們取名為 myui.ui) </p><pre><code>pyuic5 myui.ui -o myui.py</code></pre><p>而 pyuic5 路徑如下( python 安裝路徑為 D:\Python36-32 為例)</p><pre><code>D:\Python36-32\Scripts\pyuic5.exe</code></pre><p>接下來把以下文字存成&#39;PyGui.py&#39;  </p><pre><code>import sysfrom PyQt5.QtWidgets import QApplication, QDialog, QMessageBoxfrom myui import Ui_Dialogclass MyDlg(QDialog):    def __init__(self):        super(MyDlg, self).__init__()        # Set up the user interface from Designer.        self.ui = Ui_Dialog()        self.ui.setupUi(self)def main_start():    app = QApplication(sys.argv)    window = MyDlg()    window.show()    sys.exit(app.exec_())if __name__ == &#39;__main__&#39;:    main_start()</code></pre><p>再執行以下指令即可</p><pre><code>python PyGui.py </code></pre><p>ref:</p><p><a href="http://pyqt.sourceforge.net/Docs/PyQt5/designer.html">http://pyqt.sourceforge.net/Docs/PyQt5/designer.html</a></p><h2 id="在-QT-design-中觀看-ui-預覽"><a href="#在-QT-design-中觀看-ui-預覽" class="headerlink" title="在 QT design 中觀看 ui 預覽"></a>在 QT design 中觀看 ui 預覽</h2><ul><li>表單/預覽, </li><li>或是 Ctrl+R</li></ul><h2 id="LineEdit-與-TextEdit-的差異"><a href="#LineEdit-與-TextEdit-的差異" class="headerlink" title="LineEdit 與 TextEdit 的差異"></a>LineEdit 與 TextEdit 的差異</h2><p>lineEdit: 單行的 editTextEdit: 多行</p><h2 id="什麼是-Spacer"><a href="#什麼是-Spacer" class="headerlink" title="什麼是 Spacer "></a>什麼是 Spacer </h2><p>是當使用 vertical layout 時, 若中間不想放東西的時候用來填空的Horizontal Spacer 水平空白条和 Vertical Spacer 垂直空白条，空白条的作用就是填充无用的空隙，如果不希望看到控件拉伸后变丑，就可以塞一个空白条到布局器里面<a href="https://qtguide.ustclug.org/">https://qtguide.ustclug.org/</a></p><h2 id="建立一個事件"><a href="#建立一個事件" class="headerlink" title="建立一個事件"></a>建立一個事件</h2><pre><code>class MyDlg(QtGui.QDialog):    def __init__(self, parent=None):        QtGui.QWidget.__init__(self, parent)        self.ui = Ui_Dialog()        self.ui.setupUi(self)        self.ui.btnRefresh.clicked.connect(self.chk_fun)    def chk_fun(self):        print(&quot;Good.&quot;)</code></pre><p>直接在 MyDlg 中的 <code>__init__</code> 中加入事件, 並綁定到某個 function 就可以了, 例如這邊看到的是一個叫<code>btnRefresh</code> 的button, 我們把這個 button 的 clicked 的事件, 綁訂到 chk_fun 這個 function , 而這個 function 印出 good</p><p>再舉一個例子, 如 combobox 的 index change 綁定事件如下</p><pre><code>myCombobox.currentIndexChanged.connect(self.cmd_idx_change)</code></pre><h2 id="使用-keypass-event"><a href="#使用-keypass-event" class="headerlink" title="使用 keypass event"></a>使用 keypass event</h2><p>只要在該 Qdlog 中, 複寫 def keyPressEvent(self, event): 即可, 如下所示</p><pre><code>def keyPressEvent(self, event):    key = event.key()    print(key)    super(MyDlg, self).keyPressEvent(event)</code></pre><p>要注意的是, 如果現在 focus 的控鍵上有 keypassevent 的話, 會優先呼叫該控鍵的 event, 例如 txtedit 有自己的 page down , 所以 dialog 的不會對他造成影響</p><h2 id="關掉-QTextEdit-的-Scoll"><a href="#關掉-QTextEdit-的-Scoll" class="headerlink" title="關掉 QTextEdit 的 Scoll"></a>關掉 QTextEdit 的 Scoll</h2><p>找到 verticalScrollBarPolicy , 並且把她設成 off 即可</p><h2 id="設定-dialog-title"><a href="#設定-dialog-title" class="headerlink" title="設定 dialog title"></a>設定 dialog title</h2><p>self.setWindowTitle</p><h2 id="Combobox-中的下拉式-item-加長"><a href="#Combobox-中的下拉式-item-加長" class="headerlink" title="Combobox 中的下拉式 item 加長"></a>Combobox 中的下拉式 item 加長</h2><p>有個屬性叫<code>visiable item cnt</code>的數字選大一點</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;安裝-PyQt&quot;&gt;&lt;a href=&quot;#安裝-PyQt&quot; class=&quot;headerlink&quot; title=&quot;安裝 PyQt &quot;&gt;&lt;/a&gt;安裝 PyQt &lt;/h2&gt;&lt;p&gt;PyQT 為 python 的一款 GUI 程式, 是採用 GPL licence, 但也是不是每一版都有 windows 安裝版&lt;br&gt;注意: 這邊可能會更推薦使用 pip 安裝, 指令為&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; pip install pyqt5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pip 會自動根據 python 的版本自動匹配, 我這邊使用 &lt;code&gt;python 3.6.5&lt;/code&gt; 批配到的是 &lt;code&gt;pyqt 5.10.1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;雖然 PyQt 可以自行從官網下載並安裝, 但請務必使用 pip 安裝, 後面使用的時候問題會比較少&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;安裝-Pyqt5-tools&quot;&gt;&lt;a href=&quot;#安裝-Pyqt5-tools&quot; class=&quot;headerlink&quot; title=&quot;安裝 Pyqt5-tools&quot;&gt;&lt;/a&gt;安裝 Pyqt5-tools&lt;/h2&gt;&lt;p&gt;使用 pip 安裝 PyQt 時, 並不會把 Pyqt designr 給安裝起來, 所以使用 pip 安裝 Pyqt5-tools, 以便取得 QT designer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install pyqt5-tools&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而 designer 會在 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;D:\Python\Python36-32\Lib\site-packages\pyqt5-tools&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中找到&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://wwssllabcd.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>執行 amb expression</title>
    <link href="http://wwssllabcd.github.io/2017/11/12/how-to-execute-amb-expression/"/>
    <id>http://wwssllabcd.github.io/2017/11/12/how-to-execute-amb-expression/</id>
    <published>2017-11-11T17:13:59.000Z</published>
    <updated>2017-11-30T19:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立-amb-環境"><a href="#建立-amb-環境" class="headerlink" title="建立 amb 環境"></a>建立 amb 環境</h2><p>先去這邊下載</p><pre><code>https://mitpress.mit.edu/sicp/code/</code></pre><p>amb 是 chapter 4 的, 所以選以下這個下載</p><pre><code>ch4-ambeval.scm     Amb Evaluator (section 4.3)</code></pre><p>然後再scheme 中執行, 會發現 load 不進去另一個檔, 其實把兩個檔案合起來就可以了, 存成一個檔案後, 就可以使用指令 load 出來, 如下</p><pre><code>( load &quot;e:\\a.scm&quot;) </code></pre><p><code>PS：按CTRL-Y 可以貼上文字</code></p><a id="more"></a><p>然後按<code>Ctrl + x</code>, 再按<code>ctrl + e</code>就可以執行 LISP</p><p>如果出現了 </p><pre><code>;Loading &quot;e:\\a.scm&quot;... done;Value: amb-evaluator-loaded</code></pre><p>就代表載入 成功, 執行amb的部分可以參考以下</p><pre><code>http://uents.hatenablog.com/entry/sicp/059-amb-operator-with-call-cc.md</code></pre><p>接下來建立 env, 使用以下指令</p><pre><code>(define the-global-environment (setup-environment))</code></pre><h2 id="執行-amb"><a href="#執行-amb" class="headerlink" title="執行 amb "></a>執行 amb </h2><p>接下來就可以輸入 </p><pre><code>(driver-loop)</code></pre><p>如果出現</p><pre><code>;;; Amb-Eval input:</code></pre><p>此時就是代表進入到 amb 執行器, 輸入</p><pre><code>(amb 1 3 5 )</code></pre><p>會出現1 , 輸入 </p><pre><code>try-again</code></pre><p>會出現3</p><h2 id="觀察裡面的值"><a href="#觀察裡面的值" class="headerlink" title="觀察裡面的值"></a>觀察裡面的值</h2><p>例如, 我想觀察變數<code>exp</code>, 就可以在 code 中插入</p><pre><code>(newline)(display &quot;=== my print ==&quot;)(newline)(display exp)</code></pre><p>即可 trace code</p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol><li>先把輸入參數, 利用 map +analyze 分析完成後, 放到 cprocs 中</li><li>再利用 (try-next cprocs), 把每個東西都拿出來</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;建立-amb-環境&quot;&gt;&lt;a href=&quot;#建立-amb-環境&quot; class=&quot;headerlink&quot; title=&quot;建立 amb 環境&quot;&gt;&lt;/a&gt;建立 amb 環境&lt;/h2&gt;&lt;p&gt;先去這邊下載&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://mitpress.mit.edu/sicp/code/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;amb 是 chapter 4 的, 所以選以下這個下載&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ch4-ambeval.scm     Amb Evaluator (section 4.3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後再scheme 中執行, 會發現 load 不進去另一個檔, 其實把兩個檔案合起來就可以了, 存成一個檔案後, 就可以使用指令 load 出來, 如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;( load &amp;quot;e:\\a.scm&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PS：按CTRL-Y 可以貼上文字&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="sicp" scheme="http://wwssllabcd.github.io/tags/sicp/"/>
    
  </entry>
  
  <entry>
    <title>makefile 心得、教學</title>
    <link href="http://wwssllabcd.github.io/2016/10/03/how-to-write-make-file/"/>
    <id>http://wwssllabcd.github.io/2016/10/03/how-to-write-make-file/</id>
    <published>2016-10-02T17:13:59.000Z</published>
    <updated>2016-10-03T13:20:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>要寫 makefile 之前，首先我們必須要先從最基本的 GCC 編譯指令開始學起，才可以一步一步地建立起 makefile，幸好這不會花我們太多時間</p><h1 id="使用-GCC-編譯命令，並且印出-hello-world"><a href="#使用-GCC-編譯命令，並且印出-hello-world" class="headerlink" title="使用 GCC 編譯命令，並且印出 hello world "></a>使用 GCC 編譯命令，並且印出 hello world </h1><p>建立一個檔案叫做 main.c 後，輸入以下指令</p><pre><code>#include&lt;stdio.h&gt;int main()&#123;    printf(&quot;\r\nHello World&quot;);&#125;</code></pre><p>接著在命令列(windows 系統可以使用 cygwin)中，輸入 compile 指令</p><pre><code> gcc -c main.c</code></pre><p>執行完後會產生 obj file，如 main.o<br>而上述所使用的編譯參數如下所示</p><pre><code>-c : 只編譯不連結 </code></pre><p>執行連結，使用 gcc -o 指令</p><pre><code> gcc -o test main.o</code></pre><p>-o 代表作 link，-o filename 為指定輸出檔名<br>此時應該會出現一個叫 test 的檔案<br>執行 test </p><pre><code>./testHello World</code></pre><p>編譯時，如果有 header file 的時候，可以使用 -I 參數，如下所示<br>這邊是指定 header file 是在哪個目錄可以找的到</p><pre><code> gcc -c -I ./inc main.c</code></pre><a id="more"></a><h1 id="使用-makefile-簡化"><a href="#使用-makefile-簡化" class="headerlink" title="使用 makefile 簡化"></a>使用 makefile 簡化</h1><p>建立一個文字檔，取名為 makefile，內容填入如下所示</p><pre><code>test: main.o    gcc -o main.o testmain.o: main.c    gcc -c main.cclean:    rm -f *.o *.exe</code></pre><p>先解說以下這行</p><pre><code>main.o: main.c</code></pre><p>main.o: 分號前面代表目標，而後面的 main.c 就是告訴 make，要完成前面那個目標的話，必須要有<code>main.c</code>這個前置條件，所以如果輸入<code>make main.o</code> 的話，是會自動執行 <code>gcc -c main.c</code> 這段指令的，因為前置條件已經滿足，所以可以執行執行完就是產生 main.o 了</p><p>再看看第一行</p><pre><code>test: main.o</code></pre><p>test: 代表目標，而後面的 main.o 是前置條件，執行 make test 的時候，make 會找看看有沒有 main.o 這個檔，如果有的話就會執行，如果沒有的話，他會去找看看tag有沒有產生 main.o 的方法，並且嘗試產生出main.o</p><h1 id="執行-makefile"><a href="#執行-makefile" class="headerlink" title="執行 makefile"></a>執行 makefile</h1><p>在 console 輸入 make test 之後，make 會去找有無 test 這個 tag，這邊有 test 的 tag，而執行 test 的前置條件是必須要有 main.o ，則 make 會檢查有無 main.o 這個檔案，如果沒有的話，會自動搜尋 makefile 中，有無 main.o 這個檔案的產生方法，</p><p>這邊是有的，不過產生 main.o 的先決條件是要有 main.c ，則 make 會檢查有無 main.c 這個檔案，目前是有的，</p><p>所以 make 會先去執行 main.o 那個 tag，也就是 gcc -c main.c，執行這行指令後，會產生 main.o 這個檔案出來，所以執行 test 這個 tag 的條件也已經滿足了，所以可以執行 test 這個 tag ，也就是執行 gcc -o main.o test，所以產生出 test 這個檔案出來了</p><h1 id="多個檔案的-makefile"><a href="#多個檔案的-makefile" class="headerlink" title="多個檔案的 makefile"></a>多個檔案的 makefile</h1><p>加入第二個 .c file </p><pre><code>main.o: main.c    gcc -c  main.cDataIn.o: DataIn.cpp    gcc -c DataIn.cpp</code></pre><p>可以觀察到 main.o 與 dataIn.o 其實差不多格式，所以應該要有個萬用的格式例如 <em>.</em> 這種東西來簡化，而 make 的確是有這種簡化指令的，他是使用 % 來簡化，但 % 是屬於一對一的，也就是 foo.o 對應到 foo.c，這跟 * 不太一樣，而目標與前置條件都有萬用符號後，其實 gcc -c 要接的那個檔案名稱，也必須要是一種變數才行</p><pre><code>%.o: %.c    gcc -c $&lt;</code></pre><p>$&lt; : 屬於第一條件，也就是 foo.c<br>$@ : 屬於目標條件，也就是 foo.o  </p><h1 id="撰寫-makefile-的一些心得"><a href="#撰寫-makefile-的一些心得" class="headerlink" title="撰寫 makefile 的一些心得"></a>撰寫 makefile 的一些心得</h1><p>先把ld 需要的 object 建立起來，如建立起 obj_files </p><pre><code> OBJ_FILES = \    $(OBJDIR)/head.o  \    $(OBJ_LIB) \    $(OBJ_KERNEL) \</code></pre><p>然後利用 make 的前置規則讓他去找自動產生編譯需求</p><pre><code> system.bin:  $(OBJ_FILES )</code></pre><p>再利用萬用符號，讓每個檔案被編譯出來，如下所示</p><pre><code># == rule for kernel/ ==$(DIR_KERENL)/%.o: $(DIR_KERENL) /%.asm    $(AS) $&lt; -o $@$(DIR_KERENL)/%.o: $(DIR_KERENL) /%.c    $(CC) $(CFLAGS) $&lt; -o $@ </code></pre><h1 id="編譯前的-pre-task"><a href="#編譯前的-pre-task" class="headerlink" title="編譯前的 pre-task "></a>編譯前的 pre-task </h1><p>make 的前置條件，不見得是一個檔案，也可以是某個 tag</p><pre><code>all: clean mkdir boot.img </code></pre><p>這邊代表需要先執行 clean 這個規則，再需要 執行 mkdir 這個規則，然後執行boot.img</p><h1 id="make-時不顯示指令"><a href="#make-時不顯示指令" class="headerlink" title="make 時不顯示指令"></a>make 時不顯示指令</h1><p>在命令前面加上 @ ，代表不顯示該命令，如下所示@mkdir -p $@</p><h1 id="PHONY-符號的用法"><a href="#PHONY-符號的用法" class="headerlink" title=".PHONY 符號的用法"></a>.PHONY 符號的用法</h1><p>例如有時候都會見到</p><pre><code>.PHONY: clean</code></pre><p>.PHONY。這個符號的目的是告訴 make，&quot;clean&quot; 不是一個真正的檔案目標，只是一個標記，不要把他當成檔案來處理，避免有檔案真的叫 clean 時，make 會在依賴性判斷時判斷錯誤，那就糗了。</p><h1 id="在-make-file-中使用-awk"><a href="#在-make-file-中使用-awk" class="headerlink" title="在 make file 中使用 awk"></a>在 make file 中使用 awk</h1><pre><code>awk &#39;&#123; print $$1&quot; &quot;$$3 &#125;&#39; system.nm &gt; system.bsb</code></pre><p>只有使用一個$的話，會被make吃掉，使用兩個$，就不會消失</p><h1 id="makefile-中，定義變數"><a href="#makefile-中，定義變數" class="headerlink" title="makefile 中，定義變數"></a>makefile 中，定義變數</h1><p>可利用 $(MACRO) 或 ${MACRO} 來存取已定義的變數</p><p>M=$(PWD) 表明然後返回到當前目錄繼續讀入、執行當前的 Makefile。</p><h1 id="quot-語法-quot"><a href="#quot-語法-quot" class="headerlink" title="&quot;?= 語法&quot; "></a>&quot;?= 語法&quot; </h1><p>?= 語法：?= 是一個簡化的語法：若變數未定義，則替它指定新的值。否則，採用原有的值。例：FOO ?= bar若 FOO 未定義，則 FOO = bar；若 FOO 已定義，則 FOO 的值維持不變。</p><h1 id="語法"><a href="#語法" class="headerlink" title=":= 語法"></a>:= 語法</h1><p>:= 語法注意到，make 會將整個 Makefile 展開後，再決定變數的值。也就是說，變數的值將會是整個 Mackfile 中最後被指定的值。例：</p><pre><code>x = fooy = $(x) barx = xyz    # 此時 y 的值為 xyz bar</code></pre><p>在上例中，y 的值將會是 xyz bar，而不是 foo bar。您可以利用 := 來避開這個問題。:= 表示變數的值決定於它在 Makefile 中的位置，而不是整個 Makefile 展開後最終的值。</p><h1 id="巢狀-make"><a href="#巢狀-make" class="headerlink" title="巢狀 make"></a>巢狀 make</h1><p>也就是說 make 可以執行其他的 make ，如每個目錄都有自己的 make ，根目錄的 make 是可以進入到 其他目錄中，跳去執行其他的 make 後再回來使用 -C 參數。後面帶目錄名稱如下所示</p><pre><code>make -C boot</code></pre><p>你就會看到 make 會 Entering directory 後，再做 make </p><h1 id="makefile-建立目錄"><a href="#makefile-建立目錄" class="headerlink" title="makefile 建立目錄"></a>makefile 建立目錄</h1><p>必須要一個 target來幫助，如 directories，如下所示</p><pre><code>OBJDIR = ./obj$(OBJDIR):    mkdir -p $@makeDir: $&#123;OBJDIR&#125;</code></pre><p>接下來就是在 make all 那邊，加入dependence</p><pre><code>all: makeDir </code></pre><h1 id="make-內部變數"><a href="#make-內部變數" class="headerlink" title="make 內部變數"></a>make 內部變數</h1><p>$?：代表已被更新的 dependencies 的值，也就是 dependencies 中，比 targets 還新的值。<br>$@：代表 targets 的值。$&lt;：代表第一個 dependencies 的值<br>$* :代表 targets 所指定的檔案，但不包含副檔名    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;要寫 makefile 之前，首先我們必須要先從最基本的 GCC 編譯指令開始學起，才可以一步一步地建立起 makefile，幸好這不會花我們太多時間&lt;/p&gt;
&lt;h1 id=&quot;使用-GCC-編譯命令，並且印出-hello-world&quot;&gt;&lt;a href=&quot;#使用-GCC-編譯命令，並且印出-hello-world&quot; class=&quot;headerlink&quot; title=&quot;使用 GCC 編譯命令，並且印出 hello world &quot;&gt;&lt;/a&gt;使用 GCC 編譯命令，並且印出 hello world &lt;/h1&gt;&lt;p&gt;建立一個檔案叫做 main.c 後，輸入以下指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
int main()&amp;#123;
    printf(&amp;quot;\r\nHello World&amp;quot;);
&amp;#125;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接著在命令列(windows 系統可以使用 cygwin)中，輸入 compile 指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gcc -c main.c&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行完後會產生 obj file，如 main.o&lt;br&gt;而上述所使用的編譯參數如下所示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-c : 只編譯不連結 &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行連結，使用 gcc -o 指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gcc -o test main.o&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-o 代表作 link，-o filename 為指定輸出檔名&lt;br&gt;此時應該會出現一個叫 test 的檔案&lt;br&gt;執行 test &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./test

Hello World&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;編譯時，如果有 header file 的時候，可以使用 -I 參數，如下所示&lt;br&gt;這邊是指定 header file 是在哪個目錄可以找的到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gcc -c -I ./inc main.c&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="linux，makefile" scheme="http://wwssllabcd.github.io/tags/linux%EF%BC%8Cmakefile/"/>
    
  </entry>
  
  <entry>
    <title>bochs 使用教學，心得</title>
    <link href="http://wwssllabcd.github.io/2016/04/20/how-to-use-bochs/"/>
    <id>http://wwssllabcd.github.io/2016/04/20/how-to-use-bochs/</id>
    <published>2016-04-20T09:23:25.000Z</published>
    <updated>2016-06-05T16:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h1><p>使用 apt 安裝的是沒有debug 功能的，bochs 通常一出現視窗運行會沒辦法輸入指令，如果你只是要單純的執行環境的話，就使用 apt安裝吧，如果要 debug 功能的話，就要自行 compile</p><p>下載 <a href="https://sourceforge.net/projects/bochs/files/bochs/2.6.8/">bochs 2.6.8 source code</a></p><p>安裝(可參考 orange&#39;s P10)輸入下列指令 </p><pre><code>tar vxzf bochs-2.6.8.tar.gz</code></pre><p>進入目錄後，開始設定</p><pre><code>./configure --enable-disasm  --enable-debugger</code></pre><p>如果要使用 gdb 的話，就不能用 <code>--enable-debugger</code> ，要換成  <code>--enable-gdbstub</code>接下來就是</p><pre><code>makesudo make install</code></pre><a id="more"></a><h1 id="Bochs-ini-配置"><a href="#Bochs-ini-配置" class="headerlink" title="Bochs ini 配置"></a>Bochs ini 配置</h1><p>配置文件詳解可看 <a href="http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html">The configuration file bochsrc</a>也可見 linux 內核完全註釋 CH17，這邊列出我自己的 src 檔</p><pre><code>romimage: file=/usr/share/bochs/BIOS-bochs-latestmegs: 16vgaromimage: file=/usr/share/vgabios/vgabios.binfloppya: 1_44=system.img, status=insertedata0-master: type=disk, path=&quot;80.img&quot;, mode=flatboot: alog: bochsout.txtmouse: enabled=0display_library: x#debug_symbols: file=system.bsb#gdbstub: enabled=1, port=1234</code></pre><p>把以上的ini存成 <code>bochsrc.txt</code> 就可以了，另外如果有多個 ini 檔要切換時可以使用 <code>-f</code> 參數，如下所示</p><pre><code>bochs -f anotherBochIni.txt</code></pre><h1 id="bochs-載入-debug-symbols"><a href="#bochs-載入-debug-symbols" class="headerlink" title="bochs 載入 debug symbols "></a>bochs 載入 debug symbols </h1><p>載入symbol 的方是有兩種，一種是手動，一種是ini載入，以下兩者都會介紹到</p><h2 id="修改-symbol-格式"><a href="#修改-symbol-格式" class="headerlink" title="修改 symbol 格式"></a>修改 symbol 格式</h2><p>官方說，bochs的 symbol 的格式為</p><pre><code>The symbol file consists of zero or more lines of the format&quot;%x %s&quot;</code></pre><p>也就是說，只有文字檔格式 &quot;%x %s&quot;  才可以載入，不像GDB可以載入bin，而這邊可以先觀察一下 nm 輸出的格式如下</p><pre><code> 00000000 T startup_32</code></pre><p>中間有一個 type，不符合 bochs 規定的格式，所以要把那個 type 行去掉如果要改變格式，可以利用 awk 來幫助，例如要改變 nm 檔為兩行時，可用下列 awk 指令</p><pre><code> awk &#39;&#123; print $1&quot; &quot;$3 &#125;&#39; system.nm  &gt; system.bsb</code></pre><p>$1與$3 分別代表直排一與直排三，若要搭配在 make 中使用的時候，要加兩個$，如下所示 </p><pre><code>nm:   nm system.elf |sort &gt; system.nm   awk &#39;&#123; print $ $1&quot; &quot;$ $3 &#125;&#39; system.nm &gt; system.bsb</code></pre><p>nm 檔要經過修改後，才可以正確的載入到 bochs</p><h2 id="使用-ini-載入-debug-file"><a href="#使用-ini-載入-debug-file" class="headerlink" title="使用 ini 載入 debug file "></a>使用 ini 載入 debug file </h2><p>在ini中輸入</p><pre><code>debug_symbols: file=&quot;system.bsb&quot;</code></pre><p>system.bsb 為你修改過的 symbol file </p><h2 id="Bochs-手動載入-symbol"><a href="#Bochs-手動載入-symbol" class="headerlink" title="Bochs 手動載入 symbol"></a>Bochs 手動載入 symbol</h2><p>而使用 ldsym 的時候，要加雙引號，如下所示</p><pre><code> ldsym &quot;system.bsb&quot;</code></pre><h2 id="使用-gdb-當作測試-client"><a href="#使用-gdb-當作測試-client" class="headerlink" title="使用 gdb 當作測試 client"></a>使用 gdb 當作測試 client</h2><p>安裝 bochs 時，必須要打開 <code>--enable-gdbstub</code> 後，在 ini 中，加入參數即可</p><pre><code> gdbstub: enabled=1, port=1234</code></pre><h1 id="bochs-debug-指令"><a href="#bochs-debug-指令" class="headerlink" title="bochs debug 指令 "></a>bochs debug 指令 </h1><p>可以在執行時，輸入 h ，會有簡單的指令列表，而在 bochs 中，下中斷要加雙引號，如下所示</p><pre><code> b &quot;TestA&quot; </code></pre><p>也可以列出變數的值，如</p><pre><code>x/10 &quot;idt&quot;</code></pre><p>其實 bochs 應該就是根據 symbol file ，來找出對應的記憶體位置而已，</p><p>Bochs 操作蠻像 GDB 的，以下列出常用的 bochs 的debug 指令</p><table><thead><tr><th>指令</th><th>說明</th></tr></thead><tbody><tr><td>c</td><td>continue，執行 OS</td></tr><tr><td>s</td><td>單步(會進入function)</td></tr><tr><td>n</td><td>單步(不進入function)</td></tr><tr><td>b &quot;main&quot;</td><td>下中斷在 function main 的起始位置，使用時，記得要載入符號表</td></tr><tr><td>d</td><td>刪除中斷</td></tr><tr><td>blist</td><td>列出所有中斷點</td></tr><tr><td>x/10 addr</td><td>列出 addr 的位置的值</td></tr><tr><td>q</td><td>離開 bochs</td></tr></tbody></table><p>其他的指令可見 <a href="http://bochs.sourceforge.net/doc/docbook/user/internal-debugger.html">Using Bochs internal debugger</a> 說明</p><h1 id="troubleshooting"><a href="#troubleshooting" class="headerlink" title="troubleshooting "></a>troubleshooting </h1><h2 id="fatal-error-X11-extensions-Xrandr-h-No-such-file-or-directory"><a href="#fatal-error-X11-extensions-Xrandr-h-No-such-file-or-directory" class="headerlink" title="fatal error: X11/extensions/Xrandr.h: No such file or directory"></a>fatal error: X11/extensions/Xrandr.h: No such file or directory</h2><p>ANS:  missing libxrandr-dev</p><h2 id="display-library-39-sdl-39-not-available"><a href="#display-library-39-sdl-39-not-available" class="headerlink" title="display library &#39;sdl&#39; not available"></a>display library &#39;sdl&#39; not available</h2><p>手動安裝的時候，預設的display選項為 x (此例為sdl)所以<code>bochssrc.txt</code>設定要設為</p><pre><code>display_library: x</code></pre><h2 id="BIOS-No-bootable-device"><a href="#BIOS-No-bootable-device" class="headerlink" title="[BIOS ] No bootable device"></a>[BIOS ] No bootable device</h2><p>有很多問題會造成這個錯誤，這邊只是列舉一個</p><pre><code>ans:  floppya image size doesn&#39;t match one of the supported types</code></pre><p>OS 若是使用 floppy 模擬的話，磁碟最好寫滿到count 2888。最後加上</p><pre><code>count=2883 seek=5 conv=notrunc</code></pre><p>以seek5個sector為例，這邊就是寫2883個sector</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><p><a href="http://www.groad.net/bbs/thread-678-1-1.html">http://www.groad.net/bbs/thread-678-1-1.html</a><br><a href="http://www.cnblogs.com/long123king/p/3568575.html">http://www.cnblogs.com/long123king/p/3568575.html</a>     </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;安裝&quot;&gt;&lt;a href=&quot;#安裝&quot; class=&quot;headerlink&quot; title=&quot;安裝&quot;&gt;&lt;/a&gt;安裝&lt;/h1&gt;&lt;p&gt;使用 apt 安裝的是沒有debug 功能的，bochs 通常一出現視窗運行會沒辦法輸入指令，
如果你只是要單純的執行環境的話，就使用 apt安裝吧，如果要 debug 功能的話，就要自行 compile&lt;/p&gt;
&lt;p&gt;下載 &lt;a href=&quot;https://sourceforge.net/projects/bochs/files/bochs/2.6.8/&quot;&gt;bochs 2.6.8 source code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安裝(可參考 orange&amp;#39;s P10)
輸入下列指令 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar vxzf bochs-2.6.8.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;進入目錄後，開始設定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --enable-disasm  --enable-debugger&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要使用 gdb 的話，就不能用 &lt;code&gt;--enable-debugger&lt;/code&gt; ，要換成  &lt;code&gt;--enable-gdbstub&lt;/code&gt;
接下來就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make
sudo make install&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="bochs" scheme="http://wwssllabcd.github.io/tags/bochs/"/>
    
  </entry>
  
  <entry>
    <title>Bitcoin 簡介</title>
    <link href="http://wwssllabcd.github.io/2015/08/21/what-is-bitcoin/"/>
    <id>http://wwssllabcd.github.io/2015/08/21/what-is-bitcoin/</id>
    <published>2015-08-21T15:32:31.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>發明者: 中本聰(<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%9C%AC%E8%81%AA">1</a>)，但這只是化名，真實身份不明，應該是一群想撈錢的集團幹的</p><p>經過: It&#39;s a very long story，請見資料(<a href="https://yowureport.com/%E5%85%A9%E5%B9%B42%E8%90%AC%E5%80%8D%E7%9A%84%E5%8D%87%E5%80%BC%EF%BC%8C%E6%9C%80%E5%88%92%E7%AE%97%E7%9A%84%E6%8A%95%E8%B3%87-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-bitcoin/">2</a>)</p><h2 id="使用過程"><a href="#使用過程" class="headerlink" title="使用過程"></a>使用過程</h2><p>其實就是妳的電子錢包，把交易的訊息(如我要把 100 個 bitcoin 轉給 A)這條訊息用數位簽章簽過，經過P2P網路送給所有的錢包使用者手上，利用P2P網路把交易的訊息傳遞出去，利用RSA保證身份，是一種去中心化的貨幣</p><h2 id="產生比特的方式"><a href="#產生比特的方式" class="headerlink" title="產生比特的方式"></a>產生比特的方式</h2><p>就是所謂的 mining(挖礦)，透過這個公式 </p><pre><code>SHA256( Block data + Random nonce ) &lt; 難度值</code></pre><p>來算出來(<a href="https://www.ptt.cc/bbs/Soft_Job/M.1385557793.A.5E6.html">3</a>)，而 Block data 就是上一筆交易的資料，也就是說，Block data 再加上某個值 N ，如果丟到 SHA 中運算小於這次難度值的結果的話就代表挖到礦，挖到的東西就是新的 block，這個Block會把數字 N 還有這段期間收到的交易資料還有新的難度值，包成一包變成新的BlockNo後，接在舊的後面後，再藉由P2P傳出去，別人在根據新 BlockNo 繼續玩上面那套公式，而所謂的&quot;難度值&quot;會根據 BlockNo 根據當初設計的公式調整(這個數值會每隔2016個block，網絡大約每小時創建6個塊，創建2016塊大約2週)調整一次)，所以後面會越來越難挖，變成總數(發行量)會趨近於某個數值，又因為交易的資料是伴隨著新的 Block 用P2P的方式散布出去，所以有時候交易的資料並不會馬上顯示出來，約要等 6 個 block 左右的時間才可能散布到所有使用者手上</p><p>而<a href="https://zh.wikipedia.org/zh-hant/SHA%E5%AE%B6%E6%97%8F">SHA-256</a>是一種<a href="https://zh.wikipedia.org/zh-hant/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">雜湊演算法</a> (Hash algorithm)，他的公式會讓輸入的值變成長度固定的數字，例如輸入 Fox，可能會產生 DFCD3454(<a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8#/media/File:Hash_function.svg">4</a>)，他的原理有點類似拿一個質數來取餘數，如以質數 13 來做雜湊的 Base Key 的話，數字131的雜湊值就是1( 131 mod 13 = 1，就是他的餘數)，而 1 的雜湊值也是 1，而 261 的雜湊也是 1，發生了有好幾個數值Hash都相同，這個就叫做碰撞，產生碰撞的雜湊代表 Base Key 選的很爛，通常要大一點的質數才行，而SHA演算法就是以數學的角度上去確定這個碰撞的機會很小(所以才叫 &quot;Secure&quot; Hash Algorithm )</p><p>至於怎樣確定 SHA 是安全的，本人密碼學上課都在神遊，so ... 就到此為止</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;發明者: 中本聰(&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%9C%AC%E8%81%AA&quot;&gt;1&lt;/a&gt;)，但這只是化名，真實身份不明，應該是一群想撈錢的集團幹的&lt;/p&gt;
&lt;p&gt;經過: It&amp;#39;s a ver</summary>
      
    
    
    
    
    <category term="Bitcoin" scheme="http://wwssllabcd.github.io/tags/Bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>Lamobo M1( banana pi ) 安裝心得</title>
    <link href="http://wwssllabcd.github.io/2015/01/12/how-to-setup-Lamobo-m1/"/>
    <id>http://wwssllabcd.github.io/2015/01/12/how-to-setup-Lamobo-m1/</id>
    <published>2015-01-12T15:32:31.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lamobo M1 (之前比較常見的名稱為 Banana Pi, 又稱香蕉派) 跟 Raspberry pi(以下簡稱 RPI ) 一樣是屬於單版電腦，Lamobo-M1(以下簡稱 M1)而 Lamobo M1 與 Banana Pi 是同一片板子，根據該公司的說法，這是透過雙品牌的方式來運營，Banana Pi 專注於開源社群的運營</p><h1 id="評比"><a href="#評比" class="headerlink" title="評比"></a>評比</h1><p>以下為雙方比較大的差異點，見下表</p><table><thead><tr><th></th><th><a href="http://zh.wikipedia.org/wiki/%E6%A0%91%E8%8E%93%E6%B4%BE#.E7.A1.AC.E9.AB.94.E8.A7.84.E6.A0.BC.EF.BC.88Spec..EF.BC.89">Raspberry Pi Mode B</a></th><th><a href="http://lamobo.com/lamobom.html">Lamobo-M1</a></th><th>簡評</th></tr></thead><tbody><tr><td>CPU</td><td>Broadcom BCM2835 ARM11系列）700MHz</td><td><a href="http://linux-sunxi.org/A20">Allwinner A20</a> 1 GHz ARM Cortex-A7 Dual-Core</td><td>M1勝</td></tr><tr><td>GPU</td><td>Broadcom VideoCore IV @ 250 MHz</td><td>ARM Mali400MP2</td><td></td></tr><tr><td>RAM</td><td>512 M</td><td>1GB DDR3</td><td>M1勝</td></tr><tr><td>OS</td><td>支援 XBMC</td><td>支援 RPI 的 OS，也有 andorid, 但有些不能使用</td><td>各有勝負</td></tr><tr><td>sata</td><td>無</td><td>SATA*1</td><td>M1勝</td></tr><tr><td>Lan</td><td>10/100 Ethernet RJ45 x1</td><td>10/100/1000 Ethernet RJ45 x1</td><td>M1勝</td></tr></tbody></table><a id="more"></a><p>對我而言，M1 硬體的確是大勝 RPI，但我不喜歡對岸的東西，總覺得有可能會偷傳什麼資料的，除了大陸製，還有外殼難看以上這幾點外， M1的確沒什麼好挑剔的，NT 1900 就可以買到這種配備，算是佛心來著的  </p><h1 id="安裝-Raspbian"><a href="#安裝-Raspbian" class="headerlink" title="安裝 Raspbian"></a>安裝 Raspbian</h1><p>到 <a href="http://www.lemaker.org/resources/9-38/image_files.html">Lemaker OS 下載網頁</a>下載，要注意不要下載到 Pro 版本，()通常你買到的是 Banana Pi，如果你版子上有電源按鈕的話，那就是 Pro 版)，選 Raspbian 下載後解開得到 img 檔後，使用 <a href="http://sourceforge.net/projects/win32diskimager/">Win32Diskimager</a> 寫入至 SD 卡，過程與 RPI 相同，預設密碼為 <code>root/bananapi</code>，，預設電腦名稱為`lemaker&#39;，進入 OS 後，一樣可執行 Rasp-config 來修改細部設定，詳細情形與RPI相同</p><h1 id="安裝-Bananian"><a href="#安裝-Bananian" class="headerlink" title="安裝 Bananian"></a>安裝 Bananian</h1><p>到 <a href="http://www.lemaker.org/resources/9-38/image_files.html">Lemaker OS 下載網頁</a>下載，選 Raspbian 下載後解開得到 img 檔後，使用 <a href="http://sourceforge.net/projects/win32diskimager/">Win32Diskimager</a> 寫入至 SD 卡，過程與 RPI 相同，預設密碼為 <code>root/pi</code>，預設電腦名稱為<code>bananapi&#39;，進入 OS 後，可執行 </code>bananian-config` 來修改細部設定</p><h1 id="安裝-XBMC"><a href="#安裝-XBMC" class="headerlink" title="安裝 XBMC"></a>安裝 XBMC</h1><p>到 <a href="http://www.lemaker.org/resources/9-38/image_files.html">Lemaker OS 下載網頁</a>下載，選 LeMedia 後下載解壓縮完得到 img 檔後，使用 <a href="http://sourceforge.net/projects/win32diskimager/">Win32Diskimager</a> 刷入即可，不過要注意的是 LeMedia 還在開發階段，很多東西都不太能用，播放起來也很 lag，也沒聲音，簡單的來說就是 <em>XBMC for linux on Allwinner devices is NOT READY FOR USE!</em></p><h1 id="安裝-Android"><a href="#安裝-Android" class="headerlink" title="安裝 Android"></a>安裝 Android</h1><p>到 <a href="http://www.lemaker.org/resources/9-38/image_files.html">Lemaker OS 下載網頁</a>下載，選 Android，解開後得到 img 檔，但這次不能用 <a href="http://sourceforge.net/projects/win32diskimager/">Win32Diskimager</a> 來刷，要使用全志自己的卡刷工具 PhoenixCard，但是這個工具放在大陸的百度雲，下載很麻煩，打開後我卡刷也失敗，所以放棄，這邊提供<a href="http://forum.lemaker.org/cn/thread-64-1-1-Android+4.2+%E9%95%9C%E5%83%8F%E7%83%A7%E5%BD%95SD%E5%8D%A1%E6%95%99%E7%A8%8B.html">Android 詳細刷機方法</a>，有興趣可以自己參考</p><h1 id="效能"><a href="#效能" class="headerlink" title="效能"></a>效能</h1><p>因為農場是我買該機的原因，所以測試也以農場軟體相關，見下表</p><table><thead><tr><th></th><th>Raspberry pi</th><th>Lamobo-M1</th><th>簡評</th></tr></thead><tbody><tr><td>transmission-daemon</td><td>約 3MB，CPU 負載率超過 95%</td><td>輕鬆上 6MB，CPU 約 20%</td><td>M1勝</td></tr><tr><td>Samba</td><td>約 2.x MB，CUP 與 RAM 負載高</td><td>可上 9MB</td><td>M1勝</td></tr></tbody></table><p>這邊測試的是 Raspbian for Banana Pro 的 OS，而 Raspbian for Banana pi 數據只比 Raspberry Pi 好一點，我不知道為何，這個數據也許不太準，參考看看就好了，我後來改安裝 Raspbian for Banana pi ，其 transmission-daemon 的 CPU 老是給我 100%，不知哪裡有問題，不過換回去 Raspbian for Banana Pro 的就正常許多，可是我的版子又是 Banana Pi，反而要裝 For Pro 的 OS 才會比較好，真是一整個怪</p><h1 id="相關資源"><a href="#相關資源" class="headerlink" title="相關資源"></a>相關資源</h1><p>Banana pi 有其<a href="http://forum.lemaker.org/cn/forum.php">中文BPI官方論壇</a>，有中文的，但討論不熱烈，最好還是去<a href="http://forum.lemaker.org/forum.php">英文BPI官方論壇</a>比較好</p><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>我測兩次都有不一樣的數據，所以無從推薦，Lamobo 差就差在支援太少，雖然有很多 OS 可玩，但都只是能開機而已，就像是 XBMC 一樣，只是能開機而已，根本就是 NOT READY FOR USE  </p><p>Lamobo 目前只有看到在開農場的時候，同時使用 samba 會比較快之外，目前看不到什麼利基，若你喜歡折腾又有閒錢的話，可以試試，若要買還是<a href="http://www.raspberrypi.org/raspberry-pi-2-on-sale/">Raspberry Pi 2</a>會比較理想</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Lamobo M1 (之前比較常見的名稱為 Banana Pi, 又稱香蕉派) 跟 Raspberry pi(以下簡稱 RPI ) 一樣是屬於單版電腦，Lamobo-M1(以下簡稱 M1)
而 Lamobo M1 與 Banana Pi 是同一片板子，根據該公司的說法，這是透過雙品牌的方式來運營，Banana Pi 專注於開源社群的運營&lt;/p&gt;
&lt;h1 id=&quot;評比&quot;&gt;&lt;a href=&quot;#評比&quot; class=&quot;headerlink&quot; title=&quot;評比&quot;&gt;&lt;/a&gt;評比&lt;/h1&gt;&lt;p&gt;以下為雙方比較大的差異點，見下表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%A0%91%E8%8E%93%E6%B4%BE#.E7.A1.AC.E9.AB.94.E8.A7.84.E6.A0.BC.EF.BC.88Spec..EF.BC.89&quot;&gt;Raspberry Pi Mode B&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;http://lamobo.com/lamobom.html&quot;&gt;Lamobo-M1&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;簡評&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;Broadcom BCM2835 ARM11系列）700MHz&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://linux-sunxi.org/A20&quot;&gt;Allwinner A20&lt;/a&gt; 1 GHz ARM Cortex-A7 Dual-Core&lt;/td&gt;
&lt;td&gt;M1勝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GPU&lt;/td&gt;
&lt;td&gt;Broadcom VideoCore IV @ 250 MHz&lt;/td&gt;
&lt;td&gt;ARM Mali400MP2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RAM&lt;/td&gt;
&lt;td&gt;512 M&lt;/td&gt;
&lt;td&gt;1GB DDR3&lt;/td&gt;
&lt;td&gt;M1勝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OS&lt;/td&gt;
&lt;td&gt;支援 XBMC&lt;/td&gt;
&lt;td&gt;支援 RPI 的 OS，也有 andorid, 但有些不能使用&lt;/td&gt;
&lt;td&gt;各有勝負&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sata&lt;/td&gt;
&lt;td&gt;無&lt;/td&gt;
&lt;td&gt;SATA*1&lt;/td&gt;
&lt;td&gt;M1勝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Lan&lt;/td&gt;
&lt;td&gt;10/100 Ethernet RJ45 x1&lt;/td&gt;
&lt;td&gt;10/100/1000 Ethernet RJ45 x1&lt;/td&gt;
&lt;td&gt;M1勝&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 安裝教學、心得筆記</title>
    <link href="http://wwssllabcd.github.io/2014/12/22/how-to-install-hexo/"/>
    <id>http://wwssllabcd.github.io/2014/12/22/how-to-install-hexo/</id>
    <published>2014-12-22T08:48:07.000Z</published>
    <updated>2020-11-07T16:03:13.091Z</updated>
    
    <content type="html"><![CDATA[<p>自從用了 Octopress ( static page + markdown 寫 blog 後 )，我發現我回不去了以前那些所謂聰明的 blog system，以前在看 blog 的時候就超討厭 blog 自動產生一些 tag 等東西而把網頁弄得超慢，明明每次生成的東西都一樣，每一次都要自動產生的什麼鬼的，看了就不爽  </p><p>不過 Octopress 很久沒更新，且又只能限定使用 Ruby 1.9.3，造成很多不方便，所以我又跳槽到同樣是 Static Page 的 Blog System -- <a href="http://hexo.io/">Hexo</a>，特別是作者 <a href="https://twitter.com/tommy351">tommy351</a> 是台灣人，所以用起來更是愉快，這邊有<a href="http://zespia.tw/blog/2012/10/11/hexo-debut/">作者對 hexo 的介紹</a><br><img src="https://lh4.googleusercontent.com/-zW5Mdi4neqc/VJkouOcaeCI/AAAAAAAAswE/EMMODfCyNTU/s0/GitHub_icon.jpg" alt="Hexo 可建構在 GitHub 上面，為什麼放這張圖是因為它可愛 XD"></p><h1 id="安裝-Hexo"><a href="#安裝-Hexo" class="headerlink" title="安裝 Hexo "></a>安裝 Hexo </h1><h2 id="安裝-Hexo-所需檔案"><a href="#安裝-Hexo-所需檔案" class="headerlink" title="安裝 Hexo 所需檔案"></a>安裝 Hexo 所需檔案</h2><p>Hexo 是建構在 Node.js 上面，所以第一步就是安裝 Node.js，到 <a href="http://nodejs.org/">http://nodejs.org/</a> 下載並安裝，安裝好 Node.js 後，在程式集中會出現 <code>Node.js command prompt</code>，點開後會進入到命令提示字元，接下來輸入</p><pre><code>npm install hexo-cli -g</code></pre><p>而在 Ubuntu 下面安裝則要加上 sudo， 之後不再詳述此點</p><pre><code>sudo npm install hexo-cli -g</code></pre><p>安裝好後可以鍵入 hexo 看看有沒有反應，若有反應就代表安裝好了</p><pre><code>hexo # 測試 hexo 是否被正確安裝</code></pre><a id="more"></a><h2 id="建置你的-Hexo-Blog"><a href="#建置你的-Hexo-Blog" class="headerlink" title="建置你的 Hexo Blog"></a>建置你的 Hexo Blog</h2><p>選定你所要的目錄後(這邊取名叫<code>Blog</code>)，輸入</p><pre><code>hexo init Blogcd Blognpm install</code></pre><p>這樣就完成了初步的建置，這樣大致的就完成了建置了，簡單吧，若要檢視Blog可以使用</p><pre><code>hexo g  # 產生 bloghexo s  # 讓 blog 可以在 local 端檢視</code></pre><p>然後打開瀏覽器，輸入 <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000</a> 就可以看到你的 Blog 了</p><h2 id="把-Blog-放在-Github-上"><a href="#把-Blog-放在-Github-上" class="headerlink" title="把 Blog 放在 Github 上"></a>把 Blog 放在 Github 上</h2><p>首先先開一個 Repostory，取名叫 Blog 後，記住該 Repostory 的 clone 路徑後，打開本地端 Blog 中的_config.yml，尋找 <code>deploy:</code>後，type 輸入 github，repository 就去 github 那邊，把你專案的 repo 路徑抄在這，最好是選 ssh 的，branch 選 gh-pages <code>(固定，很重要，因為 github 固定以此 branch 作為網站的目錄)</code>，最後會長成像以下這個樣子</p><pre><code>deploy:    type: github    repository: git@github.com:yourname/yourRepo.git    branch: gh-pages</code></pre><p>記住，repository 後面的 yourname，請改成你的帳號，而 yourRepo 就是你剛剛取的名子，其實這個也是 git clone 使用的路徑<br>若真的不行的話，請參考<a href="http://www.jianshu.com/p/05289a4bc8b2">如何搭建一個獨立博客</a>，這邊就不再詳述  </p><p>PS: 而新版的 Hexo 已把 deploy 的方式改變，詳見 <a href="http://hexo.io/docs/deployment.html">Hexo Deployment</a>  </p><p>若發生 ERROR Deployer not found: git，請執行以下指令試試</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>接下來找到 URL 的部份，root 那邊必須要跟你的 repo 一樣，如下所示</p><pre><code># URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://xxx.github.io/Blogroot: /Blog/</code></pre><p>設好後，回到 nodejs，鍵入</p><pre><code>hexo d  # 部署 blog 到 GitHub 上</code></pre><p>就可以上傳你的 blog 到 github 了</p><h2 id="使用標準的-markdown"><a href="#使用標準的-markdown" class="headerlink" title="使用標準的 markdown"></a>使用標準的 markdown</h2><p>由於新版的 Hexo 使用 hexo-renderer-marked 來控制 Markdown ，而所以還要在調整一下，在 _config.yml 中，鍵入以下參數   </p><pre><code>marked:    gfm: true    pedantic: false    sanitize: false    tables: false    breaks: false    smartLists: false    smartypants: false</code></pre><p>其中 breaks 是控制斷行的，一般來說 markdown 是採用兩個空格( two space )來代表<code>&lt;p&gt;</code>，若喜歡用 markdown 的格式的話，這邊要設為 false，建議除了 gfm 是設 true 之外. 都設為 false 比較好  </p><h2 id="建立新文章"><a href="#建立新文章" class="headerlink" title="建立新文章"></a>建立新文章</h2><pre><code>hexo new &quot;postName&quot;  # 建立一個新的文章</code></pre><h1 id="增加其他功能"><a href="#增加其他功能" class="headerlink" title="增加其他功能"></a>增加其他功能</h1><h2 id="加入留言"><a href="#加入留言" class="headerlink" title="加入留言 "></a>加入留言 </h2><p>使用 <a href="https://disqus.com/">Disqus</a>，在_config.yml中，尋找 disqus_shortname ，並把後面加成你 Disqus 的 id </p><pre><code># Disqusdisqus_shortname: 名稱</code></pre><h2 id="加入-Google-Analytics"><a href="#加入-Google-Analytics" class="headerlink" title="加入 Google Analytics"></a>加入 Google Analytics</h2><p>Hexo 有兩個 _config.yml，一個在根目錄，一個則是 theme 使用，這邊的就要用到 theme 的 _config.yml，而以預設的 theme 來做範例，編輯 theme 目錄下的 _config.yml</p><pre><code>./themes/light/_config.yml</code></pre><p>找到<code>google_analytics:</code>後，把 ID 貼在這邊即可</p><h2 id="加入-TOC-Table-Of-Content"><a href="#加入-TOC-Table-Of-Content" class="headerlink" title="加入 TOC ( Table Of Content) "></a>加入 TOC ( Table Of Content) </h2><p>以預設的 theme 為例，在.\themes\landscape\layout_partial\article.ejs中，找到<code>&lt;%- post.content %&gt;</code>後，再把以下的段落，加在<code>&lt;%- post.content %&gt;</code>之前</p><pre><code>&lt;% if(post.toc == true)&#123; %&gt;        &lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt;            &lt;%- toc(post.content) %&gt;        &lt;/div&gt;&lt;% &#125; %&gt;</code></pre><p>以上段落就是加入 TOC 的位置，適時上可以在任何你喜歡的地方加入<br>然後在每篇文章的屬性那邊，加入</p><pre><code>toc: true </code></pre><p>就可以決定要不要打開該文章，而這邊可以利用 markdown 的<code>===</code>與<code>---</code>做 TOC 一級、二級的控制<br>題外話，這邊也可以觀察到，post 其實就是對應到文章的屬性  </p><pre><code>post.content: 文章內容post.title: 文章標題post.toc: 這邊 toc 屬性其實是自己加的，若沒設定應該是 null 的值吧</code></pre><h2 id="加入-sitemap"><a href="#加入-sitemap" class="headerlink" title="加入 sitemap "></a>加入 sitemap </h2><p>使用 sitemap 可以讓搜尋引擎可以快一點把你的網站抓回去, 加入的方法也很簡單, 鍵入</p><pre><code>npm install hexo-generator-sitemap --save</code></pre><p>然後在 <code>_config.yml</code> 中加入以下選項即可</p><pre><code>sitemap:    path: sitemap.xml</code></pre><h2 id="加入-RSS-Feed"><a href="#加入-RSS-Feed" class="headerlink" title="加入 RSS Feed "></a>加入 RSS Feed </h2><p>使用 feed 可以讓別人訂閱你的文章, 鍵入</p><pre><code>npm install hexo-generator-feed</code></pre><p>然後在 <code>_config.yml</code> 中加入</p><pre><code>#Feed Atomfeed:    type: atom    path: atom.xml    limit: 20</code></pre><p>即可</p><h1 id="從-Octopress-轉換到-Hexo"><a href="#從-Octopress-轉換到-Hexo" class="headerlink" title="從 Octopress 轉換到 Hexo"></a>從 Octopress 轉換到 Hexo</h1><p>其實要轉換不會太麻煩，只是有幾個地方要注意的就是了  </p><h2 id="網站的根目錄"><a href="#網站的根目錄" class="headerlink" title="網站的根目錄"></a>網站的根目錄</h2><p>在 _config.yml 中，網站的根目錄最好設為 <code>blog</code>(注意大小寫)，如下所示</p><pre><code>root: /blog/</code></pre><h2 id="Octopress-的文章放在-hexo-上-Compile"><a href="#Octopress-的文章放在-hexo-上-Compile" class="headerlink" title="Octopress 的文章放在 hexo 上 Compile"></a>Octopress 的文章放在 hexo 上 Compile</h2><p>文章可以直接放過去，只是 categories 要換成 tag 會比較好，不換也可以，只是 hexo 會變成 categories 而已</p><h2 id="新文章的格式"><a href="#新文章的格式" class="headerlink" title="新文章的格式"></a>新文章的格式</h2><p>Octopress 產生的 markdown 檔案是有帶日期的，但 Hexo 沒有，如果想讓 Hexo 帶日期，可以修改 _config.yml中的 <code>new_post_name</code>，改成下列格式即可</p><pre><code>new_post_name: :year-:month-:day-:title.md</code></pre><p>不過這樣改，hexo 產生文章的 link 依然是以 title 為主，這樣剛好相容於 octopress，真是太棒了  </p><h1 id="換佈景主題"><a href="#換佈景主題" class="headerlink" title="換佈景主題"></a>換佈景主題</h1><p>可先到 <a href="https://github.com/hexojs/hexo/wiki/Themes">Hexo Theme</a> 先決定好一個主題後，把該主題clone 下來，放在/theme 目錄中，如我想要換 daisy 這個主題，則需要做以下步驟</p><pre><code>git clone https://github.com/imbyron/hexo-theme-daisy.git ./themes/daisy  </code></pre><p>接著在_config.yml中，尋找 theme 這個關鍵字後，輸入剛載下來的那個目錄的名稱，如下所示</p><pre><code>theme: daisy</code></pre><h2 id="修改-default-theme-的封面"><a href="#修改-default-theme-的封面" class="headerlink" title="修改 default theme 的封面"></a>修改 default theme 的封面</h2><p>修改封面，各家的都不太一樣，要自己去找，而修改 landscape 的封面為以下兩個<br>修改封面圖案(圖片大小為 1920x1200 )</p><pre><code>YourBlogPath/themes/landscape/source/css/images/banner.jpg</code></pre><p>使用外部封面圖案</p><pre><code>YourBlogPath/themes/landscape/source/css/_variables.styl</code></pre><p>裡面的<code>banner-url = &quot;images/banner.jpg&quot;</code><br>在這邊提供一個小技巧, 因為原始的 theme 是搭配黑色為底， 所以我們可以去 Flickr 那邊找CC授權的<a href="https://www.flickr.com/search/?q=milkway">銀河(milk way)</a>照片，看到滿意的就抓下來當封面這樣就可以弄得跟預設的不一樣了</p><h2 id="修改-theme-cover"><a href="#修改-theme-cover" class="headerlink" title="修改 theme -- cover"></a>修改 theme -- cover</h2><p>Hexo 的 theme 中，有個叫 <a href="https://github.com/daisygao/hexo-themes-cover">theme cover</a> 做的蠻可愛的，也蠻乾淨的，所以這邊拿來當作範例  </p><ul><li>修改封面: 在 theme/cover下的 _comfig.yml 中修改   </li><li>修改中間的小圖: 放在/source/logo.png  </li><li>修改 brower 的 ico: 放在/source/favicon.ico</li></ul><p>而_comfig.yml中的 auto_change 最好也關掉，如果不想再文章下面出現分享到微博之類的，就把 add this 也關掉，留言系統，若想使用原本的 default 值，就把 comment_provider 槓掉即可</p><h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><h2 id="執行-hexo-d-後，出現-xxx-page-not-found"><a href="#執行-hexo-d-後，出現-xxx-page-not-found" class="headerlink" title="執行 hexo d 後，出現 xxx page not found "></a>執行 hexo d 後，出現 xxx page not found </h2><p>檢查文章檔案名稱是否包含空白</p><h2 id="執行-hexo-g-後，出現-warning-LF-will-be-replaced-by-CRLF"><a href="#執行-hexo-g-後，出現-warning-LF-will-be-replaced-by-CRLF" class="headerlink" title="執行 hexo g 後，出現 warning: LF will be replaced by CRLF"></a>執行 hexo g 後，出現 warning: LF will be replaced by CRLF</h2><p>輸入以下指令</p><pre><code>git config --global core.autocrlf false</code></pre><h2 id="在其他的地方-別台電腦-check-out-下來你的-blog-src"><a href="#在其他的地方-別台電腦-check-out-下來你的-blog-src" class="headerlink" title="在其他的地方(別台電腦) check out 下來你的 blog src  "></a>在其他的地方(別台電腦) check out 下來你的 blog src  </h2><p>因為 Hexo 的 Module 是跟著目錄的，所以如果把 code check out 下來，還是要在該目錄執行  </p><pre><code>npm install</code></pre><p>或者是</p><pre><code>npm install hexo-renderer-ejs --savenpm install hexo-renderer-marked --savenpm install hexo-renderer-stylus --save</code></pre><p>這三個，你會觀察到 ./node_modules 多了一些檔案  </p><h2 id="出現-src-refspec-master-does-not-match-any"><a href="#出現-src-refspec-master-does-not-match-any" class="headerlink" title="出現 src refspec master does not match any"></a>出現 src refspec master does not match any</h2><p>檢查一下你的 repo 是否還沒有上傳檔案，你可以先把 src 上傳之後，在做 deploy 的動作看看</p><h2 id="出現-spawn-ENOENT-at-errnoException-childprocess-js-1001-11"><a href="#出現-spawn-ENOENT-at-errnoException-childprocess-js-1001-11" class="headerlink" title="出現 spawn ENOENT at errnoException childprocess.js:1001:11"></a>出現 spawn ENOENT at errnoException childprocess.js:1001:11</h2><ul><li>輸入 git 檢查一下你的環境是否可以使用 git，如果不行的話，要把 git 加入到環境變數中才行   </li><li>輸入 node -v  檢查一下你的環境是否可以使用 node    </li><li>輸入 hexo --version 檢查一下你的環境是否可以使用 hexo   </li></ul><h2 id="出現-fatal-Could-not-read-from-remote-repository"><a href="#出現-fatal-Could-not-read-from-remote-repository" class="headerlink" title="出現 fatal: Could not read from remote repository."></a>出現 fatal: Could not read from remote repository.</h2><p>檢查 Git ssh 設定，或者是在 Git Bash 中執行</p><h2 id="出現-events-js-85-的錯誤"><a href="#出現-events-js-85-的錯誤" class="headerlink" title="出現 events.js:85 的錯誤"></a>出現 events.js:85 的錯誤</h2><p>執行 hexo d 發生錯誤，錯誤訊息如下所示</p><pre><code>INFO  Deploying: gitINFO  Clearing .deploy folder...INFO  Copying files from public folder...events.js:85    throw er; // Unhandled &#39;error&#39; event        ^Error: spawn git ENOENT    at exports._errnoException (util.js:746:11)    at Process.ChildProcess._handle.onexit (child_process.js:1053:32)    at child_process.js:1144:20    at process._tickCallback (node.js:355:11)</code></pre><p>解法: 在 Git Bash 中執行 hexo d 即可</p><h2 id="執行-hexo-d-出現-permission-denied-publickey"><a href="#執行-hexo-d-出現-permission-denied-publickey" class="headerlink" title="執行 hexo d 出現 permission denied (publickey)."></a>執行 hexo d 出現 permission denied (publickey).</h2><ul><li><p>先檢查自己的 .ssh 目錄( windows 是放在 C:\Users\yourname.ssh\  ) 有沒有放入 id_rsa</p></li><li><p>若有id_rsa檔案，但是還是有問題的話，可能是權限問題，特別是用 window 系統 copy 過去，修改成以下即可</p><p>  cd ~/.ssh  chmod 700 id_rsa</p></li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://dreamerslab.com/blog/tw/how-to-setup-a-node-js-development-environment-on-windows/">如何在 Windows 上設定 node.js 的開發環境</a><br><a href="http://www.jianshu.com/p/05289a4bc8b2">如何搭建一個獨立博客——簡明Github Pages與Hexo教程</a><br><a href="http://ibruce.info/2013/11/22/hexo-your-blog/">hexo你的博客</a><br><a href="http://code.wileam.com/update-hexo/">升級hexo的一些坑</a><br><a href="http://blog.sunnyxx.com/2014/03/07/hexo_customize/">hexo的私人訂製</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自從用了 Octopress ( static page + markdown 寫 blog 後 )，我發現我回不去了以前那些所謂聰明的 blog system，以前在看 blog 的時候就超討厭 blog 自動產生一些 tag 等東西而把網頁弄得超慢，
明明每次生成的東西都一樣，每一次都要自動產生的什麼鬼的，看了就不爽  &lt;/p&gt;
&lt;p&gt;不過 Octopress 很久沒更新，且又只能限定使用 Ruby 1.9.3，造成很多不方便，所以我又跳槽到同樣是 Static Page 的 Blog System -- &lt;a href=&quot;http://hexo.io/&quot;&gt;Hexo&lt;/a&gt;，
特別是作者 &lt;a href=&quot;https://twitter.com/tommy351&quot;&gt;tommy351&lt;/a&gt; 是台灣人，所以用起來更是愉快，
這邊有&lt;a href=&quot;http://zespia.tw/blog/2012/10/11/hexo-debut/&quot;&gt;作者對 hexo 的介紹&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://lh4.googleusercontent.com/-zW5Mdi4neqc/VJkouOcaeCI/AAAAAAAAswE/EMMODfCyNTU/s0/GitHub_icon.jpg&quot; alt=&quot;Hexo 可建構在 GitHub 上面，為什麼放這張圖是因為它可愛 XD&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;安裝-Hexo&quot;&gt;&lt;a href=&quot;#安裝-Hexo&quot; class=&quot;headerlink&quot; title=&quot;安裝 Hexo &quot;&gt;&lt;/a&gt;安裝 Hexo &lt;/h1&gt;&lt;h2 id=&quot;安裝-Hexo-所需檔案&quot;&gt;&lt;a href=&quot;#安裝-Hexo-所需檔案&quot; class=&quot;headerlink&quot; title=&quot;安裝 Hexo 所需檔案&quot;&gt;&lt;/a&gt;安裝 Hexo 所需檔案&lt;/h2&gt;&lt;p&gt;Hexo 是建構在 Node.js 上面，所以第一步就是安裝 Node.js，到 &lt;a href=&quot;http://nodejs.org/&quot;&gt;http://nodejs.org/&lt;/a&gt; 下載並安裝，
安裝好 Node.js 後，在程式集中會出現 &lt;code&gt;Node.js command prompt&lt;/code&gt;，點開後會進入到命令提示字元，接下來輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-cli -g&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而在 Ubuntu 下面安裝則要加上 sudo， 之後不再詳述此點&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo npm install hexo-cli -g&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安裝好後可以鍵入 hexo 看看有沒有反應，若有反應就代表安裝好了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo # 測試 hexo 是否被正確安裝&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Hexo" scheme="http://wwssllabcd.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Firefox addon-SDK 介紹, page-mod</title>
    <link href="http://wwssllabcd.github.io/2014/12/21/building-an-extension-for-firefox-PageMod/"/>
    <id>http://wwssllabcd.github.io/2014/12/21/building-an-extension-for-firefox-PageMod/</id>
    <published>2014-12-21T08:45:54.000Z</published>
    <updated>2016-06-05T16:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用時機"><a href="#使用時機" class="headerlink" title="使用時機"></a>使用時機</h1><p>今天要介紹的是 Firefox addon-SDK 中的 <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/page-mod">page-mod</a>, 使用時機為<code>想要把讀回來的網頁, 再加以修改</code>, 例如</p><ol><li>把某網站的排版重新排一下, 例如台鐵的火車時刻表</li><li>想把某些網站廣告區塊移除掉</li><li>想把網頁中特定資訊給顯現出來, 例如某影音網站的影片下載連結</li></ol><p>就可以使用這個, 使用的方式如下</p><h1 id="page-mode-簡介"><a href="#page-mode-簡介" class="headerlink" title="page-mode 簡介"></a>page-mode 簡介</h1><p>官方給的範例如下  </p><pre><code>var pageMod = require(&quot;sdk/page-mod&quot;);pageMod.PageMod(&#123;    include: &quot;*.mozilla.org&quot;,    contentScript: &#39;window.alert(&quot;Page matches ruleset&quot;);&#39;&#125;);</code></pre><a id="more"></a><p>這邊簡單的說明使用方式  </p><pre><code>include: 要對哪個 url 做動作, 符合的才會做接下來的動作  contentScript: 符合include 的條件後, 接下來的動作</code></pre><p>以上程式碼意思為假若 url 是 <code>*.mozilla.org</code> 的話, 則會跳出訊息<code>Page matches ruleset</code>, 當然簡單的 JS 可以這樣弄, 比較複雜的 JS 建議使用 file, 如下所示</p><pre><code>pageMod.PageMod(&#123;    include: &quot;*.mozilla.org&quot;,    contentScriptFile: &quot;./my-script.js&quot;&#125;);</code></pre><p>這邊從 <code>contentScript</code> 變成了 <code>contentScriptFile</code>, 然後 <code>./my-script.js</code> 的路徑是在 <code>/data</code> 區, 來看看<code>my-script.js</code>裡面長怎樣吧   </p><pre><code>//my-script.jswindow.alert(&quot;Page matches ruleset&quot;);   </code></pre><p>只有一行, 其實就是把 contentScript 中的括號拿掉, 就是.js中的內容了</p><h1 id="實戰-製作某影音網站的下載器"><a href="#實戰-製作某影音網站的下載器" class="headerlink" title="實戰 -- 製作某影音網站的下載器"></a>實戰 -- 製作某影音網站的下載器</h1><p>先來看一下 main.js, 當然, 目標網站的網址被我馬賽克掉了:D    </p><pre><code>var pageMod = require(&quot;sdk/page-mod&quot;);var targeURL = &quot;http://www.thisXX.com/video/*&quot;pageMod.PageMod(&#123;    include: targeURL,    contentScriptFile: &quot;./my-script.js&quot;&#125;);</code></pre><p>main.js 一如往常的簡單, 這邊說明了要針對哪個網站做動作外就沒事了, 一樣的我們把難的工作交給外部的 Java Script 檔案  </p><h2 id="找出下載連結"><a href="#找出下載連結" class="headerlink" title="找出下載連結"></a>找出下載連結</h2><p>我們的目標就是該網頁的唯一的 flv 連結 -- <code>即 http 開頭, .flv結尾</code>, 先做一個 function 來取連結</p><pre><code>var getFlvUrl = function(source)&#123;    // find .flv    var endWord = &quot;.flv&quot;;    var endPtr = source.indexOf(endWord);    var startIdx = source.lastIndexOf(&quot;http://&quot;, endPtr);    var len = endWord.length;    return source.substring(startIdx, endPtr + len  );&#125;</code></pre><p>這邊使用 indexOf 來找連結, 事實上用 regualr express 應該會更簡單, 之後再改善即可  </p><h2 id="在原網頁中-加入下載連結"><a href="#在原網頁中-加入下載連結" class="headerlink" title="在原網頁中, 加入下載連結"></a>在原網頁中, 加入下載連結</h2><p>接下來就是找一個地方放這個連結, 但如果隨便放的話, 有可能或破壞原始網頁的結構, 所以最好網頁還是一樣維持原狀, 只是在某個地方偷偷插入一段下載連結, 先來做一個超連結的 html code, 然後再把這段 code 插入原來的網頁</p><pre><code>var downloadInfo = &quot;&lt;P&gt;&lt;a href=&quot; + url + &quot;&gt;&quot; + url + &quot;&lt;/a&gt;&lt;P&gt;&quot;;</code></pre><p>接下來就是製作插入的 function, 這邊的概念也很簡單, 給定一個插入的目標還有字串, 先利用keyword 找出插入的點後, 利用substring 把原始網頁一分為二,接下來就是返還修改過的網頁, 一整個超簡單  </p><pre><code>var insertString = function(source, msg, keyword)&#123;    var idx = source.indexOf(keyword) + keyword.length;    var front = source.substring(0, idx);    var back =  source.substring(idx, source.length);        return front + msg + back;&#125;</code></pre><h2 id="把所有東西組裝起來"><a href="#把所有東西組裝起來" class="headerlink" title="把所有東西組裝起來"></a>把所有東西組裝起來</h2><p>最後就是把工具都組合起來, 這邊採用<code>點擊</code>兩字當作插入的關鍵字位置, 利用 <code>getFlvUrl(</code>) 取出 url, 利用 <code>insertString()</code> 插入下載連結後, 返還修改過的 html code 給瀏覽器    </p><pre><code>var url = getFlvUrl(document.body.innerHTML); var insert = &quot;&lt;P&gt;&lt;a href=&quot; + url + &quot;&gt;&quot; + url + &quot;&lt;/a&gt;&lt;P&gt;&quot;;var html = insertString(document.body.innerHTML, insert, &quot;點擊&quot;);document.body.innerHTML = html;</code></pre><p>整個<code>my-script.js</code>如下所示</p><pre><code>//my-script.jsvar getFlvUrl = function(source)&#123;    // find .flv    var endWord = &quot;.flv&quot;;    var endPtr = source.indexOf(endWord);    var startIdx = source.lastIndexOf(&quot;http://&quot;, endPtr);    var len = endWord.length;    return source.substring(startIdx, endPtr + len  );&#125;var insertString = function(source, msg, keyword)&#123;    var idx = source.indexOf(keyword) + keyword.length;    var front = source.substring(0, idx);    var back =  source.substring(idx, source.length);    return front + msg + back;&#125;var url = getFlvUrl(document.body.innerHTML); var insert = &quot;&lt;P&gt;&lt;a href=&quot; + url + &quot;&gt;&quot; + url + &quot;&lt;/a&gt;&lt;P&gt;&quot;;var html = insertString(document.body.innerHTML, insert, &quot;點擊&quot;);document.body.innerHTML = html;</code></pre><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>Firefox 的 addon-SDK 其實把很多事情都簡化了, 做一個附加元件其實很簡單的</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;使用時機&quot;&gt;&lt;a href=&quot;#使用時機&quot; class=&quot;headerlink&quot; title=&quot;使用時機&quot;&gt;&lt;/a&gt;使用時機&lt;/h1&gt;&lt;p&gt;今天要介紹的是 Firefox addon-SDK 中的 &lt;a href=&quot;https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/page-mod&quot;&gt;page-mod&lt;/a&gt;, 使用時機為&lt;code&gt;想要把讀回來的網頁, 再加以修改&lt;/code&gt;, 
例如&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把某網站的排版重新排一下, 例如台鐵的火車時刻表&lt;/li&gt;
&lt;li&gt;想把某些網站廣告區塊移除掉&lt;/li&gt;
&lt;li&gt;想把網頁中特定資訊給顯現出來, 例如某影音網站的影片下載連結&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就可以使用這個, 使用的方式如下&lt;/p&gt;
&lt;h1 id=&quot;page-mode-簡介&quot;&gt;&lt;a href=&quot;#page-mode-簡介&quot; class=&quot;headerlink&quot; title=&quot;page-mode 簡介&quot;&gt;&lt;/a&gt;page-mode 簡介&lt;/h1&gt;&lt;p&gt;官方給的範例如下  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var pageMod = require(&amp;quot;sdk/page-mod&amp;quot;);
pageMod.PageMod(&amp;#123;
    include: &amp;quot;*.mozilla.org&amp;quot;,
    contentScript: &amp;#39;window.alert(&amp;quot;Page matches ruleset&amp;quot;);&amp;#39;
&amp;#125;);&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Firefox extension" scheme="http://wwssllabcd.github.io/tags/Firefox-extension/"/>
    
  </entry>
  
  <entry>
    <title>打造一個 Firefox 附加元件</title>
    <link href="http://wwssllabcd.github.io/2014/05/03/building-an-extension-for-firefox/"/>
    <id>http://wwssllabcd.github.io/2014/05/03/building-an-extension-for-firefox/</id>
    <published>2014-05-02T17:32:00.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="開始之前"><a href="#開始之前" class="headerlink" title="開始之前"></a>開始之前</h1><p>以下會介紹 Mozilla 所推出的 Add-on SDK, 並且用它來打造你第一個 Firefox extension，要做的套件功能是利用 Add-on SDK 抓取匯率網站的資料，重新整理之後顯示出來  </p><p>首先先建立開發平台, 以下是需要的工具, 分別是 addon-sdk, python, firefox<img src="https://lh6.googleusercontent.com/-z0GbZ6KBNSA/VJexItwKtsI/AAAAAAAAsuM/2tHAspCDwrs/s0/Prerequisites.jpg" alt="Prerequisites"></p><ul><li><p>addon-sdk 請到 <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Installation">Mozilla 官網下載</a>, 下載完解壓縮後, 放在你喜歡的地方即可( 如 d:\project\addon-sdk)</p></li><li><p>除了 addon-sdk 外, 也需要 <a href="http://zh.wikipedia.org/zh-tw/Python">Python</a>, 由於我的平台是 windows, 所以就裝了 <a href="https://www.python.org/downloads/">Python for win</a>, 雖然有 <code>2.7.6</code>與 <code>3.4.0</code> 可以選擇, 不過mozilla 建議裝 2.7.X 的比較好, 安裝步驟就是下一步一直按下去, 沒難度.</p></li></ul><p>都安裝好了之後, 就使用<a href="http://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E5%AD%97%E5%85%83">命令提示字元</a>(以下簡稱 command line), 到 addon-sdk 下面接下來鍵入    bin\activate就會看到命令提示字元變得不太一樣了, 如下狀況<img src="https://lh4.googleusercontent.com/-zx2gUQKNiDA/VJexI1cktEI/AAAAAAAAsuI/Up_TR96b8Hw/s0/activate.jpg" alt="activate">  </p><p>這時候就是進入了 addon-sdk 開發模式, 不過這個動作在每一次關掉 command line 就要重複一次, 所以最好的做法還是把這一連串的啟動動作做成批次檔如下(我 addon-sdk 放在 d:\addon-sdk)</p><pre><code>d:cd\addon-sdkbin\activate</code></pre><a id="more"></a><h1 id="建立一個新的專案"><a href="#建立一個新的專案" class="headerlink" title="建立一個新的專案"></a>建立一個新的專案</h1><p>根據上一步, 啟動了addon-sdk 後, 在你想要的地方開始建立專案資料夾, 並且 initial 他</p><pre><code>mkdir my_addoncd my_addoncfx init</code></pre><p>執行起來大概長這樣<br><img src="https://lh6.googleusercontent.com/--JE6-Q96vNg/VJexJkW8erI/AAAAAAAAsuY/dHz8BMapgsM/s0/cfxInit.jpg" alt="cfxInit">  </p><h1 id="開始第一支程式-Hello-World"><a href="#開始第一支程式-Hello-World" class="headerlink" title="開始第一支程式 -- Hello World"></a>開始第一支程式 -- Hello World</h1><p>目錄中的 lib 的資料夾, 裡面有個 <code>main.js</code>, 則是套件的起點, 用編輯器打開, 鍵入以下程式碼</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var widgets &#x3D; require(&quot;sdk&#x2F;widget&quot;).Widget;</span><br><span class="line">myWedget &#x3D; widgets(&#123;</span><br><span class="line">id: &quot;I-am-wedget&quot;,</span><br><span class="line">label: &quot;wedget&quot;,</span><br><span class="line">content: &quot;Hello World!&quot;,</span><br><span class="line">tooltip: &quot;I-am-tooltip&quot;,</span><br><span class="line">width: 100</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>把<code>main.js</code>編碼選擇 UTF-8 後儲存關閉, 接下來就可以看看效果如何了<br>鍵入 </p><pre><code>cfx run</code></pre><p>之後就會跳出一個乾淨的 Firefox, 並且上面有你剛做的套件, 基本上 Wedget 算是顯示用的, 很簡單吧<img src="https://lh4.googleusercontent.com/-j8rzmz7qQeg/VJexKJ9PyhI/AAAAAAAAsug/oCEDsbIeVnU/s0/helloworld.jpg" alt="HelloWorld">  </p><h2 id="有關資源的存取"><a href="#有關資源的存取" class="headerlink" title="有關資源的存取"></a>有關資源的存取</h2><p>my_addon 目錄會出現數個資料夾, 如lib, data, doc, test 等, 其中 data 區對應到 code 裡面的 resource 的根目錄,如<code>./a.png</code>的意思就是代表存取 data 區裡面的 a.png 的意思，如果要用到外部的 JavaScript file ，也是放在 ./data中  </p><h2 id="放出-Message"><a href="#放出-Message" class="headerlink" title="放出 Message "></a>放出 Message </h2><p>使用 console.log 即可，如下所示  </p><pre><code>console.log(&quot;A= %D&quot;, 100)</code></pre><h1 id="實戰-製作一個抓取匯率的套件"><a href="#實戰-製作一個抓取匯率的套件" class="headerlink" title="實戰 -- 製作一個抓取匯率的套件"></a>實戰 -- 製作一個抓取匯率的套件</h1><h2 id="抓取某銀行網頁匯率的資料-使用-page-worker-取回網頁"><a href="#抓取某銀行網頁匯率的資料-使用-page-worker-取回網頁" class="headerlink" title="抓取某銀行網頁匯率的資料, 使用 page-worker 取回網頁"></a>抓取某銀行網頁匯率的資料, 使用 page-worker 取回網頁</h2><p>此時就要用 <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/page-worker">page-worker</a> 來幫你實現了, 延續剛剛的 Wedget, 這次我們來抓某個網頁的資料, 並且用 tooltip 的方式, 把它顯示在 Wedget 上面  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var widgets &#x3D; require(&quot;sdk&#x2F;widget&quot;).Widget;</span><br><span class="line">myWedget &#x3D; widgets(&#123;</span><br><span class="line">id: &quot;I-am-wedget&quot;,</span><br><span class="line">label: &quot;wedget&quot;,</span><br><span class="line">content: &quot;Hello World!&quot;,</span><br><span class="line">tooltip: &quot;I-am-tooltip&quot;,</span><br><span class="line">width: 100</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var pageWorkers &#x3D; require(&quot;sdk&#x2F;page-worker&quot;);</span><br><span class="line">var myWedget, myPW</span><br><span class="line">var script &#x3D; &quot;postMessage(document.body.innerHTML);&quot;;</span><br><span class="line">var targetURL &#x3D; &quot;http:&#x2F;&#x2F;rate.bot.com.tw&#x2F;Pages&#x2F;Static&#x2F;UIP003.zh-TW.htm&quot;;</span><br><span class="line"></span><br><span class="line">myPW &#x3D; pageWorkers.Page(&#123;</span><br><span class="line">contentURL: targetURL,</span><br><span class="line">contentScript: script,</span><br><span class="line">contentScriptWhen: &quot;ready&quot;,</span><br><span class="line">onMessage: function(message) &#123;</span><br><span class="line">myWedget.tooltip &#x3D; message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>這邊說明一下 PageWorkers 的屬性部分  </p><ul><li>contentURL: 代表的是要抓的 url</li><li>contentScript: 代表的是,抓回來要做什麼要的處理, 這邊我們只有把 document.body.innerHTML 藉由 postMessage 傳送出去</li><li>onMessage: 則負責接收 postMessage 丟出來的訊息, 也就是該網頁的 innerHTML 了, 並且把他設給 Wedget 的 tooltip </li></ul><p>我隨便選一個提供匯率的網頁, 並且把他設定給 targetURL, 他會把該網頁的 html, 顯示成為 Wedget 的 tooltip 上面, 原本把滑鼠移上去會顯示 <code>I-am-tooltip</code>, 現在已經變成亂七八糟的 html code 了, 如下所示<img src="https://lh5.googleusercontent.com/-QG7ut0HyUXo/VJexKX3oBrI/AAAAAAAAsuk/qIfCLqA8x50/s0/htmlCode.jpg" alt="htmlCode">  </p><h2 id="進一步的清理網頁資料"><a href="#進一步的清理網頁資料" class="headerlink" title="進一步的清理網頁資料"></a>進一步的清理網頁資料</h2><p>接下來就有點是 dirty work 了, 我們如果要把每個匯率的資料抓出來的話, 要怎做?<br>先觀察 html, 發現在匯率前面都會有串字串叫</p><pre><code>&quot;/Images/Flags/America.gif&quot;</code></pre><p>結束的字串都是為</p><pre><code>&quot;&lt;/td&gt;&lt;td class=&quot;</code></pre><p>我們利用這兩個字串當作識別項, 試看看能否把匯率的值給抓出來  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var findKeyWord &#x3D; function(keyWord, source, cellNo)</span><br><span class="line">&#123;</span><br><span class="line">var startWord &#x3D; &quot;&#x2F;Images&#x2F;Flags&#x2F;America.gif&quot;;</span><br><span class="line">var endWord &#x3D; &quot;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通常是Table的起始</span><br><span class="line">var startIdx &#x3D; source.indexOf(startWord);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從table的起點往後找KeyWord</span><br><span class="line">var keyWordIdx &#x3D; source.indexOf(keyWord,startIdx);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從keyword往後找結束符號</span><br><span class="line">var temp &#x3D; keyWordIdx;</span><br><span class="line">for(i&#x3D;0; i&lt;cellNo; i++)&#123;</span><br><span class="line">temp &#x3D; source.indexOf(endWord,temp)+1;</span><br><span class="line">&#125;</span><br><span class="line">endIdx &#x3D; temp-1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從EndIndex往前找，找&gt;關鍵字，但是要往前移一個</span><br><span class="line">var curIdx &#x3D; source.lastIndexOf(&quot;&gt;&quot;,endIdx)+1;</span><br><span class="line">return source.substring(curIdx,endIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>傳入要找的關鍵字(keyword), 資料來源(source), 還有要取第幾格的號碼(cellNo)來取出特定格數的資料出來, 貌似可以做到.  </p><p>再加點輔助程式吧, 現在只要呼叫 getResult 並且把 html 傳入的話, 就會得到完整的匯率表了  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">var getResult &#x3D; function(msg)&#123;</span><br><span class="line">var res &#x3D; &quot;&quot;;</span><br><span class="line">res +&#x3D; &quot;幣別： 現金買入 , 即期買入&quot;;</span><br><span class="line">res +&#x3D; getOneString(&quot;美金 ：&quot;, &quot;美金 (USD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;港幣 ：&quot;, &quot;港幣 (HKD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;英鎊 ：&quot;, &quot;英鎊 (GBP)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;澳幣 ：&quot;, &quot;澳幣 (AUD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;加拿大幣：&quot;, &quot;加拿大幣 (CAD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;新加坡幣：&quot;, &quot;新加坡幣 (SGD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;新加坡幣：&quot;, &quot;瑞士法朗 (CHF)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;日圓 ：&quot;, &quot;日圓 (JPY)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;南非幣 ：&quot;, &quot;南非幣 (ZAR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;瑞典幣 ：&quot;, &quot;瑞典幣 (SEK)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;紐元 ：&quot;, &quot;紐元 (NZD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;泰幣 ：&quot;, &quot;泰幣 (THB)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;菲國比索：&quot;, &quot;菲國比索 (PHP)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;印尼幣 ：&quot;, &quot;印尼幣 (IDR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;歐元 ：&quot;, &quot;歐元 (EUR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;韓元 ：&quot;, &quot;韓元 (KRW)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;越南盾 ：&quot;, &quot;越南盾 (VND)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;馬來幣 ：&quot;, &quot;馬來幣 (MYR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;人民幣 ：&quot;, &quot;人民幣 (CNY)&quot;, msg);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getOneString &#x3D; function(title, keyWord, html)&#123;</span><br><span class="line">var res_1, res_2;</span><br><span class="line">var res &#x3D; &quot;&quot;;</span><br><span class="line">res_1 &#x3D; findKeyWord(keyWord, html, 2);</span><br><span class="line">res_2 &#x3D; findKeyWord(keyWord, html, 4);</span><br><span class="line">res &#x3D; &quot;\n&quot; + title + res_1 + &quot;, &quot; + res_2;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var findKeyWord &#x3D; function(keyWord, source, cellNo)</span><br><span class="line">&#123;</span><br><span class="line">var startWord &#x3D; &quot;&#x2F;Images&#x2F;Flags&#x2F;America.gif&quot;;</span><br><span class="line">var endWord &#x3D; &quot;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通常是Table的起始</span><br><span class="line">var startIdx &#x3D; source.indexOf(startWord);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從table的起點往後找KeyWord</span><br><span class="line">var keyWordIdx &#x3D; source.indexOf(keyWord,startIdx);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從keyword往後找結束符號</span><br><span class="line">var temp &#x3D; keyWordIdx;</span><br><span class="line">for(i&#x3D;0; i&lt;cellNo; i++)&#123;</span><br><span class="line">temp &#x3D; source.indexOf(endWord,temp)+1;</span><br><span class="line">&#125;</span><br><span class="line">endIdx &#x3D; temp-1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從EndIndex往前找，找&gt;關鍵字，但是要往前移一個</span><br><span class="line">var curIdx &#x3D; source.lastIndexOf(&quot;&gt;&quot;,endIdx)+1;</span><br><span class="line">return source.substring(curIdx,endIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很髒很麻煩, 且一旦該網頁換掉格式就沒用了, 不是嗎?<br>我也沒辦法, 不推 API介接, 不推開放資料統一格式就是這樣麻煩, 先不提了.<br>現在我們只要在 pageWorkers 的 onMessage 加上 剛新作的 function -- getResult 就可以了   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onMessage: function(message) &#123;</span><br><span class="line">myWedget.tooltip &#x3D; getResult(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把所有東西組裝起來"><a href="#把所有東西組裝起來" class="headerlink" title="把所有東西組裝起來"></a>把所有東西組裝起來</h2><p>來看看效果吧, 很簡單吧<br><img src="https://lh6.googleusercontent.com/-XLs50aKm4qc/VJexK0N9uwI/AAAAAAAAsuw/YTqSzO1Pad0/s0/result.jpg" alt="result">  </p><p>我再把整個程式整理一下,大家可以參考  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">var widgets &#x3D; require(&quot;sdk&#x2F;widget&quot;).Widget;</span><br><span class="line">var pageWorkers &#x3D; require(&quot;sdk&#x2F;page-worker&quot;);</span><br><span class="line">var myWedget, myPW</span><br><span class="line"></span><br><span class="line">myWedget &#x3D; widgets(&#123;</span><br><span class="line">id: &quot;erw-wedget&quot;,</span><br><span class="line">label: &quot;erw&quot;,</span><br><span class="line">content: &quot;即時匯率&quot;,</span><br><span class="line">tooltip: &quot;wait ready&quot;,</span><br><span class="line">width: 50</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">var script &#x3D; &quot;postMessage(document.body.innerHTML);&quot;;</span><br><span class="line">var targetURL &#x3D; &quot;http:&#x2F;&#x2F;rate.bot.com.tw&#x2F;Pages&#x2F;Static&#x2F;UIP003.zh-TW.htm&quot;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">myPW &#x3D; pageWorkers.Page(&#123;</span><br><span class="line">contentURL: targetURL,</span><br><span class="line">contentScript: script,</span><br><span class="line">contentScriptWhen: &quot;ready&quot;,</span><br><span class="line">onMessage: function(message) &#123;</span><br><span class="line">myWedget.tooltip &#x3D; getResult(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var getResult &#x3D; function(msg)&#123;</span><br><span class="line">var res &#x3D; &quot;&quot;;</span><br><span class="line">res +&#x3D; &quot;幣別： 現金買入 , 即期買入&quot;;</span><br><span class="line">res +&#x3D; getOneString(&quot;美金 ：&quot;, &quot;美金 (USD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;港幣 ：&quot;, &quot;港幣 (HKD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;英鎊 ：&quot;, &quot;英鎊 (GBP)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;澳幣 ：&quot;, &quot;澳幣 (AUD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;加拿大幣：&quot;, &quot;加拿大幣 (CAD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;新加坡幣：&quot;, &quot;新加坡幣 (SGD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;新加坡幣：&quot;, &quot;瑞士法朗 (CHF)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;日圓 ：&quot;, &quot;日圓 (JPY)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;南非幣 ：&quot;, &quot;南非幣 (ZAR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;瑞典幣 ：&quot;, &quot;瑞典幣 (SEK)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;紐元 ：&quot;, &quot;紐元 (NZD)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;泰幣 ：&quot;, &quot;泰幣 (THB)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;菲國比索：&quot;, &quot;菲國比索 (PHP)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;印尼幣 ：&quot;, &quot;印尼幣 (IDR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;歐元 ：&quot;, &quot;歐元 (EUR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;韓元 ：&quot;, &quot;韓元 (KRW)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;越南盾 ：&quot;, &quot;越南盾 (VND)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;馬來幣 ：&quot;, &quot;馬來幣 (MYR)&quot;, msg);</span><br><span class="line">res +&#x3D; getOneString(&quot;人民幣 ：&quot;, &quot;人民幣 (CNY)&quot;, msg);</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getOneString &#x3D; function(title, keyWord, html)&#123;</span><br><span class="line">var res_1, res_2;</span><br><span class="line">var res &#x3D; &quot;&quot;;</span><br><span class="line">res_1 &#x3D; findKeyWord(keyWord, html, 2);</span><br><span class="line">res_2 &#x3D; findKeyWord(keyWord, html, 4);</span><br><span class="line">res &#x3D; &quot;\n&quot; + title + res_1 + &quot;, &quot; + res_2;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var findKeyWord &#x3D; function(keyWord, source, cellNo)&#123;</span><br><span class="line">var startWord &#x3D; &quot;&#x2F;Images&#x2F;Flags&#x2F;America.gif&quot;;</span><br><span class="line">var endWord &#x3D; &quot;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通常是Table的起始</span><br><span class="line">var startIdx &#x3D; source.indexOf(startWord);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從table的起點往後找KeyWord</span><br><span class="line">var keyWordIdx &#x3D; source.indexOf(keyWord,startIdx);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從keyword往後找結束符號</span><br><span class="line">var temp &#x3D; keyWordIdx;</span><br><span class="line">for(i&#x3D;0; i&lt;cellNo; i++)&#123;</span><br><span class="line">temp &#x3D; source.indexOf(endWord,temp)+1;</span><br><span class="line">&#125;</span><br><span class="line">endIdx &#x3D; temp-1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;從EndIndex往前找，找&gt;關鍵字，但是要往前移一個</span><br><span class="line">var curIdx &#x3D; source.lastIndexOf(&quot;&gt;&quot;,endIdx)+1;</span><br><span class="line">return source.substring(curIdx,endIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>其實 Mozilla 也有出<a href="https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Installation">官方教學</a>, 大家也可以參考看看</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;開始之前&quot;&gt;&lt;a href=&quot;#開始之前&quot; class=&quot;headerlink&quot; title=&quot;開始之前&quot;&gt;&lt;/a&gt;開始之前&lt;/h1&gt;&lt;p&gt;以下會介紹 Mozilla 所推出的 Add-on SDK, 並且用它來打造你第一個 Firefox extension，要做的套件功能是利用 Add-on SDK 抓取匯率網站的資料，重新整理之後顯示出來  &lt;/p&gt;
&lt;p&gt;首先先建立開發平台, 以下是需要的工具, 分別是 addon-sdk, python, firefox
&lt;img src=&quot;https://lh6.googleusercontent.com/-z0GbZ6KBNSA/VJexItwKtsI/AAAAAAAAsuM/2tHAspCDwrs/s0/Prerequisites.jpg&quot; alt=&quot;Prerequisites&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;addon-sdk 請到 &lt;a href=&quot;https://developer.mozilla.org/en-US/Add-ons/SDK/Tutorials/Installation&quot;&gt;Mozilla 官網下載&lt;/a&gt;, 
下載完解壓縮後, 放在你喜歡的地方即可( 如 d:\project\addon-sdk)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除了 addon-sdk 外, 也需要 &lt;a href=&quot;http://zh.wikipedia.org/zh-tw/Python&quot;&gt;Python&lt;/a&gt;, 由於我的平台是 windows, 所以就裝了 &lt;a href=&quot;https://www.python.org/downloads/&quot;&gt;Python for win&lt;/a&gt;, 
雖然有 &lt;code&gt;2.7.6&lt;/code&gt;與 &lt;code&gt;3.4.0&lt;/code&gt; 可以選擇, 不過mozilla 建議裝 2.7.X 的比較好, 安裝步驟就是下一步一直按下去, 沒難度.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;都安裝好了之後, 就使用&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E5%AD%97%E5%85%83&quot;&gt;命令提示字元&lt;/a&gt;(以下簡稱 command line), 到 addon-sdk 下面
接下來鍵入
    bin\activate
就會看到命令提示字元變得不太一樣了, 如下狀況
&lt;img src=&quot;https://lh4.googleusercontent.com/-zx2gUQKNiDA/VJexI1cktEI/AAAAAAAAsuI/Up_TR96b8Hw/s0/activate.jpg&quot; alt=&quot;activate&quot;&gt;  &lt;/p&gt;
&lt;p&gt;這時候就是進入了 addon-sdk 開發模式, 不過這個動作在每一次關掉 command line 就要重複一次, 所以最好的做法還是把這一連串的啟動動作做成批次檔如下(我 addon-sdk 放在 d:\addon-sdk)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;d:
cd\addon-sdk
bin\activate&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Firefox extension" scheme="http://wwssllabcd.github.io/tags/Firefox-extension/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry Pi 安裝 Archlinux</title>
    <link href="http://wwssllabcd.github.io/2013/11/14/how-to-install-archlinux-on-raspberrypi/"/>
    <id>http://wwssllabcd.github.io/2013/11/14/how-to-install-archlinux-on-raspberrypi/</id>
    <published>2013-11-14T11:48:00.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>簡短的紀錄一下 Raspberry pi 如何安裝 Archlinux，並且使用 pacman 安裝幾個套件  </p><p>一樣去下載頁面下載 arch linux OS 回來後，解壓縮可以得到 img 檔，安裝完後，開機，使用使用 pietty(talnet 軟體) 連線後登入，此時的安裝方式都與 wheezy 相同  </p><h1 id="更新-pacman"><a href="#更新-pacman" class="headerlink" title="更新 pacman"></a>更新 pacman</h1><p>要先更新 pacman ，否則某些套件會找不到</p><p>輸入以下指令</p><pre><code>pacman -Syypacman -Syu</code></pre><a id="more"></a><h1 id="安裝-transmission"><a href="#安裝-transmission" class="headerlink" title="安裝 transmission "></a>安裝 transmission </h1><p>使用 pacman 安裝，輸入</p><pre><code>pacman -S transmission-cli</code></pre><p>可參考<a href="https://wiki.archlinux.org/index.php/Transmission">archlinux 的 Transmission 安裝教學</a></p><p>安裝完後，先啟動, 讓他產生參數</p><pre><code>systemctl start transmission.service</code></pre><p>再停止，以便修改參數</p><pre><code>systemctl stop transmission.service</code></pre><p>檢查 status 是否正確停止</p><pre><code>systemctl status |grep transmission</code></pre><p>輸入</p><pre><code>transmission-daemon</code></pre><p>不知為何，要打入這個才會出現.config 的 folder</p><p>修改參數後重新啟動</p><pre><code>systemctl daemon-reloadsystemctl restart unit</code></pre><h1 id="安裝-samba"><a href="#安裝-samba" class="headerlink" title="安裝 samba "></a>安裝 samba </h1><p>使用 pacman 安裝套件</p><pre><code>pacman -S samba</code></pre><p>進入 <code>/etc/samba/</code>，把 <code>smb.conf.default</code> cp一份為 <code>smb.conf</code>，並且修改 <code>smb.conf</code>修改conf這邊不再贅述，若不懂的話，請參閱本站 samba 設定</p><p>跑不起來的話, 看看 samba 狀態</p><pre><code>systemctl status samba </code></pre><p>如果出現</p><pre><code>&gt; I disabled starting &quot;samba&quot; and enabled only smbd.service and nmbd.service.&gt; Now I can see Raspberry in my second computer, but I cant connect to it, &gt; it fails with &quot;you have no permission to connect&quot;</code></pre><p>代表你需要帳號密碼</p><p>samba 需要帳號密碼存取</p><pre><code>smbpasswd -a pi</code></pre><p>其中pi是要已經存在的帳號，這樣一來應該就可以成功啟動 samba </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;簡短的紀錄一下 Raspberry pi 如何安裝 Archlinux，並且使用 pacman 安裝幾個套件  &lt;/p&gt;
&lt;p&gt;一樣去下載頁面下載 arch linux OS 回來後，解壓縮可以得到 img 檔，
安裝完後，開機，使用使用 pietty(talnet 軟體) 連線後登入，此時的安裝方式都與 wheezy 相同  &lt;/p&gt;
&lt;h1 id=&quot;更新-pacman&quot;&gt;&lt;a href=&quot;#更新-pacman&quot; class=&quot;headerlink&quot; title=&quot;更新 pacman&quot;&gt;&lt;/a&gt;更新 pacman&lt;/h1&gt;&lt;p&gt;要先更新 pacman ，否則某些套件會找不到&lt;/p&gt;
&lt;p&gt;輸入以下指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pacman -Syy
pacman -Syu&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>Policy-Based Programming</title>
    <link href="http://wwssllabcd.github.io/2013/10/08/policy-based-template-programming/"/>
    <id>http://wwssllabcd.github.io/2013/10/08/policy-based-template-programming/</id>
    <published>2013-10-08T11:02:00.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>考慮以下的 code 是<code>找出vector&quot;中，相同的item出來，並放在另一個vector中</code>，但是有時後放入vector 的item是 native type( 如 int， char， 等)，有時卻是使用pair type，而這兩個 template 基本上只差在一個地方，就是取 addr 的部份，一個 native 版本是直接取，如<code>addr = (*iDBlock);</code> ，而 pair 版本是取他的 first 出來，如 <code>addr = (*iDBlock).first;</code></p><p>Native type 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt;bool flag, class T, class U&gt;</span><br><span class="line">static void findDupItem(vector&lt;T&gt;&amp; source, vector&lt;U&gt;&amp; dupColl)&#123;</span><br><span class="line">typename vector&lt;T&gt;::iterator iDBlock;</span><br><span class="line">dupColl.clear();</span><br><span class="line"></span><br><span class="line">T addr&#x3D;0;</span><br><span class="line"></span><br><span class="line">for(iDBlock &#x3D; source.begin(); iDBlock!&#x3D;source.end(); iDBlock++)&#123;</span><br><span class="line">addr &#x3D; (*iDBlock);</span><br><span class="line">if( _isHit( addr ) &#x3D;&#x3D; true )&#123;</span><br><span class="line">dupColl.push_back((*iDBlock));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pair 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class T, class U &gt;</span><br><span class="line">static void findDupItem(vector&lt; pair&lt;T, U&gt; &gt;&amp; source, vector&lt; pair&lt;T, U&gt; &gt;&amp; dupColl)&#123;</span><br><span class="line">typename vector&lt; pair&lt;T, U&gt;  &gt;::iterator iDBlock;</span><br><span class="line">dupColl.clear();</span><br><span class="line"></span><br><span class="line">T addr&#x3D;0;</span><br><span class="line">for(iDBlock &#x3D; source.begin(); iDBlock!&#x3D;source.end(); iDBlock++)&#123;</span><br><span class="line">addr &#x3D; (*iDBlock).first;</span><br><span class="line">if( _isHit( addr) &#x3D;&#x3D; true )&#123;</span><br><span class="line">dupColl.push_back((*iDBlock));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>基本上 99% 的東西都一樣，違反 DRY( Don&#39;t repeat yourself)原則，但那要如何把他合併起來呢？使用一個 flag 也許可以解決問題</p><pre><code>if ( isPairType )&#123;    addr = (*iDBlock).first;&#125;else&#123;    addr = (*iDBlock);&#125;</code></pre><p>這解法我們早就做過 N 遍了--   一個醜陋但堪用的解法<br>你我都知道，這個解法一旦複雜度變高可能會變得難以 maintain，接下來就是看誰倒楣</p><p>也許一個 function pointer 去包裝他可能是一個好方法，如</p><pre><code>static void findDupItem(vector&lt; pair&lt;T, U&gt; &gt;&amp; source, vector&lt; pair&lt;T, U&gt; &gt;&amp; dupColl, FP pFun )&#123;..略..for(iDBlock = source.begin(); iDBlock!=source.end(); iDBlock++)&#123;    addr = pFun(iDBlock);    ..略..&#125;</code></pre><p>嗯，是可以解，但沒有驚喜，有沒有一個更好的解法呢？</p><h1 id="Policy-Based-Programming"><a href="#Policy-Based-Programming" class="headerlink" title="Policy-Based Programming"></a>Policy-Based Programming</h1><p><a href="http://zh.wikipedia.org/zh-tw/%E5%9F%BA%E6%96%BC%E5%8E%9F%E5%89%87%E8%A8%AD%E8%A8%88">Policy-Based Class Design</a>首見於 Andrei Alexandrescu 出版的 《Modern C++ Design》一書，詳細的內容可以參考該書的第一章(見本篇後記)。     </p><ul><li><p>Interface design 的缺點<br>Interface design 不是不好， Interface design 有時也會出現力有未逮的情況，當軟體規模擴大到一定程度時，有時會很難避免出現某些 sub class 繼承 interface 時，不需要該 interface 的某些 constraints(約束條件)，對於實務上遇到這種況狀，通常會故意忽略掉那些參數(例如傳一個 Null 值進去)，好讓 compiler 可以順利編譯，這種語法有效，但語意無效的介面意味著 interface 出現過度設計的 bad smell。    </p></li><li><p>把每個功能切割成為小class<br>對於 interface 出現過度設計的狀況，縮小設計規模可能是一種解法，但是這種作法又會產生大量的設計組合，以 smart point 為例，你就會有一堆 class 如下   </p></li></ul><pre><code>SingleThreadSmartPtr  MultiThreadSmartPtr  RefCountSmartPtr   RefLinkSmartPrt  </code></pre><p>若增加一個選項則會面臨大量設計組合，複雜度曲線上升  </p><ul><li>利用多重繼承來處理設計組合？<br>若是利用繼承 BaseSmartPoint去組合SingleThread，RefCount 這些 class 所產生的 SmartPoint，的確是可以讓設計組合降低，但除非設計單純，否則大多數得小心繼承帶來的痛苦，特別是要去協調那些 class的運轉，就實務上來說繼承並不討喜。  </li></ul><p>繼承組合而來的 class 面對著型別又有著困擾，假設你使用一個 DeepCopy Class 來為你的 SmartPointer 實作 DeepCopy，但是 DeepCopy 是怎樣的介面呢？ 舉例來說，假設他要回傳某個東西，那回傳的 type 又是什麼？   </p><p>多重繼承本質上的確是一種<code>組合</code>，但似乎沒有辦法單獨的解決這種問題，特別是 user 在設計時，面對型別的多樣性。   </p><ul><li>Template 帶來曙光<br>哪裡型別最多？就是 Template，那裡擁有大量的型別，而這兩種設計並不衝突，有時還相輔相成，比較一下多重繼承與 template，例如 多重繼承 往往缺乏型別，而 temaplte 擁有大量型別。   </li></ul><p>而且一個良好的設計應該在編譯時期強制表現出大部分的 constraints (約束條件)，而 Template 剛好可以在 compile time 表現出 constraints 的機制。   </p><p>用多重繼承 + template 來實現有機會產生非常彈性的裝置來當作我們的設計元素。</p><h1 id="實作-Policy-Classes-Design"><a href="#實作-Policy-Classes-Design" class="headerlink" title="實作 Policy Classes Design"></a>實作 Policy Classes Design</h1><p>根據上述的解釋，修改 code 如下  </p><p>先把 GetItem使用 Policy class 封裝起來，由於我們不知道他的 ReturnType 與 Collection 的 Iterator 是什麼，反正缺 Type 就往 Template 那邊找就對了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt; typename Iter, class RT &gt;</span><br><span class="line">struct GetNornalData&#123;</span><br><span class="line">static RT getItem(Iter iter)&#123;</span><br><span class="line">return (*iter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt; typename Iter, class RT &gt;</span><br><span class="line">struct GetPair_first&#123;</span><br><span class="line">static RT getItem(Iter iter)&#123;</span><br><span class="line">return (*iter).first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以 vector<int> 來說，這邊的 ReturnType 就是 Int， 而 iter 就是 Vector<int>::iterator 了，有了policy，接下來就可以改寫 main function 了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class T, class ReturnType, class GetDataPolicy &gt;</span><br><span class="line">class FindDpu : public GetDataPolicy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">static void run(vector&lt;T&gt;&amp; source, vector&lt;T&gt;&amp; duplicateColl)&#123;</span><br><span class="line">typedef vector&lt;T&gt;::iterator Iter;</span><br><span class="line"></span><br><span class="line">Iter iter;</span><br><span class="line">ReturnType addr&#x3D;0;</span><br><span class="line"></span><br><span class="line">...略...</span><br><span class="line"></span><br><span class="line">for(iter &#x3D; source.begin(); iter!&#x3D;source.end(); iter++)&#123;</span><br><span class="line">addr &#x3D; getItem(iter); &#x2F;&#x2F; 利用繼承而獲得的 function</span><br><span class="line">...略...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用的時候如下，先宣告你要那個 Policy，再利用 Policy 去產生哪種 FindDpu class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; source, target;</span><br><span class="line">typedef GetNornalData&lt; vector&lt;int&gt;::iterator, int &gt; Policy;</span><br><span class="line"></span><br><span class="line">FindDpu&lt; int, int, Policy &gt;  fvpd_int;</span><br><span class="line">fvpd_int.run(source, target);</span><br></pre></td></tr></table></figure><p>如果是 pair 的時候，可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;char, char&gt; MyPairType;</span><br><span class="line"></span><br><span class="line">vector&lt;MyPairType&gt; source, target;</span><br><span class="line">typedef GetPair_first&lt; vector&lt;MyPairType&gt;::iterator, MyPairType::first_type &gt; Policy;</span><br><span class="line"></span><br><span class="line">FindDpu&lt; MyPairType, char, Policy &gt; fvpd_pair;</span><br><span class="line">fvpd_pair.run(source, target);</span><br></pre></td></tr></table></figure><h1 id="一點也不美麗的呼叫方式"><a href="#一點也不美麗的呼叫方式" class="headerlink" title="一點也不美麗的呼叫方式"></a>一點也不美麗的呼叫方式</h1><p>的確是使用了 Policy，但使用上前置作業要好幾行，在使用之前先宣告想要的 Policy，呼叫的時候傳入Policy ，這似乎合情合理，但使用 pair 的時候傳入 pair policy，使用int的時候傳入 int Policy 又顯得多餘又危險 -- 我總不可能使用 vector &lt; pair &gt; 傳入 int Policy 吧？</p><h1 id="模版偏特化-partial-specialization"><a href="#模版偏特化-partial-specialization" class="headerlink" title="模版偏特化( partial specialization )"></a>模版偏特化( partial specialization )</h1><p>能不能看到我傳 pair 的時候就預設 pair Policy 呢？翻了一下書，利用模版偏特化( partial specialization )也許有機會</p><p>可以看以下例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">Class Test;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">Class Test&lt;char&gt;&#123;</span><br><span class="line">typedef char ReturnType;</span><br><span class="line">string show()&#123;</span><br><span class="line">pringf(&quot;ReturnType &#x3D; char&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">Class Test&lt;int&gt;&#123;</span><br><span class="line">typedef int ReturnType;</span><br><span class="line">string show()&#123;</span><br><span class="line">pringf(&quot;ReturnType &#x3D; int&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此時如果使用</p><pre><code>Test&lt;char&gt; t;t.show()</code></pre><p>則會顯示</p><pre><code>`ReturnType = char`</code></pre><p>compiler 藉由型別推導選擇了不同的 class，看來我們有機會藉由輸入不同的 Type，而去選擇不同的 Class </p><h1 id="重新打造-Policy-Class"><a href="#重新打造-Policy-Class" class="headerlink" title="重新打造 Policy Class"></a>重新打造 Policy Class</h1><p>根據我們傳入的 T，利用 compiler 型別推導機制，來幫 Policy 作偏特化，藉以自動選擇哪種 Policy，重新設計 Policy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename RT &gt; </span><br><span class="line">struct GetDataPolicy;</span><br><span class="line"></span><br><span class="line">template&lt; typename RT&gt; </span><br><span class="line">struct GetDataPolicy &lt; std::vector&lt; RT &gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">...略...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt; typename RT, typename U &gt; </span><br><span class="line">struct GetDataPolicy &lt; std::vector&lt; std::pair&lt;RT, U&gt; &gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">...略...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這樣一來，只有 <code>T = pair&lt;RT, U&gt;</code> 的時候，compiler 會自動推導 pair Policy 為最佳解，其餘的都是 vector&lt; RT &gt; 解，而且是符合最佳解的才會被編譯出來，也就是說，沒用到的 compiler 根本就不會編譯他  </p><p>回到主程式來，先利用預設模版，然後拿 T 當作 Policy 的參數，而 compiler 會拿 T 去 Policy 作型別推導找出最佳解出來  </p><pre><code>template&lt; class T, class ReturnType, class GetDataPolicy&lt;T&gt; &gt;class FindDuplicateItem : public Policy&#123;    ...略...&#125;</code></pre><h1 id="拿掉多餘的-template-parameter-使用-Traits"><a href="#拿掉多餘的-template-parameter-使用-Traits" class="headerlink" title="拿掉多餘的 template parameter -- 使用 Traits"></a>拿掉多餘的 template parameter -- 使用 Traits</h1><p>觀察 main function 中的 ReturnType</p><pre><code>template&lt; class T, class ReturnType, class GetDataPolicy&lt;T&gt; &gt;class FindDuplicateItem : public Policy&#123;    ...略...&#125;</code></pre><p>基本上 ReturnType 也是一開始就知道的資訊，若使用偏特化的機制，也是讓我們有機會拿掉他，檢視一下整個程式可能會需要用到的 Type  </p><ul><li>getItem 所用到的 ReturnType</li><li>用以作for 迴圈的 vector<T>::iterator</li></ul><p>只要在 Policy 中重新定義就好</p><pre><code>template&lt; typename RT&gt; struct GetDataPolicy &lt; std::vector&lt; RT &gt; &gt;    &#123;    typedef typename RT ReturnType;    typedef typename std::vector&lt; RT &gt;::iterator CollItor;    ...略...&#125;;</code></pre><p>甚至可以建立一個專門作 Trais 的 template，這樣一來所需要的資訊都在 Traits 裡面了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt; typename Return_Type, typename Colls_Iter  &gt; </span><br><span class="line">struct GetDataPolicyTraits</span><br><span class="line">&#123;</span><br><span class="line">typedef typename Return_Type  ReturnType;</span><br><span class="line">typedef typename Colls_Iter   CollsIter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt; typename RT&gt; </span><br><span class="line">struct GetDataPolicy &lt; std::vector&lt; RT &gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">typedef GetDataPolicyTraits&lt;RT, typename std::vector&lt;RT&gt;::iterator&gt; Traits;</span><br><span class="line">typename Traits::ReturnType getItem(typename Traits::CollsIter iter)&#123;</span><br><span class="line">return (*iter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 main function 中，使用的時候像這樣</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt; typename T, typename Policy &#x3D; GetDataPolicy&lt;T&gt; &gt;</span><br><span class="line">class FindDuplicateItem : public Policy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void run(T&amp; source, T&amp; duplicateColl)&#123;</span><br><span class="line">Policy::Traits::CollsIter  iter;</span><br><span class="line">Policy::Traits::ReturnType addr&#x3D;0;</span><br><span class="line">...略...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有趣的是，明明 main function 傳入的是一個被泛化的 Type T，居然可以取出<code>std::vector&lt; RT &gt;</code> 或是<code>std::vector&lt; std::pair&lt;RT, U&gt; &gt;</code>的 ReturnType 與 Iterator</p><p>Traits 是一種<code>把T丟進去某個特徵萃取機制中，取出特定特徵</code>的技巧，當然不僅僅只是定義 type 而已，參考以下程式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class TypeTraits</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">template &lt;class U&gt; struct PointerTraits</span><br><span class="line">&#123;</span><br><span class="line">enum &#123; result &#x3D; false &#125;;</span><br><span class="line">typedef NullType PointeeType;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;class U&gt; struct PointerTraits&lt;U*&gt;</span><br><span class="line">&#123;</span><br><span class="line">enum &#123; result &#x3D; true &#125;;</span><br><span class="line">typedef U PointeeType;</span><br><span class="line">&#125;;</span><br><span class="line">public:</span><br><span class="line">enum &#123; isPointer &#x3D; PointerTraits&lt;T&gt;::result &#125;;</span><br><span class="line">typedef PointerTraits&lt;T&gt;::PointeeType PointeeType;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>現在我們可以來猜看看，vector<int>::iterator 是不是int 的 pointer ?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const bool iterIsPtr &#x3D; TypeTraits&lt; vector&lt;int&gt;::iterator &gt;::isPointer;</span><br><span class="line">cout &lt;&lt; &quot;vector&lt;int&gt;::iterator is &quot; &lt;&lt; iterIsPtr ? &quot;fast&quot; : &quot;smart&quot; &lt;&lt; &#39;\n&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="把一切組裝起來"><a href="#把一切組裝起來" class="headerlink" title="把一切組裝起來"></a>把一切組裝起來</h1><p>藉由 Traits 把缺的 main function 中的 Type 給補足</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">template&lt; typename Return_Type, typename Colls_Iter  &gt; </span><br><span class="line">struct GetDataPolicyTraits</span><br><span class="line">&#123;</span><br><span class="line">typedef typename Return_Type  ReturnType;</span><br><span class="line">typedef typename Colls_Iter   CollsIter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename RT &gt; </span><br><span class="line">struct GetDataPolicy;</span><br><span class="line"></span><br><span class="line">template&lt; typename RT&gt; </span><br><span class="line">struct GetDataPolicy &lt; std::vector&lt; RT &gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">typedef GetDataPolicyTraits&lt;RT, typename std::vector&lt;RT&gt;::iterator&gt; Traits;</span><br><span class="line">typename Traits::ReturnType getItem(typename Traits::CollsIter iter)&#123;</span><br><span class="line">return (*iter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt; typename RT, typename U &gt; </span><br><span class="line">struct GetDataPolicy &lt; std::vector&lt; std::pair&lt;RT, U&gt; &gt; &gt;</span><br><span class="line">&#123;</span><br><span class="line">typedef GetDataPolicyTraits&lt; RT, typename std::vector&lt; std::pair&lt;RT, U&gt; &gt;::iterator &gt; Traits;</span><br><span class="line">typename Traits::ReturnType getItem(typename Traits::CollsIter iter)&#123;</span><br><span class="line">return (*iter).first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt; typename T, typename Policy &#x3D; GetDataPolicy&lt;T&gt; &gt;</span><br><span class="line">class FindDuplicateItem : public Policy</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void run(T&amp; source, T&amp; duplicateColl)&#123;</span><br><span class="line">Policy::Traits::CollsIter  iter;</span><br><span class="line">Policy::Traits::ReturnType addr&#x3D;0;</span><br><span class="line"></span><br><span class="line">duplicateColl.clear();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;let sorting time approach to Big(1) by bitMap</span><br><span class="line">const size_t MAP_SIZE &#x3D; 0x80000;</span><br><span class="line">BYTE map[MAP_SIZE]&#x3D;&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">for(iter &#x3D; source.begin(); iter!&#x3D;source.end(); iter++)&#123;</span><br><span class="line">addr &#x3D; this-&gt;getItem(iter);</span><br><span class="line">if( _isHit( addr, map, MAP_SIZE) &#x3D;&#x3D; true )&#123;</span><br><span class="line">duplicateColl.push_back((*iter));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">bool _isHit(ULONG value, BYTE* pMap, size_t mapSize)&#123;</span><br><span class="line"></span><br><span class="line">if( value &gt;&#x3D;mapSize)&#123;</span><br><span class="line">throw MyException(UTI_PARAM_ERROR, &quot;value&gt;&#x3D;mapSize&quot;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool result &#x3D; true;</span><br><span class="line">if( pMap[ value ] &#x3D;&#x3D;0)&#123;</span><br><span class="line">pMap[ value ] &#x3D;1;</span><br><span class="line">result &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>呼叫的時候，也只要傳入最低限度的type即可</p><pre><code>vector&lt;int&gt; source, target;FindDuplicateItem&lt; vector&lt;int&gt; &gt; fvpd;fvpd.run(source, target);</code></pre><p>這邊沒有選擇使用<code>template template parameter</code>的方式去作，是因為我希望可以在源頭就直接抽換掉 Policy Class 而不受到 &lt; T &gt; 的影響。</p><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>其實對於軟體工程而言，完成一件事情可以用很多種不同的作法，而且解法似乎一樣好，但是也許就是選擇太多，導致沒經驗的工程師選擇了對未來有 side effect 的方案，導致專案越來越難進行，這只是一個簡單的 template ，幹嘛搞的那麼複雜，主要的還是觀念上的改變 -- 使用 if else 與使用 Policy 的區別， </p><p>以下兩個 link 對於 Policy-Based Class Design 我覺得寫的很好，版主很用心再寫，可以參考看看  </p><ul><li><a href="http://blog.monkeypotion.net/gameprog/beginner/exploring-the-field-of-policy-based-class-design">探索Policy-Based Class Design新視界</a>  </li><li><a href="http://blog.monkeypotion.net/gameprog/advanced/diving-into-policy-based-class-design">深入Policy-Based Class Design新大陸</a>  </li></ul><p>本篇很多案例是參考 <a href="http://jjhou.boolan.com/jjtbooks-modern-cpp-design.htm">Modern C++ Design</a>，及 <a href="http://shopping.pchome.com.tw/?mod=item&func=exhibit&IT_NO=DJAR0F-A16046100">C++ template 全覽</a>，</p><p>而 Policy-based programming 在 Modern C++ Design 的 ch1 有詳細的介紹，棒的是，侯傑有 <a href="http://jjhou.boolan.com/jjtbooks-modern-cpp-design.htm">ch1~ch4 的預覽版本可供下載</a>(真的是佛心來著)，有興趣的朋友可以參考看看</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;考慮以下的 code 是&lt;code&gt;找出vector&amp;quot;中，相同的item出來，並放在另一個vector中&lt;/code&gt;，
但是有時後放入vector 的item是 native type( 如 int， char， 等)，有時卻是使用pair type，
而這兩個 template 基本上只差在一個地方，就是取 addr 的部份，
一個 native 版本是直接取，如&lt;code&gt;addr = (*iDBlock);&lt;/code&gt; ，而 pair 版本是取他的 first 出來，如 &lt;code&gt;addr = (*iDBlock).first;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Native type 版本&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;template&amp;lt;bool flag, class T, class U&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static void findDupItem(vector&amp;lt;T&amp;gt;&amp;amp; source, vector&amp;lt;U&amp;gt;&amp;amp; dupColl)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	typename vector&amp;lt;T&amp;gt;::iterator iDBlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dupColl.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	T addr&amp;#x3D;0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for(iDBlock &amp;#x3D; source.begin(); iDBlock!&amp;#x3D;source.end(); iDBlock++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		addr &amp;#x3D; (*iDBlock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if( _isHit( addr ) &amp;#x3D;&amp;#x3D; true )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			dupColl.push_back((*iDBlock));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Pair 版本&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;template&amp;lt; class T, class U &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static void findDupItem(vector&amp;lt; pair&amp;lt;T, U&amp;gt; &amp;gt;&amp;amp; source, vector&amp;lt; pair&amp;lt;T, U&amp;gt; &amp;gt;&amp;amp; dupColl)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	typename vector&amp;lt; pair&amp;lt;T, U&amp;gt;  &amp;gt;::iterator iDBlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	dupColl.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	T addr&amp;#x3D;0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for(iDBlock &amp;#x3D; source.begin(); iDBlock!&amp;#x3D;source.end(); iDBlock++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		addr &amp;#x3D; (*iDBlock).first;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if( _isHit( addr) &amp;#x3D;&amp;#x3D; true )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			dupColl.push_back((*iDBlock));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://wwssllabcd.github.io/tags/C/"/>
    
    <category term="Modern C++ Design" scheme="http://wwssllabcd.github.io/tags/Modern-C-Design/"/>
    
  </entry>
  
  <entry>
    <title>讓 Raspberry pi 變成多媒體播放機 -- 安裝Raspbmc</title>
    <link href="http://wwssllabcd.github.io/2013/04/22/how-to-setup-raspbmc-in-raspberry-pi/"/>
    <id>http://wwssllabcd.github.io/2013/04/22/how-to-setup-raspbmc-in-raspberry-pi/</id>
    <published>2013-04-22T08:26:00.000Z</published>
    <updated>2015-12-18T12:52:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>RPi可以透過安裝 XBMC，讓自己可以變成類似 <a href="http://www.himedia-tech.cn/">海美迪(Himedia)</a> 那種高清播放機的功能，也有插件可以看PPS等網路電視，不過他不像 transmission、samba等 service 只要裝套件就好了，必須要安裝他們的OS image，所以比較常見的方法是再拿一張SD卡專門使用</p><h1 id="安裝-RaspBMC"><a href="#安裝-RaspBMC" class="headerlink" title="安裝 RaspBMC"></a>安裝 RaspBMC</h1><h2 id="下載與安裝"><a href="#下載與安裝" class="headerlink" title="下載與安裝"></a>下載與安裝</h2><p>到<a href="http://www.raspbmc.com/">Raspbmc</a>網站下載image，下載有兩種方式  </p><ul><li>一種是下載16mb大小的前導，安裝完後，他會自己下載剩下的程式安裝  </li><li>Standalone Image 是下載完整的離線安裝檔  </li></ul><p>我推薦下載<a href="http://download.raspbmc.com/downloads/bin/filesystem/prebuilt/raspbmc-final.img.gz">Standalone Image</a>，因為有時後用前導的方式會下載很久，Standalone Image的檔案下載回來後解壓縮，會得到一個img file，安裝的方式就跟官方OS一樣，使用<a href="https://launchpad.net/win32-image-writer/+download">Win32DiskImager</a>寫入即可</p><p>寫入完成後，插上RPI並接上網路，等個10min，就差不多安裝好了，基本上安裝不會有什麼大問題，順利的話，就會直接進入到 XBMC 的畫面。</p><a id="more"></a><h2 id="HDMI-設定問題"><a href="#HDMI-設定問題" class="headerlink" title="HDMI 設定問題"></a>HDMI 設定問題</h2><p>若你的顯示器比較新可能就不會有問題，若是比較舊的就有可能無法正常顯示，  </p><p>有時候顯示裝置老舊， 就必須要特別設定hdmi參數，首先找到 SD 卡根目錄下面的<code>config.txt</code>，打開來， 開始設定參數(若找不到該參數， 則自己加上去即可)設定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sdtv_mode &#x3D; 0</span><br><span class="line">sdtv_aspect &#x3D; 3</span><br><span class="line">hdmi_group &#x3D; 1</span><br><span class="line">hdmi_mode &#x3D; 1</span><br></pre></td></tr></table></figure><p>sdtv_aspect 代表你的螢幕比例，定義如下</p><pre><code>sdtv_aspect=1  4:3sdtv_aspect=2  14:9sdtv_aspect=3  16:9</code></pre><p>hdmi_group=1 及 hdmi_mode=1 是代表使用 CEA + VGA 模式， 通常設定完 HDMI 會以最低標準顯示，這兩個參數模式的組合在<a href="http://elinux.org/RPi_config.txt#Video_mode_options">RPi_config.txt Video_mode_options)</a>有列出來，這裡不再解釋</p><p>接下來你可以讓 RPI抓你的螢幕有哪些模式可以選，輸入以下指令</p><pre><code>/opt/vc/bin/tvservice -d edid.dat/opt/vc/bin/edidparser edid.dat</code></pre><p>edidparser 會列出建議的組合，照著設定就可以了</p><h1 id="登入-Raspbmc"><a href="#登入-Raspbmc" class="headerlink" title="登入 Raspbmc"></a>登入 Raspbmc</h1><h2 id="遠端控制-Raspbmc"><a href="#遠端控制-Raspbmc" class="headerlink" title="遠端控制 Raspbmc"></a>遠端控制 Raspbmc</h2><p>當你順利的進入到主畫面，除了利用滑鼠鍵盤操作外，XBMC 也提供方便的遠端控制，只要在瀏覽器上面，輸入Raspbmc的 ip 即可，如 <a href="http://192.168.0.20/">http://192.168.0.20/</a>  ，就可以用網頁的方式遙控 XBMC，也可以用手機遙控 XBMC，裝一個叫XBMC remote 的軟體即可</p><h2 id="改成中文選單"><a href="#改成中文選單" class="headerlink" title="改成中文選單"></a>改成中文選單</h2><p>切換成中文前，要先選擇字體，因為預設的字體不能顯示中文，在<code>system/ settings/ appearance/ skin / fonts</code>，選擇 <code>arial based</code> 即可，這樣在英文界面下也可看到中文字</p><p>接著切換成中文選單，選取 <code>system/ settings/ appearance/ international/ language</code> 後，選擇 <code>Chinese Traditional</code> 即可</p><h2 id="校正螢幕"><a href="#校正螢幕" class="headerlink" title="校正螢幕"></a>校正螢幕</h2><p>若你的螢幕顯示不太正確，像是歪掉，上下左右沒對齊的可以在 <code>系統/ 視訊輸出/ 視訊校正</code> 這邊做出校正，選取之後，他可以讓你手動拉拉右上角與左下的，以調整視訊的範圍  </p><p>我的心得是，先拉左上角與右下角，先把它拉小，可以先看出整個畫面是長怎樣的之後， 再去做調整，中間的部分是拉一個正方形出來，正下方的部分是拉字幕的高度</p><h2 id="新增播放影片"><a href="#新增播放影片" class="headerlink" title="新增播放影片"></a>新增播放影片</h2><p>這邊以 window 8 的共享資料夾內的影片來當作例子，首先你必須先建立好共享資料夾(這不再贅述)，在<code>新增視訊來源</code>的介面上， 選瀏覽後，選擇<code>window網路 (SMB)</code>，找到你 share 的網路與 folder 後， 看一下下方是否有顯示<code>smb://MyPC/ShareFD/</code>，如果有，就按下確定鍵( 代表你選擇這個目錄)，接著你會回到<code>新增視訊來源</code>那邊，再按下&quot;確定&quot;就可以了</p><p>注意:  </p><pre><code>windows 8 即使在共享資料夾那邊選擇存取帳號為 everyone 時，也是需要帳號密碼，若是不想要輸入網路資料夾的密碼的話，則必須要關閉 windows 8 分享資料夾密碼保護的功能，若要以 window 8 的檔案撥放的話，要關掉共用密碼保護設定  </code></pre><p><code>選擇網路和網際網路/網路和共用中心/變更進階共用設定/所有網路</code>在<code>以密碼保護的共用</code>項目下，勾選<code>關閉以密碼保護的共用</code>，按<code>儲存變更</code>。這樣分享的資料夾就可以使用 everyone 而不用輸入密碼了</p><h2 id="安裝PPS等插件"><a href="#安裝PPS等插件" class="headerlink" title="安裝PPS等插件"></a>安裝PPS等插件</h2><p>使用 terminal 登入後，使用 wget 下載<a href="https://code.google.com/p/xbmc-addons-chinese/">XBMC媒體中心的中文擴展功能腳本</a>回來後，到設定那邊安裝即可</p><h2 id="修改遠端密碼"><a href="#修改遠端密碼" class="headerlink" title="修改遠端密碼"></a>修改遠端密碼</h2><p>建議還是用 terminal 登入進去改一下帳號密碼就是了遠端的帳號密碼預設還是 pi/ raspberry，第一次登入會強制執行語言與地區的設定，就跟 RPI設定一樣，選 <code>en_us.utf8</code> 與 <code>zh_tw.utf8</code> 即可，預設為 <code>en_us.utf8</code>，設定好之後，回到 terminal 畫面後再輸入 <code>sudo passwd</code> ，改變登入的密碼</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://learning.wingsv.org/raspberry-pi-%E7%B0%A1%E6%98%93%E5%AE%89%E8%A3%9D-xbmc/">Raspberry Pi 簡易安裝 XBMC</a><br><a href="https://vistb.net/2012/12/raspberrypi-tour-use-raspbmc-build-htpc/">Raspberry Pi 使用手記 -- 簡介及利用Raspbmc搭建媒體播放器</a><br><a href="http://blog.sina.com.cn/s/blog_6ab7ecff0101afot.html">Raspberry Pi的HDMI輸出問題解法</a><br><a href="http://elinux.org/RPi_config.txt#Video_mode_options">RPiconfig</a><br><a href="https://code.google.com/p/xbmc-addons-chinese/">XBMC媒體中心的中文擴展功能腳本</a><br><a href="http://support2.microsoft.com/kb/2702421/zh-tw">如何解決連接至已經設定允許 Everyone 讀取的共用資料夾時，仍出現詢問帳號密碼對話視窗</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RPi可以透過安裝 XBMC，讓自己可以變成類似 &lt;a href=&quot;http://www.himedia-tech.cn/&quot;&gt;海美迪(Himedia)&lt;/a&gt; 那種高清播放機的功能，也有插件可以看PPS等網路電視，
不過他不像 transmission、samba等 service 只要裝套件就好了，必須要安裝他們的OS image，所以比較常見的方法是再拿一張SD卡專門使用&lt;/p&gt;
&lt;h1 id=&quot;安裝-RaspBMC&quot;&gt;&lt;a href=&quot;#安裝-RaspBMC&quot; class=&quot;headerlink&quot; title=&quot;安裝 RaspBMC&quot;&gt;&lt;/a&gt;安裝 RaspBMC&lt;/h1&gt;&lt;h2 id=&quot;下載與安裝&quot;&gt;&lt;a href=&quot;#下載與安裝&quot; class=&quot;headerlink&quot; title=&quot;下載與安裝&quot;&gt;&lt;/a&gt;下載與安裝&lt;/h2&gt;&lt;p&gt;到&lt;a href=&quot;http://www.raspbmc.com/&quot;&gt;Raspbmc&lt;/a&gt;網站下載image，下載有兩種方式  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一種是下載16mb大小的前導，安裝完後，他會自己下載剩下的程式安裝  &lt;/li&gt;
&lt;li&gt;Standalone Image 是下載完整的離線安裝檔  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我推薦下載&lt;a href=&quot;http://download.raspbmc.com/downloads/bin/filesystem/prebuilt/raspbmc-final.img.gz&quot;&gt;Standalone Image&lt;/a&gt;，因為有時後用前導的方式會下載很久，
Standalone Image的檔案下載回來後解壓縮，會得到一個img file，安裝的方式就跟官方OS一樣，使用&lt;a href=&quot;https://launchpad.net/win32-image-writer/+download&quot;&gt;Win32DiskImager&lt;/a&gt;寫入即可&lt;/p&gt;
&lt;p&gt;寫入完成後，插上RPI並接上網路，等個10min，就差不多安裝好了，基本上安裝不會有什麼大問題，順利的話，就會直接進入到 XBMC 的畫面。&lt;/p&gt;</summary>
    
    
    
    
    <category term="How-To" scheme="http://wwssllabcd.github.io/tags/How-To/"/>
    
    <category term="Raspberry Pi" scheme="http://wwssllabcd.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
</feed>
